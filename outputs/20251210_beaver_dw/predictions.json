[
    {
        "db_id": "dw",
        "question": "What is the current building key, building street address, city, state, and postal code of the history department?",
        "predicted_sql": "SELECT \n    BUILDINGS.BUILDING_KEY, \n    BUILDINGS.BUILDING_STREET_ADDRESS, \n    FCLT_BUILDING_ADDRESS.CITY, \n    FCLT_BUILDING_ADDRESS.STATE, \n    FCLT_BUILDING_ADDRESS.POSTAL_CODE \nFROM \n    BUILDINGS \nJOIN \n    FCLT_BUILDING_ADDRESS ON BUILDINGS.BUILDING_KEY = FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY \nJOIN \n    FCLT_ROOMS ON FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY \nJOIN \n    FCLT_ORG_DLC_KEY ON FCLT_ROOMS.FCLT_ORGANIZATION_KEY = FCLT_ORG_DLC_KEY.FCLT_ORGANIZATION_KEY \nJOIN \n    MASTER_DEPT_HIERARCHY ON FCLT_ORG_DLC_KEY.DLC_KEY = MASTER_DEPT_HIERARCHY.DLC_KEY \nWHERE \n    MASTER_DEPT_HIERARCHY.DLC_NAME = 'History Department';"
    },
    {
        "db_id": "dw",
        "question": "Show the unique activity titles, locations, term start date, and supervisor name for all independent activities, sorted by the ascending order of start date.",
        "predicted_sql": "SELECT DISTINCT \n    IAD.ACTIVITY_TITLE, \n    ISS.SESSION_LOCATION, \n    ATA.TERM_START_DATE, \n    ISP.PERSON_NAME\nFROM \n    IAP_SUBJECT_DETAIL IAD\nJOIN \n    IAP_SUBJECT_SESSION ISS ON IAD.IAP_SUBJECT_SESSION_KEY = ISS.IAP_SUBJECT_SESSION_KEY\nJOIN \n    ACADEMIC_TERMS_ALL ATA ON IAD.TERM_CODE = ATA.TERM_CODE\nJOIN \n    IAP_SUBJECT_PERSON ISP ON IAD.IAP_SUBJECT_PERSON_KEY = ISP.IAP_SUBJECT_PERSON_KEY\nWHERE \n    ISP.PERSON_ROLE = 'Activity leader'\nORDER BY \n    ATA.TERM_START_DATE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the unique course instructor names, course titles, and the amount of material for each course instructor key and the key of subject offered.",
        "predicted_sql": "SELECT \n    DISTINCT LCI.INSTRUCTOR_NAME,\n    LSO.SUBJECT_TITLE,\n    COUNT(LRCD.CATALOG_ISBN) AS material_count\nFROM \n    LIBRARY_COURSE_INSTRUCTOR LCI\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED LSO ON LRMD.LIBRARY_SUBJECT_OFFERED_KEY = LSO.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRCD ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRCD.LIBRARY_RESERVE_CATALOG_KEY\nGROUP BY \n    LCI.INSTRUCTOR_NAME,\n    LSO.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "What is the room, floor, building key, building street address, city, state, and postal code of Professor Summer Haynes's office?",
        "predicted_sql": "SELECT \n    fr.ROOM, \n    fr.FLOOR, \n    fr.BUILDING_KEY, \n    b.BUILDING_STREET_ADDRESS, \n    fba.CITY, \n    fba.STATE, \n    fba.POSTAL_CODE \nFROM \n    EMPLOYEE_DIRECTORY ed \nJOIN \n    FAC_ROOMS fr ON ed.OFFICE_LOCATION = fr.FAC_ROOM_KEY \nJOIN \n    FAC_BUILDING_ADDRESS fba ON fr.BUILDING_KEY = fba.BUILDING_KEY \nJOIN \n    BUILDINGS b ON b.BUILDING_KEY = fba.BUILDING_KEY \nWHERE \n    ed.FULL_NAME = 'Summer Haynes';"
    },
    {
        "db_id": "dw",
        "question": "List the unique full room names, their corresponding building names, street addresses, cities, states, postal codes, and building heights for rooms associated with subjects that Computer Science students can enroll in.",
        "predicted_sql": "SELECT DISTINCT \n    FCLT_ROOMS.ROOM_FULL_NAME, \n    BUILDINGS.BUILDING_NAME, \n    BUILDINGS.BUILDING_STREET_ADDRESS, \n    FCLT_BUILDING_ADDRESS.CITY, \n    FCLT_BUILDING_ADDRESS.STATE, \n    FCLT_BUILDING_ADDRESS.POSTAL_CODE, \n    FCLT_BUILDING.BUILDING_HEIGHT\nFROM \n    FCLT_ROOMS\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED ON FCLT_ROOMS.FCLT_ROOM_KEY = COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE\nJOIN \n    FCLT_BUILDING ON FCLT_ROOMS.FCLT_BUILDING_KEY = FCLT_BUILDING.FCLT_BUILDING_KEY\nJOIN \n    BUILDINGS ON FCLT_BUILDING.FCLT_BUILDING_KEY = BUILDINGS.BUILDING_KEY\nJOIN \n    FCLT_BUILDING_ADDRESS ON FCLT_BUILDING.FCLT_BUILDING_KEY = FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY\nWHERE \n    COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME = 'Electrical Eng & Computer Sci';"
    },
    {
        "db_id": "dw",
        "question": "List the unique term code, subject title, room, floor, building key, building street address, city, state, and postal code, formats, and number of enrolled students for all courses with more than 300 attendees.",
        "predicted_sql": "SELECT DISTINCT \n    SO.TERM_CODE, \n    SO.SUBJECT_TITLE, \n    FR.ROOM, \n    FR.FLOOR, \n    FR.FCLT_BUILDING_KEY, \n    BA.BUILDING_STREET_ADDRESS, \n    BA.CITY, \n    BA.STATE, \n    BA.POSTAL_CODE, \n    SO.FORM_TYPE, \n    SO.NUM_ENROLLED_STUDENTS\nFROM SUBJECT_OFFERED SO\nJOIN FCLT_ROOMS FR ON SO.MEET_PLACE = FR.FCLT_ROOM_KEY\nJOIN FCLT_BUILDING_ADDRESS BA ON FR.FCLT_BUILDING_KEY = BA.FCLT_BUILDING_KEY\nJOIN BUILDINGS B ON FR.FCLT_BUILDING_KEY = B.BUILDING_KEY\nWHERE SO.NUM_ENROLLED_STUDENTS > 300;"
    },
    {
        "db_id": "dw",
        "question": "What are the subject titles, their material titles, ISBN numbers, new shelf prices, and total costs of new materials for each subject title, sorted by individual item prices in ascending order?",
        "predicted_sql": "SELECT \n    tso.SUBJECT_TITLE,\n    tm.TITLE AS MATERIAL_TITLE,\n    tm.ISBN,\n    tm.NEW_SHELF_PRICE,\n    tm.NEW_SHELF_PRICE AS TOTAL_COST\nFROM \n    TIP_SUBJECT_OFFERED tso\nJOIN \n    TIP_DETAIL td ON tso.SUBJECT_ID = td.SUBJECT_ID\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nORDER BY \n    tm.NEW_SHELF_PRICE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the long names of buildings constructed before 1950 that have more than 100 employees, the built year of the building, and number of employees.",
        "predicted_sql": "SELECT FCLT_BUILDING_HIST.BUILDING_NAME_LONG, \n       FCLT_BUILDING_HIST.DATE_BUILT, \n       COUNT(EMPLOYEE_DIRECTORY.MIT_ID) AS number_of_employees\nFROM FCLT_BUILDING_HIST\nJOIN FCLT_ROOMS ON FCLT_BUILDING_HIST.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY\nJOIN EMPLOYEE_DIRECTORY ON FCLT_ROOMS.BUILDING_ROOM = EMPLOYEE_DIRECTORY.OFFICE_LOCATION\nWHERE FCLT_BUILDING_HIST.DATE_BUILT < '01-JAN-1950'\nGROUP BY FCLT_BUILDING_HIST.BUILDING_NAME_LONG, FCLT_BUILDING_HIST.DATE_BUILT\nHAVING COUNT(EMPLOYEE_DIRECTORY.MIT_ID) > 100;"
    },
    {
        "db_id": "dw",
        "question": "For each building key, what is the building name and the number of courses offered by the Center for International Studies?",
        "predicted_sql": "SELECT \n    FCLT_BUILDING.FCLT_BUILDING_KEY, \n    FCLT_BUILDING.BUILDING_NAME, \n    COUNT(COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID) AS number_of_courses\nFROM \n    FCLT_BUILDING\nJOIN \n    FCLT_ROOMS ON FCLT_BUILDING.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED ON FCLT_ROOMS.FCLT_ROOM_KEY = COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE\nJOIN \n    CIS_COURSE_CATALOG ON COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID = CIS_COURSE_CATALOG.SUBJECT_ID\nWHERE \n    CIS_COURSE_CATALOG.DEPARTMENT_NAME = 'Center for International Studies'\nGROUP BY \n    FCLT_BUILDING.FCLT_BUILDING_KEY, \n    FCLT_BUILDING.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building that accomodates the most students, and how many students does it accomodate?",
        "predicted_sql": "SELECT FCLT_BUILDING.BUILDING_NAME, COUNT(MIT_STUDENT_DIRECTORY.FULL_NAME) AS student_count\nFROM FCLT_BUILDING\nJOIN FCLT_ROOMS ON FCLT_BUILDING.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY\nJOIN MIT_STUDENT_DIRECTORY ON FCLT_ROOMS.BUILDING_ROOM = MIT_STUDENT_DIRECTORY.OFFICE_LOCATION\nGROUP BY FCLT_BUILDING.BUILDING_NAME\nORDER BY student_count DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "List the name and floor of the building with the largest floor number.",
        "predicted_sql": "SELECT fb.BUILDING_NAME, ff.FLOOR \nFROM FAC_BUILDING fb \nJOIN FAC_FLOOR ff ON fb.FAC_BUILDING_KEY = ff.BUILDING_KEY \nWHERE ff.FLOOR = (SELECT MAX(FLOOR) FROM FAC_FLOOR) \nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category and academic year, list the category name, academic year, total fee collected, total number of IAP subjects, and the minimum and maximum enrollment.",
        "predicted_sql": "SELECT \n    isc.IAP_CATEGORY_NAME,\n    td.ACADEMIC_YEAR,\n    SUM(isd.FEE) AS total_fee_collected,\n    COUNT(isd.ACTIVITY_TITLE) AS total_number_of_IAP_subjects,\n    MIN(isd.MAX_ENROLLMENT) AS minimum_enrollment,\n    MAX(isd.MAX_ENROLLMENT) AS maximum_enrollment\nFROM \n    IAP_SUBJECT_DETAIL isd\nJOIN \n    IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    TIME_DAY td ON isd.TERM_CODE = td.ACADEMIC_TERM_CODE\nGROUP BY \n    isc.IAP_CATEGORY_NAME, td.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor of the independent activity periods, list the sponsor name, number of sessions held, the total number of enrollment, the minimum and maximum fee, the number of sessions with info, and the number of sessions without info.",
        "predicted_sql": "SELECT \n    s.SPONSOR_NAME,\n    COUNT(DISTINCT ses.IAP_SUBJECT_SESSION_KEY) AS number_of_sessions_held,\n    SUM(d.MAX_ENROLLMENT) AS total_number_of_enrollment,\n    MIN(d.FEE) AS minimum_fee,\n    MAX(d.FEE) AS maximum_fee,\n    SUM(CASE WHEN ses.HAS_SESSION_INFO = 'Y' THEN 1 ELSE 0 END) AS number_of_sessions_with_info,\n    SUM(CASE WHEN ses.HAS_SESSION_INFO = 'N' THEN 1 ELSE 0 END) AS number_of_sessions_without_info\nFROM \n    IAP_SUBJECT_SPONSOR s\nJOIN \n    IAP_SUBJECT_DETAIL d ON s.IAP_SUBJECT_SPONSOR_KEY = d.IAP_SUBJECT_SPONSOR_KEY\nJOIN \n    IAP_SUBJECT_SESSION ses ON d.IAP_SUBJECT_SESSION_KEY = ses.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    s.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the individual's email and name, academic year, total number of IAP subjects, the minimum and maximum fees, and the total course enrollment for each individual and academic year?",
        "predicted_sql": "SELECT \n    p.PERSON_EMAIL, \n    p.PERSON_NAME, \n    td.ACADEMIC_YEAR, \n    COUNT(DISTINCT d.ACTIVITY_TITLE) AS total_IAP_subjects, \n    MIN(d.FEE) AS min_fee, \n    MAX(d.FEE) AS max_fee, \n    SUM(d.MAX_ENROLLMENT) AS total_course_enrollment\nFROM \n    IAP_SUBJECT_PERSON p\nJOIN \n    IAP_SUBJECT_DETAIL d ON p.IAP_SUBJECT_PERSON_KEY = d.IAP_SUBJECT_PERSON_KEY\nJOIN \n    TIME_DAY td ON td.ACADEMIC_TERM_CODE = d.TERM_CODE\nGROUP BY \n    p.PERSON_EMAIL, \n    p.PERSON_NAME, \n    td.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "What is the term code, term description, total number of IAP sessions, total fee collected, and minimum and maximum enrollment for each term code?",
        "predicted_sql": "SELECT \n    ACADEMIC_TERMS_ALL.TERM_CODE, \n    ACADEMIC_TERMS_ALL.TERM_DESCRIPTION, \n    COUNT(IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY) AS total_sessions, \n    SUM(IAP_SUBJECT_DETAIL.FEE) AS total_fee_collected, \n    MIN(IAP_SUBJECT_DETAIL.MAX_ENROLLMENT) AS min_enrollment, \n    MAX(IAP_SUBJECT_DETAIL.MAX_ENROLLMENT) AS max_enrollment\nFROM \n    ACADEMIC_TERMS_ALL\nJOIN \n    IAP_SUBJECT_DETAIL ON ACADEMIC_TERMS_ALL.TERM_CODE = IAP_SUBJECT_DETAIL.TERM_CODE\nJOIN \n    IAP_SUBJECT_SESSION ON IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY = IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    ACADEMIC_TERMS_ALL.TERM_CODE, \n    ACADEMIC_TERMS_ALL.TERM_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building, total number of subjects, total fee, and shortest and longest sessions for each physical IAP session location?",
        "predicted_sql": "SELECT \n    B.BUILDING_NAME,\n    COUNT(DISTINCT ISD.ACTIVITY_TITLE) AS total_subjects,\n    SUM(ISD.FEE) AS total_fee,\n    MIN(STRFTIME('%H%M', ISS.SESSION_END_TIME) - STRFTIME('%H%M', ISS.SESSION_START_TIME)) AS shortest_session,\n    MAX(STRFTIME('%H%M', ISS.SESSION_END_TIME) - STRFTIME('%H%M', ISS.SESSION_START_TIME)) AS longest_session\nFROM \n    BUILDINGS B\nJOIN \n    IAP_SUBJECT_SESSION ISS ON B.BUILDING_NUMBER = ISS.SESSION_LOCATION\nJOIN \n    IAP_SUBJECT_DETAIL ISD ON ISS.IAP_SUBJECT_SESSION_KEY = ISD.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    B.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is total number of subjects, the total fee, and the shortest and longest sessions, for all virtual IAP sessions?",
        "predicted_sql": "SELECT \n    COUNT(DISTINCT IAP_SUBJECT_DETAIL.ACTIVITY_TITLE) AS total_subjects,\n    SUM(IAP_SUBJECT_DETAIL.FEE) AS total_fee,\n    MIN(julianday(IAP_SUBJECT_SESSION.SESSION_END_TIME) - julianday(IAP_SUBJECT_SESSION.SESSION_START_TIME)) AS shortest_session,\n    MAX(julianday(IAP_SUBJECT_SESSION.SESSION_END_TIME) - julianday(IAP_SUBJECT_SESSION.SESSION_START_TIME)) AS longest_session\nFROM \n    IAP_SUBJECT_DETAIL\nJOIN \n    IAP_SUBJECT_SESSION ON IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY = IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY\nWHERE \n    IAP_SUBJECT_SESSION.SESSION_LOCATION = 'On line';"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, full name of the department, course level, total number of courses, and total number of degree-granting courses for each school code, department, and course level?",
        "predicted_sql": "SELECT \n    s.SCHOOL_CODE, \n    s.SCHOOL_NAME, \n    d.DEPARTMENT_FULL_NAME, \n    c.COURSE_LEVEL, \n    COUNT(c.COURSE) AS TOTAL_COURSES, \n    COUNT(CASE WHEN c.IS_DEGREE_GRANTING = 'Y' THEN 1 END) AS TOTAL_DEGREE_GRANTING_COURSES\nFROM \n    SIS_COURSE_DESCRIPTION c\nJOIN \n    SIS_DEPARTMENT d ON c.DEPARTMENT = d.DEPARTMENT_CODE\nJOIN \n    SIS_SUBJECT_CODE s ON c.COURSE = s.SUBJECT_CODE\nGROUP BY \n    s.SCHOOL_CODE, \n    s.SCHOOL_NAME, \n    d.DEPARTMENT_FULL_NAME, \n    c.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What are the different schools and departments that offer SIS courses? List their school code, school name, department code, department name, the total number of phone numbers, and the most common course level.",
        "predicted_sql": "SELECT \n    SIS_SUBJECT_CODE.SCHOOL_CODE,\n    SIS_SUBJECT_CODE.SCHOOL_NAME,\n    SIS_DEPARTMENT.DEPARTMENT_CODE,\n    SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME AS DEPARTMENT_NAME,\n    COUNT(SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER) AS TOTAL_PHONE_NUMBERS,\n    (SELECT COURSE_LEVEL \n     FROM SIS_COURSE_DESCRIPTION \n     WHERE SIS_COURSE_DESCRIPTION.DEPARTMENT = SIS_DEPARTMENT.DEPARTMENT_CODE \n     GROUP BY COURSE_LEVEL \n     ORDER BY COUNT(*) DESC \n     LIMIT 1) AS MOST_COMMON_COURSE_LEVEL\nFROM \n    SIS_ADMIN_DEPARTMENT\nJOIN \n    SIS_DEPARTMENT ON SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE = SIS_DEPARTMENT.DEPARTMENT_CODE\nJOIN \n    SIS_COURSE_DESCRIPTION ON SIS_DEPARTMENT.DEPARTMENT_CODE = SIS_COURSE_DESCRIPTION.DEPARTMENT\nJOIN \n    SIS_SUBJECT_CODE ON SIS_COURSE_DESCRIPTION.COURSE = SIS_SUBJECT_CODE.SUBJECT_CODE\nGROUP BY \n    SIS_SUBJECT_CODE.SCHOOL_CODE,\n    SIS_SUBJECT_CODE.SCHOOL_NAME,\n    SIS_DEPARTMENT.DEPARTMENT_CODE,\n    SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, DLC key, the graduate level, total number of SIS subjects, the minimum and maximum course numbers, and the total number of departments offering subjects for each school?",
        "predicted_sql": "SELECT \n    s.SCHOOL_CODE, \n    s.SCHOOL_NAME, \n    d.DLC_KEY, \n    c.GRADUATE_LEVEL, \n    COUNT(DISTINCT s.SUBJECT_CODE) AS total_sis_subjects, \n    MIN(s.COURSE_NUMBER) AS min_course_number, \n    MAX(s.COURSE_NUMBER) AS max_course_number, \n    COUNT(DISTINCT d.DEPARTMENT_CODE) AS total_departments\nFROM \n    SIS_SUBJECT_CODE s\nJOIN \n    SIS_COURSE_DESCRIPTION c ON s.SUBJECT_CODE = c.COURSE\nJOIN \n    SIS_DEPARTMENT d ON c.DEPARTMENT = d.DEPARTMENT_CODE\nGROUP BY \n    s.SCHOOL_CODE, \n    s.SCHOOL_NAME, \n    d.DLC_KEY, \n    c.GRADUATE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What is the building component, name of the building, square footage for all rooms, total number of floors, total number of rooms, total number of facility organizations, total number of supervisors, and total number of supervisees for each building component?",
        "predicted_sql": "SELECT \n    SD.BUILDING_COMPONENT,\n    B.BUILDING_NAME,\n    SUM(SD.ROOM_SQUARE_FOOTAGE) AS Total_Room_Square_Footage,\n    COUNT(DISTINCT SF.FLOOR) AS Total_Floors,\n    COUNT(DISTINCT SD.BUILDING_ROOM) AS Total_Rooms,\n    COUNT(DISTINCT SU.FCLT_ORGANIZATION_KEY) AS Total_Facility_Organizations,\n    COUNT(DISTINCT SSU.MIT_ID) AS Total_Supervisors,\n    SUM(SSU.NUM_OF_SUPERVISEES) AS Total_Supervisees\nFROM \n    SPACE_DETAIL SD\nJOIN \n    BUILDINGS B ON SD.BUILDING_KEY = B.BUILDING_KEY\nJOIN \n    SPACE_FLOOR SF ON SD.FLOOR_KEY = SF.FLOOR_KEY\nLEFT JOIN \n    SPACE_UNIT SU ON SU.SPACE_UNIT_KEY = SD.SPACE_UNIT_KEY\nLEFT JOIN \n    SPACE_SUPERVISOR_USAGE SSU ON SU.DLC_KEY = SSU.DEPT_NAMES\nGROUP BY \n    SD.BUILDING_COMPONENT,\n    B.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the DLC key, name of the DLC, total number of floors, total square footage, total number of facility organizations, total number of supervisors, total number of supervisees, and total building heights for each DLC?",
        "predicted_sql": "SELECT \n    su.DLC_KEY AS 'DLC key',\n    fo.DLC_NAME AS 'name of the DLC',\n    COUNT(DISTINCT sf.FLOOR_KEY) AS 'total number of floors',\n    SUM(sd.ROOM_SQUARE_FOOTAGE) AS 'total square footage',\n    COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS 'total number of facility organizations',\n    COUNT(DISTINCT spu.MIT_ID) AS 'total number of supervisors',\n    SUM(spu.NUM_OF_SUPERVISEES) AS 'total number of supervisees',\n    SUM(fb.BUILDING_HEIGHT) AS 'total building heights'\nFROM \n    SPACE_UNIT su\nJOIN \n    SPACE_SUPERVISOR_USAGE spu ON su.DLC_KEY = spu.DEPT_NAMES\nJOIN \n    FCLT_ORGANIZATION fo ON su.DLC_KEY = fo.DLC_KEY\nJOIN \n    SPACE_DETAIL sd ON su.SPACE_UNIT_KEY = sd.SPACE_UNIT_KEY\nJOIN \n    SPACE_FLOOR sf ON sd.BUILDING_KEY = sf.FLOOR_KEY\nJOIN \n    FCLT_BUILDING fb ON sd.BUILDING_KEY = fb.FCLT_BUILDING_KEY\nGROUP BY \n    su.DLC_KEY, fo.DLC_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the department name, total number of types of TIP subjects, total number of enrolled students, the minimum and maximum rental new price for each department?",
        "predicted_sql": "SELECT \n    tso.OFFER_DEPT_NAME,\n    COUNT(DISTINCT tso.SUBJECT_ID) AS total_types_of_tip_subjects,\n    SUM(tso.NUM_ENROLLED_STUDENTS) AS total_enrolled_students,\n    MIN(tm.RENTAL_NEW_PRICE) AS min_rental_new_price,\n    MAX(tm.RENTAL_NEW_PRICE) AS max_rental_new_price\nFROM \n    TIP_SUBJECT_OFFERED tso\nJOIN \n    TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL tm ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY\nGROUP BY \n    tso.OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the details of courses offered in the current academic term, including the academic year, term code, hgn code, the total number of types of courses, the average number of units, the department name, the name and email address of the person in charge?",
        "predicted_sql": "SELECT \n    ACADEMIC_TERMS.ACADEMIC_YEAR,\n    COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE,\n    SUBJECT_OFFERED.HGN_CODE,\n    COUNT(DISTINCT COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID) AS total_course_types,\n    AVG(COURSE_CATALOG_SUBJECT_OFFERED.TOTAL_UNITS) AS average_units,\n    COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME,\n    EMPLOYEE_DIRECTORY.FULL_NAME,\n    EMPLOYEE_DIRECTORY.EMAIL_ADDRESS\nFROM \n    ACADEMIC_TERMS\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED ON ACADEMIC_TERMS.TERM_CODE = COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE\nJOIN \n    SUBJECT_OFFERED ON COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID = SUBJECT_OFFERED.SUBJECT_ID\nJOIN \n    EMPLOYEE_DIRECTORY ON SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID = EMPLOYEE_DIRECTORY.MIT_ID\nWHERE \n    ACADEMIC_TERMS.IS_CURRENT_TERM = 'Y'\nGROUP BY \n    ACADEMIC_TERMS.ACADEMIC_YEAR,\n    COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE,\n    SUBJECT_OFFERED.HGN_CODE,\n    COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME,\n    EMPLOYEE_DIRECTORY.FULL_NAME,\n    EMPLOYEE_DIRECTORY.EMAIL_ADDRESS;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve information about the IAP subjects, including their titles, categories, session titles, session start time, session end time, sponsor names, and total number of sessions.",
        "predicted_sql": "SELECT \n    IAP_SUBJECT_DETAIL.ACTIVITY_TITLE AS title,\n    IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME AS category,\n    IAP_SUBJECT_SESSION.SESSION_TITLE AS session_title,\n    IAP_SUBJECT_SESSION.SESSION_START_TIME AS session_start_time,\n    IAP_SUBJECT_SESSION.SESSION_END_TIME AS session_end_time,\n    IAP_SUBJECT_SPONSOR.SPONSOR_NAME AS sponsor_name,\n    COUNT(IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY) AS total_sessions\nFROM \n    IAP_SUBJECT_DETAIL\nJOIN \n    IAP_SUBJECT_CATEGORY ON IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY = IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    IAP_SUBJECT_SESSION ON IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY = IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY\nJOIN \n    IAP_SUBJECT_SPONSOR ON IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY = IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY\nGROUP BY \n    IAP_SUBJECT_DETAIL.ACTIVITY_TITLE, \n    IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME,\n    IAP_SUBJECT_SESSION.SESSION_TITLE,\n    IAP_SUBJECT_SESSION.SESSION_START_TIME,\n    IAP_SUBJECT_SESSION.SESSION_END_TIME,\n    IAP_SUBJECT_SPONSOR.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Show the department names, the corresponding SIS subject code, subject code descriptions, graduate level, and the total number of courses per department.",
        "predicted_sql": "SELECT \n    d.DEPARTMENT_NAME,\n    s.SUBJECT_CODE,\n    s.SUBJECT_CODE_DESC,\n    c.GRADUATE_LEVEL,\n    COUNT(s.COURSE_NUMBER) AS total_courses\nFROM \n    SIS_DEPARTMENT d\nJOIN \n    SIS_COURSE_DESCRIPTION c ON d.DEPARTMENT_CODE = c.DEPARTMENT\nJOIN \n    SIS_SUBJECT_CODE s ON s.COURSE_NUMBER = c.COURSE\nGROUP BY \n    d.DEPARTMENT_NAME, s.SUBJECT_CODE, s.SUBJECT_CODE_DESC, c.GRADUATE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "For each term, list the term code, the term description, whether the term is current or not, and the total number of types of CIS courses.",
        "predicted_sql": "SELECT \n    ata.TERM_CODE,\n    ata.TERM_DESCRIPTION,\n    atp.IS_CURRENT_TERM,\n    COUNT(cc.SUBJECT_ID) AS TOTAL_CIS_COURSES\nFROM \n    ACADEMIC_TERMS_ALL ata\nLEFT JOIN \n    ACADEMIC_TERM_PARAMETER atp ON ata.TERM_CODE = atp.TERM_CODE\nLEFT JOIN \n    CIS_COURSE_CATALOG cc ON atp.TERM_CODE = cc.EFFECTIVE_TERM_CODE\nGROUP BY \n    ata.TERM_CODE, ata.TERM_DESCRIPTION, atp.IS_CURRENT_TERM;"
    },
    {
        "db_id": "dw",
        "question": "What is the author, school name, material status, total record counts, and total number of types of courses for each author and school?",
        "predicted_sql": "SELECT \n    m.AUTHOR, \n    d.SCHOOL_NAME, \n    s.TIP_MATERIAL_STATUS AS material_status, \n    SUM(td.RECORD_COUNT) AS total_record_counts, \n    COUNT(DISTINCT td.SUBJECT_ID) AS total_types_of_courses\nFROM \n    TIP_MATERIAL m\nJOIN \n    TIP_DETAIL td ON m.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY\nJOIN \n    TIP_SUBJECT_OFFERED so ON td.TIP_SUBJECT_OFFERED_KEY = so.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    STUDENT_DEPARTMENT d ON so.OFFER_DEPT_CODE = d.DEPARTMENT_CODE\nJOIN \n    TIP_MATERIAL_STATUS s ON td.TIP_MATERIAL_STATUS_KEY = s.TIP_MATERIAL_STATUS_KEY\nGROUP BY \n    m.AUTHOR, \n    d.SCHOOL_NAME, \n    s.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is the course number, subject title, material status, the total, min, and max new shelf price, the total, min, and max used shelf price, total number of schools and the total number of materials for each TIP subject and material status?",
        "predicted_sql": "SELECT \n    so.COURSE_NUMBER,\n    so.SUBJECT_TITLE,\n    ms.TIP_MATERIAL_STATUS,\n    COUNT(DISTINCT so.OFFER_SCHOOL_NAME) AS total_schools,\n    COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS total_materials,\n    SUM(m.NEW_SHELF_PRICE) AS total_new_price,\n    MIN(m.NEW_SHELF_PRICE) AS min_new_price,\n    MAX(m.NEW_SHELF_PRICE) AS max_new_price,\n    SUM(m.USED_SHELF_PRICE) AS total_used_price,\n    MIN(m.USED_SHELF_PRICE) AS min_used_price,\n    MAX(m.USED_SHELF_PRICE) AS max_used_price\nFROM \n    TIP_SUBJECT_OFFERED so\nJOIN \n    TIP_DETAIL td ON so.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL m ON td.TIP_MATERIAL_KEY = m.TIP_MATERIAL_KEY\nJOIN \n    TIP_MATERIAL_STATUS ms ON td.TIP_MATERIAL_STATUS_KEY = ms.TIP_MATERIAL_STATUS_KEY\nGROUP BY \n    so.COURSE_NUMBER, so.SUBJECT_TITLE, ms.TIP_MATERIAL_STATUS"
    },
    {
        "db_id": "dw",
        "question": "What is material status, the total number of materials, the total number of subjects, the total number of schools, and the most recent publication year for each material status?",
        "predicted_sql": "SELECT \n    TMS.TIP_MATERIAL_STATUS AS material_status,\n    COUNT(DISTINCT TD.TIP_MATERIAL_KEY) AS total_materials,\n    COUNT(DISTINCT TD.SUBJECT_ID) AS total_subjects,\n    COUNT(DISTINCT SD.SCHOOL_NAME) AS total_schools,\n    MAX(TM.YEAR) AS most_recent_publication_year\nFROM \n    TIP_DETAIL TD\nJOIN \n    TIP_MATERIAL TM ON TM.TIP_MATERIAL_KEY = TD.TIP_MATERIAL_KEY\nJOIN \n    TIP_MATERIAL_STATUS TMS ON TMS.TIP_MATERIAL_STATUS_KEY = TD.TIP_MATERIAL_STATUS_KEY\nJOIN \n    TIP_SUBJECT_OFFERED TSO ON TSO.TIP_SUBJECT_OFFERED_KEY = TD.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    STUDENT_DEPARTMENT SD ON SD.DEPARTMENT_CODE = TSO.OFFER_DEPT_CODE\nGROUP BY \n    TMS.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is the term description, whether the term is current or not, total number of types of TIP subjects offered and materials needed, the minimum and maximum number of enrolled students, the total number of schools offering subjects, and the total number of records for each term code?",
        "predicted_sql": "SELECT \n    AT.TERM_DESCRIPTION,\n    AT.IS_CURRENT_TERM,\n    COUNT(DISTINCT TSO.COURSE_NUMBER) AS total_tip_subjects,\n    COUNT(DISTINCT TM.ISBN) AS total_materials,\n    MIN(TSO.NUM_ENROLLED_STUDENTS) AS min_enrolled_students,\n    MAX(TSO.NUM_ENROLLED_STUDENTS) AS max_enrolled_students,\n    COUNT(DISTINCT TSO.OFFER_SCHOOL_NAME) AS total_schools,\n    SUM(TD.RECORD_COUNT) AS total_records\nFROM \n    ACADEMIC_TERMS_ALL AT\nLEFT JOIN \n    TIP_SUBJECT_OFFERED TSO ON AT.TERM_CODE = TSO.TERM_CODE\nLEFT JOIN \n    TIP_DETAIL TD ON TSO.TIP_SUBJECT_OFFERED_KEY = TD.TIP_SUBJECT_OFFERED_KEY\nLEFT JOIN \n    TIP_MATERIAL TM ON TD.TIP_MATERIAL_KEY = TM.TIP_MATERIAL_KEY\nLEFT JOIN \n    TIP_MATERIAL_STATUS TMS ON TD.TIP_MATERIAL_STATUS_KEY = TMS.TIP_MATERIAL_STATUS_KEY\nGROUP BY \n    AT.TERM_DESCRIPTION, AT.IS_CURRENT_TERM;"
    },
    {
        "db_id": "dw",
        "question": "List all buildings with their names, building numbers, building height, street address, city, state, HR department name, assignable square footage, total and average square footage, ordered in descending order of assignable, total, and average square footage.",
        "predicted_sql": "SELECT \n    B.BUILDING_NAME, \n    B.BUILDING_NUMBER, \n    FB.BUILDING_HEIGHT, \n    B.BUILDING_STREET_ADDRESS, \n    A.CITY, \n    A.STATE, \n    O.HR_DEPARTMENT_NAME, \n    B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE, \n    SUM(R.AREA) AS TOTAL_SQUARE_FOOTAGE, \n    AVG(R.AREA) AS AVERAGE_SQUARE_FOOTAGE \nFROM \n    BUILDINGS B \nJOIN \n    FAC_BUILDING FB ON B.BUILDING_KEY = FB.FAC_BUILDING_KEY \nJOIN \n    FAC_ROOMS R ON FB.FAC_BUILDING_KEY = R.BUILDING_KEY \nJOIN \n    FAC_BUILDING_ADDRESS A ON B.BUILDING_KEY = A.BUILDING_KEY \nJOIN \n    FAC_ORGANIZATION O ON R.ORGANIZATION_KEY = O.ORGANIZATION_KEY \nGROUP BY \n    B.BUILDING_NAME, \n    B.BUILDING_NUMBER, \n    FB.BUILDING_HEIGHT, \n    B.BUILDING_STREET_ADDRESS, \n    A.CITY, \n    A.STATE, \n    O.HR_DEPARTMENT_NAME, \n    B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE \nORDER BY \n    B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE DESC, \n    TOTAL_SQUARE_FOOTAGE DESC, \n    AVERAGE_SQUARE_FOOTAGE DESC;"
    },
    {
        "db_id": "dw",
        "question": "For the 2023 Fall term, what are the unique term descriptions, subject titles along with their prerequisites, total number of types of subjects per term code, instructor of this course, and the number of types of courses ever taught by the instructor?",
        "predicted_sql": "SELECT DISTINCT \n    AT.TERM_DESCRIPTION, \n    C.SUBJECT_TITLE, \n    C.PREREQUISITES, \n    COUNT(DISTINCT C.SUBJECT_ID) OVER (PARTITION BY C.TERM_CODE) AS TYPE_COUNT_PER_TERM,\n    C.FALL_INSTRUCTORS, \n    COUNT(DISTINCT C.SUBJECT_ID) OVER (PARTITION BY C.FALL_INSTRUCTORS) AS TYPE_COUNT_PER_INSTRUCTOR\nFROM \n    ACADEMIC_TERMS AT\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED C ON AT.TERM_CODE = C.TERM_CODE\nWHERE \n    AT.TERM_CODE = '2023FA';"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the assignable floor area and building.",
        "predicted_sql": "SELECT \n    FR.ROOM_FULL_NAME,\n    FB.BUILDING_NAME,\n    FF.FLOOR,\n    FO.ORGANIZATION_NAME,\n    FO.HR_DEPARTMENT_NAME,\n    (FR.AREA / FF.ASSIGNABLE_AREA) * 100 AS ROOM_AREA_PERCENTAGE,\n    (FR.AREA / (SELECT SUM(FF2.ASSIGNABLE_AREA) \n                 FROM FAC_FLOOR FF2 \n                 WHERE FF2.BUILDING_KEY = FR.BUILDING_KEY)) * 100 AS BUILDING_AREA_PERCENTAGE\nFROM \n    FAC_ROOMS FR\nJOIN \n    FAC_FLOOR FF ON FR.FLOOR_KEY = FF.FLOOR_KEY\nJOIN \n    FAC_BUILDING FB ON FR.BUILDING_KEY = FB.FAC_BUILDING_KEY\nJOIN \n    FAC_ORGANIZATION FO ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the floor area and building.",
        "predicted_sql": "SELECT \n    R.ROOM_FULL_NAME, \n    B.BUILDING_NAME, \n    F.FLOOR, \n    O.ORGANIZATION_NAME, \n    O.HR_DEPARTMENT_NAME,\n    (R.AREA / F.ASSIGNABLE_AREA * 100) AS ROOM_AREA_PERCENTAGE,\n    (R.AREA / B.ASSIGNABLE_AREA * 100) AS ROOM_AREA_PERCENTAGE_BUILDING\nFROM \n    FAC_ROOMS R\nJOIN \n    FAC_BUILDING B ON R.BUILDING_KEY = B.FAC_BUILDING_KEY\nJOIN \n    FAC_FLOOR F ON R.BUILDING_KEY = F.BUILDING_KEY AND R.FLOOR = F.FLOOR\nJOIN \n    FAC_ORGANIZATION O ON R.ORGANIZATION_KEY = O.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What are the academic year, and instructors names for courses offered in the academic year 2022, along with the total number of types of courses per instructor?",
        "predicted_sql": "SELECT \n    ACADEMIC_TERMS_ALL.ACADEMIC_YEAR, \n    EMPLOYEE_DIRECTORY.FULL_NAME, \n    COUNT(DISTINCT SUBJECT_OFFERED.COURSE_NUMBER) AS total_course_types\nFROM \n    ACADEMIC_TERMS_ALL \nJOIN \n    SUBJECT_OFFERED ON ACADEMIC_TERMS_ALL.TERM_CODE = SUBJECT_OFFERED.TERM_CODE \nJOIN \n    EMPLOYEE_DIRECTORY ON SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID = EMPLOYEE_DIRECTORY.MIT_ID \nWHERE \n    ACADEMIC_TERMS_ALL.ACADEMIC_YEAR = '2022' \nGROUP BY \n    ACADEMIC_TERMS_ALL.ACADEMIC_YEAR, EMPLOYEE_DIRECTORY.FULL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the building names, department names, organizations, their highest and lowest floor number, along with the total number of rooms per each building key?",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME AS building_name,\n    o.HR_DEPARTMENT_NAME AS department_name,\n    o.ORGANIZATION AS organization,\n    MIN(f.FLOOR) AS lowest_floor,\n    MAX(f.FLOOR) AS highest_floor,\n    COUNT(r.FAC_ROOM_KEY) AS total_rooms\nFROM \n    FAC_BUILDING b\nJOIN \n    FAC_ROOMS r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY\nJOIN \n    FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nJOIN \n    FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\nGROUP BY \n    b.BUILDING_NAME, o.HR_DEPARTMENT_NAME, o.ORGANIZATION\nORDER BY \n    b.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Provide the complete information for students with the first name Kevin, including their full names, email addresses, department names, department phone numbers, school names, and the total student count per department and school. If a student is associated with more than one department, list a separate row for each department.",
        "predicted_sql": "SELECT \n    MSD.FULL_NAME,\n    MSD.EMAIL_ADDRESS,\n    SD.DEPARTMENT_NAME,\n    SAD.DEPARTMENT_PHONE_NUMBER,\n    SD.SCHOOL_NAME,\n    COUNT(*) OVER (PARTITION BY SD.DEPARTMENT_CODE, SD.SCHOOL_CODE) AS TOTAL_STUDENT_COUNT\nFROM \n    MIT_STUDENT_DIRECTORY MSD\nJOIN \n    SIS_DEPARTMENT SD ON MSD.DEPARTMENT = SD.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT SAD ON SD.DEPARTMENT_CODE = SAD.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    MSD.FIRST_NAME = 'Kevin';"
    },
    {
        "db_id": "dw",
        "question": "What are the unique titles of subjects offered in the fall term along with their instructor names, instructor emails, and the total number of types of subjects per instructor?",
        "predicted_sql": "SELECT DISTINCT c.SUBJECT_TITLE, \n                e.FULL_NAME, \n                e.EMAIL_ADDRESS, \n                COUNT(DISTINCT c.SUBJECT_ID) AS TOTAL_SUBJECT_TYPES\nFROM COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nJOIN ACADEMIC_TERMS_ALL a ON c.TERM_CODE = a.TERM_CODE\nWHERE a.TERM_CODE LIKE '%FA' \nGROUP BY c.SUBJECT_TITLE, e.FULL_NAME, e.EMAIL_ADDRESS;"
    },
    {
        "db_id": "dw",
        "question": "List the building names, names of HR departments occupying them, the total gross square footage, the total and average assignable square footage, and the built year per building key.",
        "predicted_sql": "SELECT \n    B.BUILDING_NAME,\n    FO.HR_DEPARTMENT_NAME,\n    B.BLDG_GROSS_SQUARE_FOOTAGE,\n    SUM(B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) AS total_assignable_sq_ft,\n    AVG(B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) AS average_assignable_sq_ft,\n    FB.DATE_BUILT\nFROM \n    BUILDINGS B\nJOIN \n    FAC_BUILDING FB ON B.BUILDING_KEY = FB.FAC_BUILDING_KEY\nJOIN \n    FAC_ROOMS FR ON FB.FAC_BUILDING_KEY = FR.BUILDING_KEY\nJOIN \n    FAC_ORGANIZATION FO ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY\nGROUP BY \n    B.BUILDING_NAME, FO.HR_DEPARTMENT_NAME, B.BLDG_GROSS_SQUARE_FOOTAGE, FB.DATE_BUILT"
    },
    {
        "db_id": "dw",
        "question": "Retrieve the titles of subjects offered in the summer term along with their descriptions, responsible faculty names, email address, building name, room name, floor level, building street address, and the total number of types of courses per departmnet.",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE, \n    c.SUBJECT_DESCRIPTION, \n    c.RESPONSIBLE_FACULTY_NAME, \n    e.EMAIL_ADDRESS, \n    b.BUILDING_NAME, \n    r.ROOM_FULL_NAME, \n    f.LEVEL_ID, \n    b.BUILDING_STREET_ADDRESS, \n    COUNT(DISTINCT c.SUBJECT_ID) AS TOTAL_COURSE_TYPES\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS t ON c.TERM_CODE = t.TERM_CODE\nJOIN \n    EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nJOIN \n    FAC_ROOMS r ON c.MEET_PLACE = r.FAC_ROOM_KEY\nJOIN \n    FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nJOIN \n    BUILDINGS b ON r.BUILDING_KEY = b.BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS a ON b.BUILDING_KEY = a.BUILDING_KEY\nWHERE \n    t.TERM_CODE LIKE '%SUMMER%' \nGROUP BY \n    c.SUBJECT_TITLE, \n    c.SUBJECT_DESCRIPTION, \n    c.RESPONSIBLE_FACULTY_NAME, \n    e.EMAIL_ADDRESS, \n    b.BUILDING_NAME, \n    r.ROOM_FULL_NAME, \n    f.LEVEL_ID, \n    b.BUILDING_STREET_ADDRESS;"
    },
    {
        "db_id": "dw",
        "question": "For each term code, list the term description, attribute desciption, department name, school name, and the number of subjects in the area of humanities, arts and social sciences.",
        "predicted_sql": "SELECT \n    ACADEMIC_TERMS_ALL.TERM_CODE,\n    ACADEMIC_TERMS_ALL.TERM_DESCRIPTION,\n    CIS_HASS_ATTRIBUTE.HASS_ATTRIBUTE_DESC,\n    SIS_DEPARTMENT.DEPARTMENT_NAME,\n    SIS_DEPARTMENT.SCHOOL_NAME,\n    COUNT(COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID) AS NUMBER_OF_SUBJECTS\nFROM \n    ACADEMIC_TERMS_ALL\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED ON ACADEMIC_TERMS_ALL.TERM_CODE = COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE\nJOIN \n    CIS_HASS_ATTRIBUTE ON COURSE_CATALOG_SUBJECT_OFFERED.HASS_ATTRIBUTE = CIS_HASS_ATTRIBUTE.HASS_ATTRIBUTE\nJOIN \n    SIS_DEPARTMENT ON COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_CODE = SIS_DEPARTMENT.DEPARTMENT_CODE\nWHERE \n    CIS_HASS_ATTRIBUTE.CIS_ATTRIBUTE_GROUP = 'H'\nGROUP BY \n    ACADEMIC_TERMS_ALL.TERM_CODE, \n    ACADEMIC_TERMS_ALL.TERM_DESCRIPTION, \n    CIS_HASS_ATTRIBUTE.HASS_ATTRIBUTE_DESC,\n    SIS_DEPARTMENT.DEPARTMENT_NAME,\n    SIS_DEPARTMENT.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List building names, their height, street address, city, state, postal code, their gross and assignable square footage, the smallest and largest floor level and the total area of all rooms for each building key.",
        "predicted_sql": "SELECT \n    fb.BUILDING_NAME,\n    fb.BUILDING_HEIGHT,\n    b.BUILDING_STREET_ADDRESS,\n    fba.CITY,\n    fba.STATE,\n    fba.POSTAL_CODE,\n    fb.EXT_GROSS_AREA,\n    fb.ASSIGNABLE_AREA,\n    MIN(f.FLOOR) AS SMALLEST_FLOOR_LEVEL,\n    MAX(f.FLOOR) AS LARGEST_FLOOR_LEVEL,\n    SUM(r.AREA) AS TOTAL_ROOM_AREA\nFROM \n    FAC_BUILDING fb\nJOIN \n    BUILDINGS b ON fb.FAC_BUILDING_KEY = b.BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS fba ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY\nJOIN \n    FAC_FLOOR f ON fb.FAC_BUILDING_KEY = f.BUILDING_KEY\nJOIN \n    FAC_ROOMS r ON f.FLOOR_KEY = r.FLOOR_KEY\nGROUP BY \n    fb.BUILDING_NAME, \n    fb.BUILDING_HEIGHT,\n    b.BUILDING_STREET_ADDRESS,\n    fba.CITY,\n    fba.STATE,\n    fba.POSTAL_CODE,\n    fb.EXT_GROSS_AREA,\n    fb.ASSIGNABLE_AREA;"
    },
    {
        "db_id": "dw",
        "question": "What is the category title, version, department name, school name, total number of courses for each course level, and the total number of degree-granting courses for each CIP category code?",
        "predicted_sql": "SELECT \n    CIP.CATEGORY_TITLE,\n    CIP.VERSION,\n    SIS_DEPARTMENT.DEPARTMENT_NAME,\n    SIS_DEPARTMENT.SCHOOL_NAME,\n    SIS_COURSE_DESCRIPTION.COURSE_LEVEL,\n    COUNT(SIS_COURSE_DESCRIPTION.COURSE) AS total_courses,\n    COUNT(CASE WHEN SIS_COURSE_DESCRIPTION.IS_DEGREE_GRANTING = 'Y' THEN 1 END) AS total_degree_granting_courses\nFROM \n    CIP\nJOIN \n    SIS_COURSE_DESCRIPTION ON SIS_COURSE_DESCRIPTION.CIP_PROGRAM_CODE = CIP.PROGRAM_CODE\nJOIN \n    SIS_DEPARTMENT ON SIS_COURSE_DESCRIPTION.DEPARTMENT = SIS_DEPARTMENT.DEPARTMENT_CODE\nGROUP BY \n    CIP.CATEGORY_TITLE, \n    CIP.VERSION, \n    SIS_DEPARTMENT.DEPARTMENT_NAME, \n    SIS_DEPARTMENT.SCHOOL_NAME, \n    SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library materials, the minimum and maximum publication years, and the total number of materials status for each course name?",
        "predicted_sql": "SELECT \n    LCI.COURSE_NAME,\n    COUNT(DISTINCT LRC.CATALOG_SYSTEM_NUMBER) AS total_materials,\n    MIN(LRC.CATALOG_YEAR) AS min_publication_year,\n    MAX(LRC.CATALOG_YEAR) AS max_publication_year,\n    COUNT(DISTINCT LMS.LIBRARY_MATERIAL_STATUS) AS total_material_status\nFROM \n    LIBRARY_COURSE_INSTRUCTOR LCI\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS LMS ON LRMD.LIBRARY_MATERIAL_STATUS_KEY = LMS.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    LCI.COURSE_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library reserve materials, the minimum and maximum publication years, and the total number of enrolled students for each course instructor?",
        "predicted_sql": "SELECT \n    lci.INSTRUCTOR_NAME,\n    COUNT(lrc.CATALOG_SYSTEM_NUMBER) AS total_library_reserve_materials,\n    MIN(lrc.CATALOG_YEAR) AS min_publication_year,\n    MAX(lrc.CATALOG_YEAR) AS max_publication_year,\n    SUM(lso.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\nFROM \n    LIBRARY_COURSE_INSTRUCTOR lci\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrm ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrm.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrm.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED lso ON lrm.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nGROUP BY \n    lci.INSTRUCTOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the material status, term description, total number of courses and materials, occurences in departments and school, and the total number of instructors for each library material status code and term code?",
        "predicted_sql": "SELECT \n    LMS.LIBRARY_MATERIAL_STATUS AS material_status,\n    ATA.TERM_DESCRIPTION AS term_description,\n    COUNT(DISTINCT LSO.COURSE_NUMBER) AS total_courses,\n    COUNT(DISTINCT LRC.CATALOG_SYSTEM_NUMBER) AS total_materials,\n    COUNT(DISTINCT LSO.OFFER_DEPT_CODE) AS occurrences_in_departments,\n    COUNT(DISTINCT LSO.OFFER_SCHOOL_NAME) AS occurrences_in_schools,\n    COUNT(DISTINCT LCI.INSTRUCTOR_NAME) AS total_instructors\nFROM \n    LIBRARY_MATERIAL_STATUS LMS\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LMS.LIBRARY_MATERIAL_STATUS_KEY = LRMD.LIBRARY_MATERIAL_STATUS_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED LSO ON LSO.LIBRARY_SUBJECT_OFFERED_KEY = LRMD.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRC ON LRC.LIBRARY_RESERVE_CATALOG_KEY = LRMD.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR LCI ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    ACADEMIC_TERMS_ALL ATA ON ATA.TERM_CODE = LSO.TERM_CODE\nGROUP BY \n    LMS.LIBRARY_MATERIAL_STATUS, ATA.TERM_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "For building 36, list all space units, their floor and building name, building street address, their space usage, and the number of organizations and space units on the same building and floor.",
        "predicted_sql": "SELECT \n    SU.SPACE_UNIT, \n    SF.FLOOR, \n    B.BUILDING_NAME, \n    B.BUILDING_STREET_ADDRESS, \n    SUU.SPACE_USAGE, \n    COUNT(DISTINCT O.FCLT_ORGANIZATION_KEY) AS ORGANIZATION_COUNT, \n    COUNT(DISTINCT SU.SPACE_UNIT_KEY) AS SPACE_UNIT_COUNT\nFROM \n    BUILDINGS B\nJOIN \n    SPACE_DETAIL SD ON B.BUILDING_KEY = SD.BUILDING_KEY\nJOIN \n    SPACE_UNIT SU ON SD.SPACE_UNIT_KEY = SU.SPACE_UNIT_KEY\nJOIN \n    SPACE_USAGE SUU ON SD.SPACE_USAGE_KEY = SUU.SPACE_USAGE_KEY\nJOIN \n    SPACE_FLOOR SF ON SD.FLOOR_KEY = SF.FLOOR_KEY\nLEFT JOIN \n    FCLT_ORGANIZATION O ON SU.FCLT_ORGANIZATION_KEY = O.FCLT_ORGANIZATION_KEY\nWHERE \n    B.BUILDING_NUMBER = '36'\nGROUP BY \n    SU.SPACE_UNIT, SF.FLOOR, B.BUILDING_NAME, B.BUILDING_STREET_ADDRESS, SUU.SPACE_USAGE;"
    },
    {
        "db_id": "dw",
        "question": "For each distinct mailing list containing more than 1000 people and with a name starting with A (case insensitive), provide its name, whether it is a mailing list, whether it is a moira group, whether it is a NFS group, the owner of the mailing list, and the number of people in the list.",
        "predicted_sql": "SELECT \n    ML.MOIRA_LIST_NAME, \n    ML.IS_MOIRA_MAILING_LIST, \n    ML.IS_MOIRA_GROUP, \n    ML.IS_NFS_GROUP, \n    O.OWNER, \n    COUNT(DISTINCT MD.MOIRA_LIST_MEMBER) AS NumberOfPeople\nFROM \n    MOIRA_LIST ML\nJOIN \n    MOIRA_LIST_DETAIL MD ON ML.MOIRA_LIST_KEY = MD.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER O ON MD.MOIRA_LIST_OWNER_KEY = O.MOIRA_LIST_OWNER_KEY\nWHERE \n    ML.IS_MOIRA_MAILING_LIST = 'Y' \n    AND ML.MOIRA_LIST_NAME LIKE 'A%' \nGROUP BY \n    ML.MOIRA_LIST_NAME, \n    ML.IS_MOIRA_MAILING_LIST, \n    ML.IS_MOIRA_GROUP, \n    ML.IS_NFS_GROUP, \n    O.OWNER\nHAVING \n    COUNT(DISTINCT MD.MOIRA_LIST_MEMBER) > 1000;"
    },
    {
        "db_id": "dw",
        "question": "List the mailing lists with the largest number of members and the least number of members, including their names, owners, public status, hidden status, and number of members in the list. If a mailing list has multiple owners, create a separate entry for each owner. Similarly, if multiple lists share the minimum or maximum member count, include all those lists.",
        "predicted_sql": "WITH MemberCounts AS (\n    SELECT \n        ml.MOIRA_LIST_NAME,\n        mol.OWNER,\n        ml.IS_PUBLIC,\n        ml.IS_HIDDEN,\n        COUNT(mld.MOIRA_LIST_MEMBER) AS member_count\n    FROM \n        MOIRA_LIST ml\n    JOIN \n        MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n    JOIN \n        MOIRA_LIST_OWNER mol ON mld.MOIRA_LIST_OWNER_KEY = mol.MOIRA_LIST_OWNER_KEY\n    GROUP BY \n        ml.MOIRA_LIST_NAME, mol.OWNER, ml.IS_PUBLIC, ml.IS_HIDDEN\n),\nMaxMinCounts AS (\n    SELECT \n        MAX(member_count) AS max_count,\n        MIN(member_count) AS min_count\n    FROM \n        MemberCounts\n)\nSELECT \n    mc.MOIRA_LIST_NAME,\n    mc.OWNER,\n    mc.IS_PUBLIC,\n    mc.IS_HIDDEN,\n    mc.member_count\nFROM \n    MemberCounts mc\nJOIN \n    MaxMinCounts mmc ON mc.member_count = mmc.max_count OR mc.member_count = mmc.min_count\nORDER BY \n    mc.member_count;"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with C (case insensitive) and containing faculty who teach courses in the summer in financial aid years after 2001, provide the name of the list, the number of people in the list, and the number of faculty in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(mld.MOIRA_LIST_MEMBER) AS total_members,\n    COUNT(DISTINCT ed.MIT_ID) AS faculty_count\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    EMPLOYEE_DIRECTORY ed ON mld.MOIRA_LIST_MEMBER_MIT_ID = ed.MIT_ID\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED cc ON ed.MIT_ID = cc.RESPONSIBLE_FACULTY_MIT_ID\nJOIN \n    ACADEMIC_TERMS at ON cc.TERM_CODE = at.TERM_CODE\nWHERE \n    ml.MOIRA_LIST_NAME ILIKE 'C%'\n    AND at.FINANCIAL_AID_YEAR > '2001'\n    AND at.IS_OFFERED_SUMMER_TERM = 'Y'\nGROUP BY \n    ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Regarding the mailing list about duo users, provide the number of students in this list, and the number of departments and schools associated with these students.",
        "predicted_sql": "SELECT \n    COUNT(DISTINCT moira.MOIRA_LIST_MEMBER_MIT_ID) AS student_count,\n    COUNT(DISTINCT dept.DEPARTMENT_CODE) AS department_count,\n    COUNT(DISTINCT dept.SCHOOL_CODE) AS school_count\nFROM \n    MOIRA_LIST moira\nJOIN \n    MOIRA_LIST_DETAIL moira_detail ON moira.MOIRA_LIST_KEY = moira_detail.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON student ON moira_detail.MOIRA_LIST_MEMBER_MIT_ID = student.MIT_ID\nJOIN \n    MIT_STUDENT_DIRECTORY std_dir ON student.MIT_ID = std_dir.EMAIL_ADDRESS\nJOIN \n    SIS_DEPARTMENT dept ON std_dir.DEPARTMENT = dept.DEPARTMENT_CODE\nWHERE \n    moira.MOIRA_LIST_NAME = 'cat-duo-users';"
    },
    {
        "db_id": "dw",
        "question": "For faculty who are responsible for courses in 2023 fall term, list the name of mailing lists with ten members that they subscribe to, the number of faculty in these lists, and the number of courses associated with those faculty.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME, \n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS number_of_faculty, \n    COUNT(DISTINCT c.SUBJECT_TITLE) AS number_of_courses\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nJOIN \n    MOIRA_LIST_DETAIL mld ON e.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN \n    MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nWHERE \n    c.TERM_CODE = '2023FA'\nGROUP BY \n    ml.MOIRA_LIST_NAME\nHAVING \n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) = 10;"
    },
    {
        "db_id": "dw",
        "question": "For each course instructor in the 'keeper-zephyr' mailing list, provide the name of mailing lists they subscribe to, instructor name, earliest and latest publication years, and total number of enrolled students.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME, \n    ci.INSTRUCTOR_NAME, \n    MIN(rc.CATALOG_YEAR) AS Earliest_Publication_Year, \n    MAX(rc.CATALOG_YEAR) AS Latest_Publication_Year, \n    SUM(so.NUM_ENROLLED_STUDENTS) AS Total_Enrolled_Students\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR ci ON sp.FULL_NAME = ci.INSTRUCTOR_NAME\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL rmd ON ci.LIBRARY_COURSE_INSTRUCTOR_KEY = rmd.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG rc ON rmd.LIBRARY_RESERVE_CATALOG_KEY = rc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED so ON rmd.LIBRARY_SUBJECT_OFFERED_KEY = so.LIBRARY_SUBJECT_OFFERED_KEY\nWHERE \n    ml.MOIRA_LIST_NAME = 'keeper-zephyr'\nGROUP BY \n    ml.MOIRA_LIST_NAME, ci.INSTRUCTOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list with a name beginning with R (case insensitive), and that Professor Ayden Hopkins is subscribed to, list its name, description, owner, number of people in the list, and number of tenured faculty in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME, \n    ml.MOIRA_LIST_DESCRIPTION, \n    mo.OWNER, \n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS number_of_people,\n    SUM(CASE WHEN sp.PAYROLL_RANK LIKE '%tenured%' THEN 1 ELSE 0 END) AS number_of_tenured_faculty\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER mo ON mo.MOIRA_LIST_OWNER_KEY = mld.MOIRA_LIST_OWNER_KEY\nJOIN \n    SE_PERSON sp ON sp.MIT_ID = mld.MOIRA_LIST_MEMBER_MIT_ID\nWHERE \n    ml.IS_MOIRA_MAILING_LIST = 'Y' \n    AND ml.MOIRA_LIST_NAME LIKE 'R%' \n    AND mld.MOIRA_LIST_MEMBER_FULL_NAME = 'Hopkins, Ayden'\nGROUP BY \n    ml.MOIRA_LIST_NAME, \n    ml.MOIRA_LIST_DESCRIPTION, \n    mo.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For the email list with name 'date-destiny', list the name of the list, department name, the number of students from the Management department, and the percentage of students who are from the Management department, rounded to two decimal places.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    sad.SIS_ADMIN_DEPARTMENT_NAME,\n    COUNT(DISTINCT ms.FULL_NAME) AS number_of_students,\n    ROUND(COUNT(DISTINCT ms.FULL_NAME) * 100.0 / (SELECT COUNT(*) FROM MOIRA_LIST_DETAIL mld WHERE mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY), 2) AS percentage_of_management_students\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON sp.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN \n    MIT_STUDENT_DIRECTORY ms ON ms.FULL_NAME = sp.FULL_NAME\nJOIN \n    SIS_ADMIN_DEPARTMENT sad ON ms.DEPARTMENT = sad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    ml.MOIRA_LIST_NAME = 'date-destiny' \n    AND sad.SIS_ADMIN_DEPARTMENT_NAME = 'Management department'\nGROUP BY \n    ml.MOIRA_LIST_NAME, sad.SIS_ADMIN_DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For the building with the most floors, list the building name and the names of the mailing lists staring with a (case insensitive) that the building employees with kerberos starting with c (case insensitive) subscribe to.",
        "predicted_sql": "SELECT fb.BUILDING_NAME, ml.MOIRA_LIST_NAME\nFROM FAC_BUILDING fb\nJOIN FAC_FLOOR ff ON fb.FAC_BUILDING_KEY = ff.BUILDING_KEY\nJOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY\nJOIN EMPLOYEE_DIRECTORY ed ON fr.FAC_ROOM_KEY = ed.OFFICE_LOCATION\nJOIN MOIRA_LIST_DETAIL mld ON ed.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nWHERE ed.KRB_NAME LIKE 'c%'\nAND ml.MOIRA_LIST_NAME LIKE 'a%'\nAND fb.FAC_BUILDING_KEY = (\n    SELECT fb2.FAC_BUILDING_KEY\n    FROM FAC_BUILDING fb2\n    JOIN FAC_FLOOR ff2 ON fb2.FAC_BUILDING_KEY = ff2.BUILDING_KEY\n    GROUP BY fb2.FAC_BUILDING_KEY\n    ORDER BY COUNT(ff2.LEVEL_ID) DESC\n    LIMIT 1\n)\nORDER BY fb.BUILDING_NAME, ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For the email lists subscribed by faculty members with last names begin with Y, list the names of the lists, the total number of subjects managed by faculty in those mailing lists, and the number of such faculty in the lists.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(DISTINCT cso.SUBJECT_ID) AS total_subjects,\n    COUNT(DISTINCT ed.MIT_ID) AS total_faculty\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    EMPLOYEE_DIRECTORY ed ON mld.MOIRA_LIST_MEMBER_MIT_ID = ed.MIT_ID\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED cso ON ed.FULL_NAME LIKE '%' || SUBSTR(ed.LAST_NAME, 1, 1) || '%'\nWHERE \n    ed.LAST_NAME LIKE 'Y%'\nGROUP BY \n    ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with H who are subscribed to mailing list 'beacon-date-date', list the names of the students, the phone numbers of departments they belong to, and the size of the mailing list 'beacon-date-date' that they are subscribed to.",
        "predicted_sql": "SELECT \n    msd.FULL_NAME, \n    sad.DEPARTMENT_PHONE_NUMBER, \n    (SELECT COUNT(*) FROM MOIRA_LIST_DETAIL mld WHERE mld.MOIRA_LIST_KEY = 'beacon-date-date') AS mailing_list_size\nFROM \n    MIT_STUDENT_DIRECTORY msd\nJOIN \n    SE_PERSON sp ON msd.FULL_NAME = sp.FULL_NAME\nJOIN \n    MOIRA_LIST_DETAIL mld ON sp.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN \n    MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nJOIN \n    SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    msd.LAST_NAME LIKE 'H%' AND \n    ml.MOIRA_LIST_NAME = 'beacon-date-date';"
    },
    {
        "db_id": "dw",
        "question": "Give the count of mailing lists with names starting with B that include members from the Electrical Engineering and Computer Science department, along with the name of the list starting with B that have the highest number of members from that department and the corresponding member count.",
        "predicted_sql": "WITH MemberCounts AS (\n    SELECT \n        ml.MOIRA_LIST_NAME,\n        COUNT(*) AS member_count\n    FROM \n        MOIRA_LIST ml\n    JOIN \n        MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n    JOIN \n        SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\n    WHERE \n        ml.MOIRA_LIST_NAME LIKE 'B%' AND \n        sp.ORGANIZATION = 'Electrical Engineering and Computer Science'\n    GROUP BY \n        ml.MOIRA_LIST_NAME\n)\nSELECT \n    (SELECT COUNT(*) FROM MemberCounts) AS total_mailings,\n    MAX(MOIRA_LIST_NAME) AS max_list_name,\n    MAX(member_count) AS max_member_count\nFROM \n    MemberCounts;"
    },
    {
        "db_id": "dw",
        "question": "For the 'kangaroo-inspire-yearn' email list, for each department present in the list, list the department name, the number of students in that department, and its percentage relative to the students in the mailing list.",
        "predicted_sql": "SELECT \n    d.SIS_ADMIN_DEPARTMENT_NAME,\n    COUNT(sd.FULL_NAME) AS student_count,\n    COUNT(sd.FULL_NAME) * 100.0 / (SELECT COUNT(*) FROM MOIRA_LIST_DETAIL WHERE MOIRA_LIST_KEY = 'kangaroo-inspire-yearn') AS percentage\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN \n    MIT_STUDENT_DIRECTORY sd ON sp.FULL_NAME = sd.FULL_NAME\nJOIN \n    SIS_ADMIN_DEPARTMENT d ON sd.DEPARTMENT = d.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    ml.MOIRA_LIST_NAME = 'kangaroo-inspire-yearn'\nGROUP BY \n    d.SIS_ADMIN_DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Among the mailing lists subscribed by people with physical offices in building 24, provide the name of the most subscribed mailing list and the total number of subscribers.",
        "predicted_sql": "SELECT ml.MOIRA_LIST_NAME, COUNT(mld.MOIRA_LIST_MEMBER) AS total_subscribers \nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN EMPLOYEE_DIRECTORY ed ON ed.KRB_NAME = mld.MOIRA_LIST_MEMBER\nWHERE ed.OFFICE_LOCATION LIKE '24%'\nGROUP BY ml.MOIRA_LIST_NAME\nORDER BY total_subscribers DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For email lists subscribed by either support staff or faculty, list its name, the number of subscribers that are support staff, the number of subscribers that are faculty, as well as its active status.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(CASE WHEN sp.EMPLOYEE_TYPE = 'Support Staff' THEN 1 END) AS support_staff_count,\n    COUNT(CASE WHEN sp.EMPLOYEE_TYPE = 'Faculty' THEN 1 END) AS faculty_count,\n    ml.IS_ACTIVE\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER_MIT_ID = sp.MIT_ID\nWHERE \n    sp.EMPLOYEE_TYPE IN ('Support Staff', 'Faculty')\nGROUP BY \n    ml.MOIRA_LIST_NAME, ml.IS_ACTIVE;"
    },
    {
        "db_id": "dw",
        "question": "For the 'ocean-apple' mailing list, identify the department with the highest student count. Provide the department name, phone number, and the total number of students subscribed to the mailing list from that department. If multiple departments have the same highest count, list each one separately.",
        "predicted_sql": "SELECT \n    SAD.SIS_ADMIN_DEPARTMENT_NAME, \n    SAD.DEPARTMENT_PHONE_NUMBER, \n    COUNT(MSD.FULL_NAME) AS student_count\nFROM \n    MOIRA_LIST ML \nJOIN \n    MOIRA_LIST_DETAIL MLD ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY \nJOIN \n    SE_PERSON SP ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME \nJOIN \n    MIT_STUDENT_DIRECTORY MSD ON SP.FULL_NAME = MSD.FULL_NAME \nJOIN \n    SIS_ADMIN_DEPARTMENT SAD ON MSD.DEPARTMENT = SAD.SIS_ADMIN_DEPARTMENT_CODE \nWHERE \n    ML.MOIRA_LIST_NAME = 'ocean-apple' \nGROUP BY \n    SAD.SIS_ADMIN_DEPARTMENT_NAME, SAD.DEPARTMENT_PHONE_NUMBER\nHAVING \n    COUNT(MSD.FULL_NAME) = (\n        SELECT MAX(student_count) \n        FROM (\n            SELECT COUNT(MSD.FULL_NAME) AS student_count\n            FROM \n                MOIRA_LIST ML \n            JOIN \n                MOIRA_LIST_DETAIL MLD ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY \n            JOIN \n                SE_PERSON SP ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME \n            JOIN \n                MIT_STUDENT_DIRECTORY MSD ON SP.FULL_NAME = MSD.FULL_NAME \n            WHERE \n                ML.MOIRA_LIST_NAME = 'ocean-apple' \n            GROUP BY \n                MSD.DEPARTMENT\n        )\n    )"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list, list its owner, owner type, the member visibility ('Public Members' if public, and 'Hidden Members' otherwise), and the number of members of this type of visibility. For each owner and owner type, include a grand total for all members in the format of (owner, owner type, null, total members).",
        "predicted_sql": "SELECT \n    o.OWNER, \n    o.OWNER_TYPE, \n    CASE \n        WHEN l.IS_PUBLIC = 'Y' THEN 'Public Members' \n        ELSE 'Hidden Members' \n    END AS MEMBER_VISIBILITY, \n    COUNT(d.MOIRA_LIST_MEMBER) AS TOTAL_MEMBERS \nFROM \n    MOIRA_LIST l \nJOIN \n    MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY \nJOIN \n    MOIRA_LIST_OWNER o ON o.MOIRA_LIST_OWNER_KEY = d.MOIRA_LIST_OWNER_KEY \nWHERE \n    l.IS_MOIRA_MAILING_LIST = 'Y' \nGROUP BY \n    o.OWNER, \n    o.OWNER_TYPE, \n    l.IS_PUBLIC \n\nUNION ALL \n\nSELECT \n    o.OWNER, \n    o.OWNER_TYPE, \n    NULL AS MEMBER_VISIBILITY, \n    COUNT(d.MOIRA_LIST_MEMBER) AS TOTAL_MEMBERS \nFROM \n    MOIRA_LIST l \nJOIN \n    MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY \nJOIN \n    MOIRA_LIST_OWNER o ON o.MOIRA_LIST_OWNER_KEY = d.MOIRA_LIST_OWNER_KEY \nWHERE \n    l.IS_MOIRA_MAILING_LIST = 'Y' \nGROUP BY \n    o.OWNER, \n    o.OWNER_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "Group biology courses by cluster type and course level. For each group, list the name of the department, the course title, cluster type, total enrollments, average enrollment within its cluster, course level, number of unique course materials, average new and used prices for TIP materials, total material record count for TIP materials, number of unique library titles, and number of unique library ISBNs.",
        "predicted_sql": "SELECT \n    sos.OFFER_DEPT_NAME AS department_name,\n    sos.SUBJECT_TITLE AS course_title,\n    sos.CLUSTER_TYPE AS cluster_type,\n    SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollments,\n    AVG(sos.NUM_ENROLLED_STUDENTS) OVER (PARTITION BY sos.CLUSTER_TYPE) AS average_enrollment_within_cluster,\n    scd.COURSE_LEVEL AS course_level,\n    COUNT(DISTINCT tm.TIP_MATERIAL_KEY) AS number_of_unique_course_materials,\n    AVG(tm.NEW_SHELF_PRICE) AS average_new_price,\n    AVG(tm.USED_SHELF_PRICE) AS average_used_price,\n    SUM(td.RECORD_COUNT) AS total_material_record_count,\n    COUNT(DISTINCT lrc.CATALOG_TITLE) AS number_of_unique_library_titles,\n    COUNT(DISTINCT lrc.CATALOG_ISBN) AS number_of_unique_library_isbns\nFROM \n    SUBJECT_OFFERED_SUMMARY sos\nJOIN \n    SIS_COURSE_DESCRIPTION scd ON sos.COURSE_NUMBER = scd.COURSE\nLEFT JOIN \n    TIP_DETAIL td ON sos.SUBJECT_ID = td.SUBJECT_ID\nLEFT JOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrc.CATALOG_ISBN IN (SELECT tm.ISBN)\nWHERE \n    sos.SUBJECT_TITLE LIKE '%Biology%'\nGROUP BY \n    sos.OFFER_DEPT_NAME, sos.SUBJECT_TITLE, sos.CLUSTER_TYPE, scd.COURSE_LEVEL"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered this year in either the Fall or Spring term, list its department name, school name, subject ID, subject title, course level, total units, the term it is offered ('Spring' for Spring term and 'Fall' for Fall term), term description, the number of distinct instructors teaching in the Fall, and the number of distinct instructors teaching in the Spring.",
        "predicted_sql": "SELECT \n    CDS.DEPARTMENT_NAME,\n    SD.SCHOOL_NAME,\n    CCO.SUBJECT_ID,\n    CCO.SUBJECT_TITLE,\n    SCD.COURSE_LEVEL,\n    CCO.TOTAL_UNITS,\n    CASE \n        WHEN CCO.IS_OFFERED_FALL_TERM = 'Y' THEN 'Fall' \n        WHEN CCO.IS_OFFERED_SPRING_TERM = 'Y' THEN 'Spring' \n    END AS TERM,\n    AT.TERM_DESCRIPTION,\n    COUNT(DISTINCT CASE WHEN CCO.IS_OFFERED_FALL_TERM = 'Y' THEN CCO.FALL_INSTRUCTORS END) AS FALL_INSTRUCTORS_COUNT,\n    COUNT(DISTINCT CASE WHEN CCO.IS_OFFERED_SPRING_TERM = 'Y' THEN CCO.SPRING_INSTRUCTORS END) AS SPRING_INSTRUCTORS_COUNT\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED CCO\nJOIN \n    ACADEMIC_TERMS AT ON CCO.TERM_CODE = AT.TERM_CODE\nJOIN \n    SIS_DEPARTMENT SD ON CCO.DEPARTMENT_CODE = SD.DEPARTMENT_CODE\nJOIN \n    SIS_COURSE_DESCRIPTION SCD ON CCO.SUBJECT_CODE = SCD.COURSE\nWHERE \n    CCO.IS_OFFERED_THIS_YEAR = 'Y' \n    AND (CCO.IS_OFFERED_FALL_TERM = 'Y' OR CCO.IS_OFFERED_SPRING_TERM = 'Y')\nGROUP BY \n    CDS.DEPARTMENT_NAME,\n    SD.SCHOOL_NAME,\n    CCO.SUBJECT_ID,\n    CCO.SUBJECT_TITLE,\n    SCD.COURSE_LEVEL,\n    CCO.TOTAL_UNITS,\n    AT.TERM_DESCRIPTION"
    },
    {
        "db_id": "dw",
        "question": "For Political Science courses with HASS attributes, for each attribute, list the name and description of the attribute, the number of unique subjects, average units, the total enrollment, the number of departments that grant degrees, and the subject code description.",
        "predicted_sql": "SELECT \n    c.HASS_ATTRIBUTE AS name,\n    c.HASS_ATTRIBUTE_DESC AS description,\n    COUNT(DISTINCT c.SUBJECT_ID) AS unique_subjects,\n    AVG(c.TOTAL_UNITS) AS average_units,\n    SUM(s.NUM_ENROLLED_STUDENTS) AS total_enrollment,\n    COUNT(DISTINCT d.DEPARTMENT_CODE) AS departments_granting_degrees,\n    sc.SUBJECT_CODE_DESC AS subject_code_description\nFROM \n    CIS_COURSE_CATALOG c\nJOIN \n    SUBJECT_OFFERED_SUMMARY s ON c.SUBJECT_ID = s.SUBJECT_ID\nJOIN \n    SIS_SUBJECT_CODE sc ON c.SUBJECT_CODE = sc.SUBJECT_CODE\nJOIN \n    SIS_DEPARTMENT d ON sc.DEPARTMENT_CODE = d.DEPARTMENT_CODE\nWHERE \n    d.DEPARTMENT_NAME = 'Political Science' \nGROUP BY \n    c.HASS_ATTRIBUTE, c.HASS_ATTRIBUTE_DESC, sc.SUBJECT_CODE_DESC;"
    },
    {
        "db_id": "dw",
        "question": "Group subjects by cluster type, department offering the subject, and the school name. For each group, list the cluster type, name of the department, school name, whether the department grants degrees, total number of subjects, total enrollment, and average enrollment. Exclude clusters or schools with no student data.",
        "predicted_sql": "SELECT \n    sos.CLUSTER_TYPE,\n    sos.OFFER_DEPT_NAME,\n    sd.SCHOOL_NAME,\n    sd.IS_DEGREE_GRANTING,\n    COUNT(sos.SUBJECT_ID) AS total_subjects,\n    SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollment,\n    AVG(sos.NUM_ENROLLED_STUDENTS) AS average_enrollment\nFROM \n    SUBJECT_OFFERED_SUMMARY sos\nJOIN \n    SIS_DEPARTMENT sd ON sos.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE\nWHERE \n    sos.NUM_ENROLLED_STUDENTS > 0\nGROUP BY \n    sos.CLUSTER_TYPE, sos.OFFER_DEPT_NAME, sd.SCHOOL_NAME, sd.IS_DEGREE_GRANTING\nHAVING \n    total_enrollment > 0"
    },
    {
        "db_id": "dw",
        "question": "Group classes that take place in buildings at MIT by the building name and course level. For each group, provide the name of the building, the course level ('Graduate' or 'Undergraduate'), the total number of unique courses of such level, and total instructors for these courses. Include subtotals for each building and course level and a grand total across all buildings and course levels.",
        "predicted_sql": "WITH CourseDetails AS (\n    SELECT \n        fb.BUILDING_NAME,\n        scd.COURSE_LEVEL,\n        so.SUBJECT_ID,\n        so.RESPONSIBLE_FACULTY_NAME\n    FROM \n        FAC_BUILDING fb\n    JOIN \n        SUBJECT_OFFERED so ON fb.FAC_BUILDING_KEY = so.MEET_PLACE\n    JOIN \n        SIS_COURSE_DESCRIPTION scd ON so.COURSE_NUMBER = scd.COURSE\n    WHERE \n        fb.SITE = 'MIT'\n),\nAggregatedData AS (\n    SELECT \n        BUILDING_NAME,\n        CASE \n            WHEN COURSE_LEVEL = 'G' THEN 'Graduate'\n            WHEN COURSE_LEVEL = 'U' THEN 'Undergraduate'\n        END AS Course_Level,\n        COUNT(DISTINCT SUBJECT_ID) AS Total_Courses,\n        COUNT(DISTINCT RESPONSIBLE_FACULTY_NAME) AS Total_Instructors\n    FROM \n        CourseDetails\n    GROUP BY \n        BUILDING_NAME, Course_Level\n)\nSELECT \n    BUILDING_NAME,\n    Course_Level,\n    Total_Courses,\n    Total_Instructors\nFROM \n    AggregatedData\nUNION ALL\nSELECT \n    'Subtotal' AS BUILDING_NAME,\n    Course_Level,\n    SUM(Total_Courses),\n    SUM(Total_Instructors)\nFROM \n    AggregatedData\nGROUP BY \n    Course_Level\nUNION ALL\nSELECT \n    'Grand Total' AS BUILDING_NAME,\n    NULL AS Course_Level,\n    SUM(Total_Courses),\n    SUM(Total_Instructors)\nFROM \n    AggregatedData;"
    },
    {
        "db_id": "dw",
        "question": "For each course, provide the room number of course location, building name, building number, building city, building state, area, organization name, room usage, term code, course level, the total number of subjects, unique meeting times, and total units. Do not include meet place or meet times with NULL values.",
        "predicted_sql": "SELECT \n    FAC_ROOMS.ROOM AS room_number,\n    FAC_BUILDING.BUILDING_NAME AS building_name,\n    FAC_BUILDING.BUILDING_NUMBER AS building_number,\n    FAC_BUILDING_ADDRESS.CITY AS building_city,\n    FAC_BUILDING_ADDRESS.STATE AS building_state,\n    FAC_ROOMS.AREA AS area,\n    FAC_ROOMS.ORGANIZATION_NAME AS organization_name,\n    FAC_MAJOR_USE.MAJOR_USE AS room_usage,\n    COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE AS term_code,\n    SIS_COURSE_DESCRIPTION.COURSE_LEVEL AS course_level,\n    COUNT(DISTINCT COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID) AS total_subjects,\n    COUNT(DISTINCT COURSE_CATALOG_SUBJECT_OFFERED.MEET_TIME) AS unique_meeting_times,\n    COURSE_CATALOG_SUBJECT_OFFERED.TOTAL_UNITS AS total_units\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED\nJOIN \n    FAC_ROOMS ON FAC_ROOMS.FAC_ROOM_KEY = COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE\nJOIN \n    FAC_BUILDING ON FAC_ROOMS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY\nJOIN \n    FAC_MAJOR_USE ON FAC_ROOMS.MAJOR_USE_KEY = FAC_MAJOR_USE.MAJOR_USE_KEY\nJOIN \n    SIS_COURSE_DESCRIPTION ON SIS_COURSE_DESCRIPTION.COURSE = COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID\nWHERE \n    COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE IS NOT NULL\nGROUP BY \n    FAC_ROOMS.ROOM,\n    FAC_BUILDING.BUILDING_NAME,\n    FAC_BUILDING.BUILDING_NUMBER,\n    FAC_BUILDING_ADDRESS.CITY,\n    FAC_BUILDING_ADDRESS.STATE,\n    FAC_ROOMS.AREA,\n    FAC_ROOMS.ORGANIZATION_NAME,\n    COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE,\n    SIS_COURSE_DESCRIPTION.COURSE_LEVEL,\n    COURSE_CATALOG_SUBJECT_OFFERED.TOTAL_UNITS;"
    },
    {
        "db_id": "dw",
        "question": "Consider only books cataloged on or after 2000. For each library material status and department, list the material status, department name, number of associated catalog items, and the total number of enrolled students in courses using those materials. Include subtotals for each material status and a grand total across all status (the corresponding status field is 'Grand Total').",
        "predicted_sql": "WITH CatalogData AS (\n    SELECT \n        LMS.LIBRARY_MATERIAL_STATUS AS MaterialStatus,\n        SSC.DEPARTMENT_NAME AS DepartmentName,\n        COUNT(DISTINCT LRC.LIBRARY_RESERVE_CATALOG_KEY) AS CatalogItemCount,\n        SUM(SO.NUM_ENROLLED_STUDENTS) AS TotalEnrolledStudents\n    FROM \n        LIBRARY_RESERVE_CATALOG LRC\n    JOIN \n        LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LRC.LIBRARY_RESERVE_CATALOG_KEY = LRMD.LIBRARY_RESERVE_CATALOG_KEY\n    JOIN \n        LIBRARY_MATERIAL_STATUS LMS ON LRMD.LIBRARY_MATERIAL_STATUS_KEY = LMS.LIBRARY_MATERIAL_STATUS_KEY\n    JOIN \n        LIBRARY_SUBJECT_OFFERED SO ON LRMD.LIBRARY_SUBJECT_OFFERED_KEY = SO.LIBRARY_SUBJECT_OFFERED_KEY\n    JOIN \n        SIS_SUBJECT_CODE SSC ON SO.COURSE_NUMBER = SSC.COURSE_NUMBER\n    WHERE \n        LRC.CATALOG_YEAR >= '2000'\n    GROUP BY \n        LMS.LIBRARY_MATERIAL_STATUS, SSC.DEPARTMENT_NAME\n),\nSubtotals AS (\n    SELECT \n        MaterialStatus,\n        DepartmentName,\n        CatalogItemCount,\n        TotalEnrolledStudents\n    FROM \n        CatalogData\n    UNION ALL\n    SELECT \n        MaterialStatus,\n        'Subtotal' AS DepartmentName,\n        SUM(CatalogItemCount) AS CatalogItemCount,\n        SUM(TotalEnrolledStudents) AS TotalEnrolledStudents\n    FROM \n        CatalogData\n    GROUP BY \n        MaterialStatus\n),\nGrandTotal AS (\n    SELECT \n        'Grand Total' AS MaterialStatus,\n        'Grand Total' AS DepartmentName,\n        SUM(CatalogItemCount) AS CatalogItemCount,\n        SUM(TotalEnrolledStudents) AS TotalEnrolledStudents\n    FROM \n        CatalogData\n)\nSELECT \n    MaterialStatus, \n    DepartmentName, \n    CatalogItemCount, \n    TotalEnrolledStudents\nFROM \n    Subtotals\nUNION ALL\nSELECT \n    MaterialStatus, \n    DepartmentName, \n    CatalogItemCount, \n    TotalEnrolledStudents\nFROM \n    GrandTotal\nORDER BY \n    MaterialStatus, DepartmentName;"
    },
    {
        "db_id": "dw",
        "question": "For each department in the library system, list the name of the department, total number of courses using library materials, the number of catalog items associated with those courses, and the average enrollment per course. Include a grand total across all departments (the corresponding department field should be 'Grand Total').",
        "predicted_sql": "SELECT \n    COALESCE(c.department, 'Grand Total') AS department,\n    COUNT(DISTINCT ci.course_name) AS total_courses,\n    COUNT(DISTINCT rc.library_reserve_catalog_key) AS total_catalog_items,\n    AVG(so.num_enrolled_students) AS avg_enrollment_per_course\nFROM \n    library_course_instructor ci\nLEFT JOIN \n    library_reserve_matrl_detail md ON ci.library_course_instructor_key = md.library_course_instructor_key\nLEFT JOIN \n    library_reserve_catalog rc ON md.library_reserve_catalog_key = rc.library_reserve_catalog_key\nLEFT JOIN \n    library_subject_offered so ON md.library_subject_offered_key = so.library_subject_offered_key\nGROUP BY \n    c.department WITH ROLLUP\nHAVING \n    department IS NOT NULL\nORDER BY \n    department;"
    },
    {
        "db_id": "dw",
        "question": "For each department and school offering courses with materials, list the department name, school name, number of unique course materials, number of courses, average new and used shelf prices of materials, total material records, and number of distinct material statuses. Include a grand total across all schools and departments (the corresponding school and department fields should be null).",
        "predicted_sql": "WITH DepartmentCourseMaterials AS (\n    SELECT \n        d.DEPARTMENT_NAME,\n        d.SCHOOL_NAME,\n        COUNT(DISTINCT m.TITLE) AS unique_materials,\n        COUNT(DISTINCT so.SUBJECT_TITLE) AS courses,\n        AVG(m.NEW_SHELF_PRICE) AS avg_new_price,\n        AVG(m.USED_SHELF_PRICE) AS avg_used_price,\n        SUM(td.RECORD_COUNT) AS total_material_records,\n        COUNT(DISTINCT ms.TIP_MATERIAL_STATUS) AS distinct_material_statuses\n    FROM \n        SIS_DEPARTMENT d\n    JOIN \n        TIP_SUBJECT_OFFERED so ON d.DEPARTMENT_CODE = so.OFFER_DEPT_CODE\n    JOIN \n        TIP_DETAIL td ON so.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\n    JOIN \n        TIP_MATERIAL m ON td.TIP_MATERIAL_KEY = m.TIP_MATERIAL_KEY\n    JOIN \n        TIP_MATERIAL_STATUS ms ON td.TIP_MATERIAL_STATUS_KEY = ms.TIP_MATERIAL_STATUS_KEY\n    WHERE \n        so.IS_NO_COURSE_MATERIAL = 'N'\n    GROUP BY \n        d.DEPARTMENT_NAME, d.SCHOOL_NAME\n)\nSELECT \n    DEPARTMENT_NAME,\n    SCHOOL_NAME,\n    unique_materials,\n    courses,\n    avg_new_price,\n    avg_used_price,\n    total_material_records,\n    distinct_material_statuses\nFROM \n    DepartmentCourseMaterials\nUNION ALL\nSELECT \n    NULL AS DEPARTMENT_NAME,\n    NULL AS SCHOOL_NAME,\n    SUM(unique_materials) AS unique_materials,\n    SUM(courses) AS courses,\n    AVG(avg_new_price) AS avg_new_price,\n    AVG(avg_used_price) AS avg_used_price,\n    SUM(total_material_records) AS total_material_records,\n    SUM(distinct_material_statuses) AS distinct_material_statuses\nFROM \n    DepartmentCourseMaterials;"
    },
    {
        "db_id": "dw",
        "question": "For each TIP material status, list the total number of unique materials associated with the status, the total number of records associated with the status, and the total student enrollment associated with the status. Any material status with null values should be displayed as 'No material status'. Additionally, include a grand total across all material status (the material status for this row should be displayed as 'Grand Total').",
        "predicted_sql": "SELECT \n    COALESCE(TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS, 'No material status') AS material_status,\n    COUNT(DISTINCT TIP_MATERIAL.ISBN) AS unique_materials_count,\n    SUM(TIP_DETAIL.RECORD_COUNT) AS total_records_count,\n    SUM(TIP_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS) AS total_enrollment_count\nFROM \n    TIP_DETAIL\nLEFT JOIN \n    TIP_MATERIAL_STATUS ON TIP_DETAIL.TIP_MATERIAL_STATUS_KEY = TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY\nLEFT JOIN \n    TIP_MATERIAL ON TIP_DETAIL.TIP_MATERIAL_KEY = TIP_MATERIAL.TIP_MATERIAL_KEY\nLEFT JOIN \n    TIP_SUBJECT_OFFERED ON TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY = TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY\nGROUP BY \n    TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS\nUNION ALL\nSELECT \n    'Grand Total' AS material_status,\n    COUNT(DISTINCT TIP_MATERIAL.ISBN) AS unique_materials_count,\n    SUM(TIP_DETAIL.RECORD_COUNT) AS total_records_count,\n    SUM(TIP_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS) AS total_enrollment_count\nFROM \n    TIP_DETAIL\nLEFT JOIN \n    TIP_MATERIAL_STATUS ON TIP_DETAIL.TIP_MATERIAL_STATUS_KEY = TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY\nLEFT JOIN \n    TIP_MATERIAL ON TIP_DETAIL.TIP_MATERIAL_KEY = TIP_MATERIAL.TIP_MATERIAL_KEY\nLEFT JOIN \n    TIP_SUBJECT_OFFERED ON TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY = TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY;"
    },
    {
        "db_id": "dw",
        "question": "For each room, list its associated building name, floor number, room number, ownership type, organization name, number of rooms, area, and percentage of area relative to the building. Include subtotals across floors, subtotals across all floors for each building, and a grand total across all buildings. For the subtotal for each building and the grand total, the percentage of area should be relative to area of all buildings. All numeric values should be rounded to integers and formatted using commas as thousands separators except the relative percentages which should be rounded to two decimal places.",
        "predicted_sql": "WITH RoomDetails AS (\n    SELECT \n        b.BUILDING_NAME_LONG,\n        f.FLOOR,\n        r.BUILDING_ROOM,\n        b.OWNERSHIP_TYPE,\n        o.ORGANIZATION_NAME,\n        COUNT(r.FCLT_ROOM_KEY) OVER (PARTITION BY f.FLOOR, b.BUILDING_NAME_LONG) AS NUM_OF_ROOMS,\n        ROUND(r.AREA) AS AREA,\n        SUM(r.AREA) OVER (PARTITION BY b.BUILDING_NAME_LONG) AS BUILDING_TOTAL_AREA\n    FROM \n        FCLT_ROOMS r\n    JOIN \n        FCLT_FLOOR f ON r.FCLT_FLOOR_KEY = f.FCLT_FLOOR_KEY\n    JOIN \n        FCLT_BUILDING b ON f.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\n    JOIN \n        FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY\n),\nTotalArea AS (\n    SELECT \n        SUM(AREA) AS TOTAL_AREA\n    FROM \n        RoomDetails\n)\nSELECT \n    building_name,\n    floor,\n    building_room,\n    ownership_type,\n    organization_name,\n    num_of_rooms,\n    area,\n    ROUND((area * 100.0 / building_total_area), 2) AS percentage_area,\n    ROUND((SUM(area) OVER (PARTITION BY building_name)), 0) AS building_subtotal,\n    ROUND((SUM(area) OVER (PARTITION BY NULL)), 0) AS grand_total\nFROM \n    RoomDetails \nORDER BY \n    building_name, floor;"
    },
    {
        "db_id": "dw",
        "question": "For each financial aid year and academic year, list the number of fiscal periods, quarters, the start term date, the end term date, and number of distinct department-level term parameters.",
        "predicted_sql": "SELECT \n    ACADEMIC_TERMS.FINANCIAL_AID_YEAR, \n    ACADEMIC_TERMS.ACADEMIC_YEAR, \n    COUNT(DISTINCT TIME_MONTH.FISCAL_PERIOD) AS fiscal_periods, \n    COUNT(DISTINCT TIME_QUARTER.FY_QUARTER_CODE) AS quarters, \n    MIN(TIME_DAY.START_DATE) AS start_term_date, \n    MAX(TIME_DAY.END_DATE) AS end_term_date, \n    COUNT(DISTINCT ACADEMIC_TERM_PARAMETER.TERM_PARAMETER) AS distinct_term_parameters\nFROM \n    ACADEMIC_TERMS\nJOIN \n    TIME_DAY ON ACADEMIC_TERMS.TERM_START_DATE = TIME_DAY.CALENDAR_DATE\nJOIN \n    TIME_MONTH ON TIME_DAY.FISCAL_PERIOD = TIME_MONTH.FISCAL_PERIOD\nJOIN \n    TIME_QUARTER ON TIME_MONTH.FISCAL_YEAR = TIME_QUARTER.FISCAL_YEAR\nJOIN \n    ACADEMIC_TERM_PARAMETER ON ACADEMIC_TERMS.TERM_CODE = ACADEMIC_TERM_PARAMETER.TERM_CODE\nGROUP BY \n    ACADEMIC_TERMS.FINANCIAL_AID_YEAR, \n    ACADEMIC_TERMS.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "Group buildings by campus sectors. For each group, list the campus sector, name of the building, city and state where the building is located, total number of floors, total assignable area, total number of rooms, total number of organizations, ownership type, and a rank column indicating the order (1-indexed) of this row within each sector based on the descending order of assignable area. Include subtotals for each sector and a grand total across all sectors. The subtotal and grand total only need to computed over the total number of floors and assignable area.",
        "predicted_sql": "WITH BuildingData AS (\n    SELECT \n        FCLT_BUILDING.CAMPUS_SECTOR,\n        FCLT_BUILDING.BUILDING_NAME_LONG,\n        FCLT_BUILDING_ADDRESS.CITY,\n        FCLT_BUILDING_ADDRESS.STATE,\n        COUNT(DISTINCT FCLT_FLOOR.FLOOR) AS TOTAL_FLOORS,\n        SUM(FCLT_BUILDING.ASSIGNABLE_AREA) AS TOTAL_ASSIGNABLE_AREA,\n        COUNT(DISTINCT FCLT_ROOMS.FCLT_ROOM_KEY) AS TOTAL_ROOMS,\n        COUNT(DISTINCT FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY) AS TOTAL_ORGANIZATIONS,\n        FCLT_BUILDING.OWNERSHIP_TYPE\n    FROM \n        FCLT_BUILDING\n        JOIN FCLT_BUILDING_ADDRESS ON FCLT_BUILDING.FCLT_BUILDING_KEY = FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY\n        JOIN FCLT_FLOOR ON FCLT_BUILDING.FCLT_BUILDING_KEY = FCLT_FLOOR.FCLT_BUILDING_KEY\n        JOIN FCLT_ROOMS ON FCLT_BUILDING.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY\n        JOIN FCLT_ORGANIZATION ON FCLT_ROOMS.FCLT_ORGANIZATION_KEY = FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY\n    GROUP BY \n        FCLT_BUILDING.CAMPUS_SECTOR,\n        FCLT_BUILDING.BUILDING_NAME_LONG,\n        FCLT_BUILDING_ADDRESS.CITY,\n        FCLT_BUILDING_ADDRESS.STATE,\n        FCLT_BUILDING.OWNERSHIP_TYPE\n),\nRankedData AS (\n    SELECT \n        CAMPUS_SECTOR,\n        BUILDING_NAME_LONG,\n        CITY,\n        STATE,\n        TOTAL_FLOORS,\n        TOTAL_ASSIGNABLE_AREA,\n        TOTAL_ROOMS,\n        TOTAL_ORGANIZATIONS,\n        OWNERSHIP_TYPE,\n        ROW_NUMBER() OVER (PARTITION BY CAMPUS_SECTOR ORDER BY TOTAL_ASSIGNABLE_AREA DESC) AS RANK\n    FROM \n        BuildingData\n),\nSubtotals AS (\n    SELECT \n        CAMPUS_SECTOR,\n        'Subtotal' AS BUILDING_NAME_LONG,\n        NULL AS CITY,\n        NULL AS STATE,\n        SUM(TOTAL_FLOORS) AS TOTAL_FLOORS,\n        SUM(TOTAL_ASSIGNABLE_AREA) AS TOTAL_ASSIGNABLE_AREA,\n        NULL AS TOTAL_ROOMS,\n        NULL AS TOTAL_ORGANIZATIONS,\n        NULL AS OWNERSHIP_TYPE,\n        NULL AS RANK\n    FROM \n        RankedData\n    GROUP BY \n        CAMPUS_SECTOR\n)\nSELECT \n    CAMPUS_SECTOR,\n    BUILDING_NAME_LONG,\n    CITY,\n    STATE,\n    TOTAL_FLOORS,\n    TOTAL_ASSIGNABLE_AREA,\n    TOTAL_ROOMS,\n    TOTAL_ORGANIZATIONS,\n    OWNERSHIP_TYPE,\n    RANK\nFROM \n    RankedData\nUNION ALL\nSELECT \n    CAMPUS_SECTOR,\n    BUILDING_NAME_LONG,\n    CITY,\n    STATE,\n    TOTAL_FLOORS,\n    TOTAL_ASSIGNABLE_AREA,\n    TOTAL_ROOMS,\n    TOTAL_ORGANIZATIONS,\n    OWNERSHIP_TYPE,\n    RANK\nFROM \n    Subtotals\nORDER BY \n    CAMPUS_SECTOR, \n    RANK;\n\nSELECT \n    'Grand Total' AS CAMPUS_SECTOR, \n    NULL AS BUILDING_NAME_LONG,\n    NULL AS CITY,\n    NULL AS STATE,\n    SUM(TOTAL_FLOORS) AS TOTAL_FLOORS,\n    SUM(TOTAL_ASSIGNABLE_AREA) AS TOTAL_ASSIGNABLE_AREA,\n    NULL AS TOTAL_ROOMS,\n    NULL AS TOTAL_ORGANIZATIONS,\n    NULL AS OWNERSHIP_TYPE\nFROM \n    RankedData;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the name of the department, the title of the TIP material associated with the department, author, ISBN, library term code, and whether it is available in the library reserves ('Available in Library' if yes and 'Not Available in Library' otherwise), the total number of instructors per library book for the department, the total number of materials available in the library for the department, and the total number of available materials across all departments.",
        "predicted_sql": "SELECT \n    tso.OFFER_DEPT_NAME AS department_name,\n    tm.TITLE AS material_title,\n    tm.AUTHOR,\n    tm.ISBN,\n    tso.TERM_CODE,\n    CASE \n        WHEN lrc.CATALOG_ISBN IS NOT NULL THEN 'Available in Library' \n        ELSE 'Not Available in Library' \n    END AS availability,\n    COUNT(DISTINCT lc.LIBRARY_COURSE_INSTRUCTOR_KEY) AS total_instructors_per_book,\n    COUNT(DISTINCT tm.TIP_MATERIAL_KEY) AS total_materials_per_dept,\n    (SELECT COUNT(DISTINCT tm_inner.TIP_MATERIAL_KEY) FROM TIP_MATERIAL tm_inner) AS total_available_materials\nFROM \n    TIP_SUBJECT_OFFERED tso\nJOIN \n    TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrd ON td.TIP_SUBJECT_OFFERED_KEY = lrd.LIBRARY_SUBJECT_OFFERED_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nLEFT JOIN \n    LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nLEFT JOIN \n    LIBRARY_COURSE_INSTRUCTOR lc ON lrd.LIBRARY_COURSE_INSTRUCTOR_KEY = lc.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    tso.OFFER_DEPT_NAME, \n    tm.TITLE, \n    tm.AUTHOR, \n    tm.ISBN, \n    tso.TERM_CODE, \n    lrc.CATALOG_ISBN\nORDER BY \n    tso.OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department and material status, list the name of the department, the material status, the number of TIP materials associated with this department and status, the number of library materials associated with this department and status, the total number of TIP and library materials associated with this department and status. Include a subtotal for each department and a grand total across all departments.",
        "predicted_sql": "WITH TIP_COUNT AS (\n    SELECT \n        tso.OFFER_DEPT_NAME,\n        tms.TIP_MATERIAL_STATUS,\n        COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS TIP_MATERIALS_COUNT\n    FROM \n        TIP_DETAIL td\n    JOIN \n        TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\n    JOIN \n        TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\n    GROUP BY \n        tso.OFFER_DEPT_NAME, tms.TIP_MATERIAL_STATUS\n),\nLIBRARY_COUNT AS (\n    SELECT \n        lso.OFFER_DEPT_NAME,\n        lms.LIBRARY_MATERIAL_STATUS,\n        COUNT(DISTINCT lrd.LIBRARY_RESERVE_CATALOG_KEY) AS LIBRARY_MATERIALS_COUNT\n    FROM \n        LIBRARY_RESERVE_MATRL_DETAIL lrd\n    JOIN \n        LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\n    JOIN \n        LIBRARY_MATERIAL_STATUS lms ON lrd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\n    GROUP BY \n        lso.OFFER_DEPT_NAME, lms.LIBRARY_MATERIAL_STATUS\n)\nSELECT \n    COALESCE(t.OFFER_DEPT_NAME, l.OFFER_DEPT_NAME) AS DEPARTMENT,\n    COALESCE(t.TIP_MATERIAL_STATUS, l.LIBRARY_MATERIAL_STATUS) AS MATERIAL_STATUS,\n    COALESCE(t.TIP_MATERIALS_COUNT, 0) AS TIP_MATERIALS_COUNT,\n    COALESCE(l.LIBRARY_MATERIALS_COUNT, 0) AS LIBRARY_MATERIALS_COUNT,\n    COALESCE(t.TIP_MATERIALS_COUNT, 0) + COALESCE(l.LIBRARY_MATERIALS_COUNT, 0) AS TOTAL_MATERIALS\nFROM \n    TIP_COUNT t\nFULL JOIN \n    LIBRARY_COUNT l ON t.OFFER_DEPT_NAME = l.OFFER_DEPT_NAME AND t.TIP_MATERIAL_STATUS = l.LIBRARY_MATERIAL_STATUS\nORDER BY \n    DEPARTMENT, MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "For each building that is not a subdivision, list the building number, full name, street address, building type, occupancy date, ownership type, and site location. You should also include three rows at the end showing the number of owned, leased, all buildings at MIT that are not subdivisions, in the format of (null, #building Buildings, null, null, null, null, null).",
        "predicted_sql": "SELECT \n    FB.BUILDING_NUMBER,\n    FB.BUILDING_NAME_LONG AS FULL_NAME,\n    B.BUILDING_STREET_ADDRESS,\n    FB.BUILDING_TYPE,\n    FB.DATE_OCCUPIED AS OCCUPANCY_DATE,\n    FB.OWNERSHIP_TYPE,\n    FB.SITE\nFROM \n    FAC_BUILDING FB\nJOIN \n    BUILDINGS B ON FB.FAC_BUILDING_KEY = B.BUILDING_KEY\nWHERE \n    FB.PARENT_BUILDING_NUMBER IS NULL\n\nUNION ALL\n\nSELECT \n    NULL,\n    COUNT(CASE WHEN FB.OWNERSHIP_TYPE = 'OWNED' THEN 1 END) AS TOTAL_OWNED,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL\nFROM \n    FAC_BUILDING FB\nWHERE \n    FB.PARENT_BUILDING_NUMBER IS NULL\n\nUNION ALL\n\nSELECT \n    NULL,\n    COUNT(CASE WHEN FB.OWNERSHIP_TYPE = 'LEASED' THEN 1 END) AS TOTAL_LEASED,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL\nFROM \n    FAC_BUILDING FB\nWHERE \n    FB.PARENT_BUILDING_NUMBER IS NULL\n\nUNION ALL\n\nSELECT \n    NULL,\n    COUNT(*) AS TOTAL_BUILDINGS,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL\nFROM \n    FAC_BUILDING FB\nWHERE \n    FB.PARENT_BUILDING_NUMBER IS NULL;"
    },
    {
        "db_id": "dw",
        "question": "For each owned building that is not a subdivision, list the construction start year, the building number, and the year of initial occupancy. Display the construction start year only if it differs from the previous row. If the year of initial occupancy or construction start year is unknown, display 'UNKNOWN'. You should also include a row at the end showing the total number of owned buildings that are not subdivisions, in the format of (null, #building Buildings, null).",
        "predicted_sql": "WITH OwnedBuildings AS (\n    SELECT \n        CASE \n            WHEN DATE_BUILT IS NULL THEN 'UNKNOWN' \n            ELSE strftime('%Y', DATE_BUILT) \n        END AS ConstructionStartYear,\n        BUILDING_NUMBER,\n        CASE \n            WHEN DATE_OCCUPIED IS NULL THEN 'UNKNOWN' \n            ELSE strftime('%Y', DATE_OCCUPIED) \n        END AS YearOfInitialOccupancy\n    FROM \n        FAC_BUILDING\n    WHERE \n        OWNERSHIP_TYPE = 'OWNED' \n        AND PARENT_BUILDING_NUMBER IS NULL\n),\nFilteredBuildings AS (\n    SELECT \n        DISTINCT ConstructionStartYear,\n        BUILDING_NUMBER,\n        YearOfInitialOccupancy,\n        ROW_NUMBER() OVER (ORDER BY ConstructionStartYear, BUILDING_NUMBER) AS RowNum\n    FROM \n        OwnedBuildings\n)\nSELECT \n    CASE \n        WHEN ConstructionStartYear != LAG(ConstructionStartYear) OVER (ORDER BY RowNum) THEN ConstructionStartYear \n        ELSE NULL \n    END AS ConstructionStartYear,\n    BUILDING_NUMBER,\n    YearOfInitialOccupancy\nFROM \n    FilteredBuildings\nUNION ALL\nSELECT \n    NULL, \n    COUNT(*) || ' Buildings', \n    NULL \nFROM \n    OwnedBuildings;"
    },
    {
        "db_id": "dw",
        "question": "Group all buildings at MIT into either owned or leased. For each group, state the ownership type, usage type, number of buildings, gross square footage, number of rooms, and the number of associated organizations. Display the ownership type only if it differs from the previous row. Include subtotals for each group and a grand total across all groups. The subtotal and grand total rows should not include ownership type and usage type. Footage should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH BuildingCounts AS (\n    SELECT \n        FCLT_BUILDING_HIST.OWNERSHIP_TYPE,\n        FCLT_BUILDING_HIST.BUILDING_USE,\n        COUNT(DISTINCT FCLT_BUILDING_HIST.FCLT_BUILDING_KEY) AS num_buildings,\n        ROUND(SUM(FCLT_BUILDING_HIST.EXT_GROSS_AREA)) AS gross_sq_ft,\n        COUNT(DISTINCT FCLT_ROOMS.FCLT_ROOM_KEY) AS num_rooms,\n        COUNT(DISTINCT FCLT_ROOMS.FCLT_ORGANIZATION_KEY) AS num_organizations\n    FROM \n        FCLT_BUILDING_HIST\n    LEFT JOIN \n        FCLT_ROOMS ON FCLT_ROOMS.FCLT_BUILDING_KEY = FCLT_BUILDING_HIST.FCLT_BUILDING_KEY\n    WHERE \n        FCLT_BUILDING_HIST.SITE = 'MIT'\n    GROUP BY \n        FCLT_BUILDING_HIST.OWNERSHIP_TYPE, FCLT_BUILDING_HIST.BUILDING_USE\n), Subtotals AS (\n    SELECT \n        OWNERSHIP_TYPE,\n        NULL AS BUILDING_USE,\n        SUM(num_buildings) AS num_buildings,\n        SUM(gross_sq_ft) AS gross_sq_ft,\n        SUM(num_rooms) AS num_rooms,\n        SUM(num_organizations) AS num_organizations\n    FROM \n        BuildingCounts\n    GROUP BY \n        OWNERSHIP_TYPE\n), GrandTotal AS (\n    SELECT \n        NULL AS OWNERSHIP_TYPE,\n        NULL AS BUILDING_USE,\n        SUM(num_buildings) AS num_buildings,\n        SUM(gross_sq_ft) AS gross_sq_ft,\n        SUM(num_rooms) AS num_rooms,\n        SUM(num_organizations) AS num_organizations\n    FROM \n        BuildingCounts\n)\nSELECT \n    b.OWNERSHIP_TYPE,\n    b.BUILDING_USE,\n    b.num_buildings,\n    printf('%,.0f', b.gross_sq_ft) AS gross_sq_ft,\n    b.num_rooms,\n    b.num_organizations\nFROM \n    BuildingCounts b\nUNION ALL\nSELECT \n    s.OWNERSHIP_TYPE,\n    s.BUILDING_USE,\n    s.num_buildings,\n    printf('%,.0f', s.gross_sq_ft) AS gross_sq_ft,\n    s.num_rooms,\n    s.num_organizations\nFROM \n    Subtotals s\nUNION ALL\nSELECT \n    g.OWNERSHIP_TYPE,\n    g.BUILDING_USE,\n    g.num_buildings,\n    printf('%,.0f', g.gross_sq_ft) AS gross_sq_ft,\n    g.num_rooms,\n    g.num_organizations\nFROM \n    GrandTotal g\nORDER BY \n    OWNERSHIP_TYPE, BUILDING_USE;"
    },
    {
        "db_id": "dw",
        "question": "For each building use, list the type, the number of distinct buildings (excluding subdivisions) of this use, the total gross square footage of these buildings, and the number of unique organizations associated with the rooms in these buildings. If the building is used as a residence, display the usage type as \"RESIDENTIAL.\" You should also include a row at the end showing the total number of buildings, the gross square footage, and the number of organizations across all types of building use. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH BuildingStats AS (\n    SELECT \n        CASE \n            WHEN B.BUILDING_USE = 'RESIDENT' THEN 'RESIDENTIAL'\n            ELSE B.BUILDING_USE \n        END AS USAGE_TYPE,\n        COUNT(DISTINCT B.FCLT_BUILDING_KEY) AS DISTINCT_BUILDINGS,\n        SUM(B.EXT_GROSS_AREA) AS TOTAL_GROSS_SQ_FOOTAGE,\n        COUNT(DISTINCT R.FCLT_ORGANIZATION_KEY) AS UNIQUE_ORGANIZATIONS\n    FROM \n        FCLT_BUILDING B\n    LEFT JOIN \n        FCLT_ROOMS R ON B.FCLT_BUILDING_KEY = R.FCLT_BUILDING_KEY\n    WHERE \n        B.PARENT_BUILDING_NUMBER IS NULL\n    GROUP BY \n        USAGE_TYPE\n),\nTotalStats AS (\n    SELECT \n        COUNT(DISTINCT FCLT_BUILDING_KEY) AS TOTAL_BUILDINGS,\n        SUM(EXT_GROSS_AREA) AS TOTAL_GROSS_SQ_FOOTAGE,\n        COUNT(DISTINCT FCLT_ORGANIZATION_KEY) AS TOTAL_ORGANIZATIONS\n    FROM \n        FCLT_BUILDING B\n    LEFT JOIN \n        FCLT_ROOMS R ON B.FCLT_BUILDING_KEY = R.FCLT_BUILDING_KEY\n    WHERE \n        B.PARENT_BUILDING_NUMBER IS NULL\n)\nSELECT \n    USAGE_TYPE, \n    DISTINCT_BUILDINGS, \n    ROUND(TOTAL_GROSS_SQ_FOOTAGE) AS TOTAL_GROSS_SQ_FOOTAGE, \n    UNIQUE_ORGANIZATIONS \nFROM \n    BuildingStats\nUNION ALL\nSELECT \n    'Total' AS USAGE_TYPE, \n    TOTAL_BUILDINGS, \n    ROUND(TOTAL_GROSS_SQ_FOOTAGE) AS TOTAL_GROSS_SQ_FOOTAGE, \n    TOTAL_ORGANIZATIONS \nFROM \n    TotalStats;"
    },
    {
        "db_id": "dw",
        "question": "For each organization except Cambridge-MIT Institute, list its ID, number, level, formatted name according to level (if level is 2, there should be 1 space before the name, if level is 3, there should be 2 space before the name, up to level 6), whether it is assignable ('ASSIGNABLE' if assignable, 'NON-ASSIGNABLE' otherwise), total area, number of rooms, and average room area. Area and number of rooms should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    fo.ORGANIZATION_ID,\n    fo.ORGANIZATION_NUMBER,\n    fo.ORGANIZATION_LEVEL,\n    CASE \n        WHEN fo.ORGANIZATION_LEVEL = '2' THEN ' ' || fo.ORGANIZATION_NAME\n        WHEN fo.ORGANIZATION_LEVEL = '3' THEN '  ' || fo.ORGANIZATION_NAME\n        WHEN fo.ORGANIZATION_LEVEL = '4' THEN '   ' || fo.ORGANIZATION_NAME\n        WHEN fo.ORGANIZATION_LEVEL = '5' THEN '    ' || fo.ORGANIZATION_NAME\n        WHEN fo.ORGANIZATION_LEVEL = '6' THEN '     ' || fo.ORGANIZATION_NAME\n        ELSE fo.ORGANIZATION_NAME\n    END AS formatted_name,\n    CASE \n        WHEN fo.ASSIGNABLE = '1' THEN 'ASSIGNABLE' \n        ELSE 'NON-ASSIGNABLE' \n    END AS assignable,\n    REPLACE(ROUND(SUM(fr.AREA)), ',', '') AS total_area,\n    COUNT(DISTINCT fr.ROOM) AS number_of_rooms,\n    ROUND(AVG(fr.AREA)) AS average_room_area\nFROM \n    FCLT_ORGANIZATION fo\nJOIN \n    FCLT_ROOMS fr ON fo.FCLT_ORGANIZATION_KEY = fr.FCLT_ORGANIZATION_KEY\nWHERE \n    fo.ORGANIZATION_NAME != 'Cambridge-MIT Institute'\nGROUP BY \n    fo.ORGANIZATION_ID, fo.ORGANIZATION_NUMBER, fo.ORGANIZATION_LEVEL, formatted_name, fo.ASSIGNABLE\nORDER BY \n    fo.ORGANIZATION_ID;"
    },
    {
        "db_id": "dw",
        "question": "Group all rooms into whether or not they are assignable and the major use descriptions. For each group, state \"ASSIGNABLE\" if the room is assignable and \"NON-ASSIGNABLE\" otherwise, the major use description, the total number of rooms, total area, and average area. Include subtotals for each group and a grand total across all groups. The assignable status and major use descriptions should only be displayed when they differ from the previous row. Do not include rooms whose major use or major use description starts with 'ZUSE.' The results should be sorted by assignable status and major use description. The subtotal and grand total rows should not include assignable status or major use description.",
        "predicted_sql": "WITH RoomStats AS (\n    SELECT \n        CASE WHEN FR.ASSIGNABLE = '1' THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END AS ASSIGNABLE_STATUS,\n        FMU.DESCRIPTION AS MAJOR_USE_DESCRIPTION,\n        COUNT(FR.ROOM) AS TOTAL_ROOMS,\n        SUM(FR.AREA) AS TOTAL_AREA,\n        AVG(FR.AREA) AS AVG_AREA\n    FROM \n        FCLT_ROOMS FR\n    JOIN \n        FCLT_MAJOR_USE FMU ON FR.FCLT_MAJOR_USE_KEY = FMU.FCLT_MAJOR_USE_KEY\n    WHERE \n        FMU.MAJOR_USE_DESC NOT LIKE 'ZUSE%'\n    GROUP BY \n        FMU.DESCRIPTION, FR.ASSIGNABLE\n),\n\nSubtotals AS (\n    SELECT \n        NULL AS ASSIGNABLE_STATUS,\n        NULL AS MAJOR_USE_DESCRIPTION,\n        SUM(TOTAL_ROOMS) AS TOTAL_ROOMS,\n        SUM(TOTAL_AREA) AS TOTAL_AREA,\n        AVG(AVG_AREA) AS AVG_AREA\n    FROM \n        RoomStats\n    GROUP BY \n        ASSIGNABLE_STATUS\n)\n\nSELECT \n    ASSIGNABLE_STATUS,\n    MAJOR_USE_DESCRIPTION,\n    TOTAL_ROOMS,\n    TOTAL_AREA,\n    AVG_AREA\nFROM \n    RoomStats\n\nUNION ALL\n\nSELECT \n    ASSIGNABLE_STATUS,\n    NULL AS MAJOR_USE_DESCRIPTION,\n    TOTAL_ROOMS,\n    TOTAL_AREA,\n    AVG_AREA\nFROM \n    Subtotals\n\nORDER BY \n    ASSIGNABLE_STATUS, MAJOR_USE_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "List each floor key and department name within the Stata building, as well as the number of rooms, total area, and average area per department on each floor. Include subtotals for each floor and a grand total across all floors. Sort the results by floor key and department name in ascending order. Exclude departments without any rooms in the building. Only the first row of each floor group should include the floor key, and the subtotal and grand total rows should not include floor key or department name. Number of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH RoomData AS (\n    SELECT \n        f.FLOOR_KEY,\n        org.ORGANIZATION_NAME,\n        COUNT(r.FAC_ROOM_KEY) AS NumberOfRooms,\n        ROUND(SUM(r.AREA)) AS TotalArea,\n        ROUND(AVG(r.AREA)) AS AvgAreaPerDepartment\n    FROM FAC_ROOMS r\n    JOIN FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY AND r.BUILDING_KEY = f.BUILDING_KEY\n    JOIN FCLT_ORGANIZATION org ON r.ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY\n    JOIN BUILDINGS b ON r.BUILDING_KEY = b.BUILDING_KEY\n    WHERE b.BUILDING_NAME = 'Stata Building'\n    GROUP BY f.FLOOR_KEY, org.ORGANIZATION_NAME\n),\nFloorSubtotals AS (\n    SELECT \n        FLOOR_KEY, \n        NULL AS ORGANIZATION_NAME, \n        SUM(NumberOfRooms) AS NumberOfRooms, \n        SUM(TotalArea) AS TotalArea, \n        ROUND(AVG(AvgAreaPerDepartment)) AS AvgAreaPerDepartment\n    FROM RoomData\n    GROUP BY FLOOR_KEY\n),\nGrandTotal AS (\n    SELECT \n        NULL AS FLOOR_KEY,\n        NULL AS ORGANIZATION_NAME,\n        SUM(NumberOfRooms) AS NumberOfRooms,\n        SUM(TotalArea) AS TotalArea,\n        ROUND(AVG(AvgAreaPerDepartment)) AS AvgAreaPerDepartment\n    FROM RoomData\n)\nSELECT \n    FLOOR_KEY,\n    ORGANIZATION_NAME,\n    NumberOfRooms,\n    FORMAT(NumberOfRooms, 'N0') AS FormattedNumberOfRooms,\n    FORMAT(TotalArea, 'N0') AS FormattedTotalArea,\n    FORMAT(AvgAreaPerDepartment, 'N0') AS FormattedAvgAreaPerDepartment\nFROM RoomData\nUNION ALL\nSELECT \n    FLOOR_KEY,\n    ORGANIZATION_NAME,\n    NumberOfRooms,\n    NULL AS FormattedNumberOfRooms,\n    NULL AS FormattedTotalArea,\n    NULL AS FormattedAvgAreaPerDepartment\nFROM FloorSubtotals\nUNION ALL\nSELECT \n    NULL AS FLOOR_KEY,\n    NULL AS ORGANIZATION_NAME,\n    NumberOfRooms,\n    NULL AS FormattedNumberOfRooms,\n    NULL AS FormattedTotalArea,\n    NULL AS FormattedAvgAreaPerDepartment\nFROM GrandTotal\nORDER BY FLOOR_KEY, ORGANIZATION_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List each building key and floor key within the department of facilities, the number of rooms, total area, average area per floor, building name, access level, zip code, and city. Include subtotals for each building and a grand total across all buildings. The subtotals and grand total should not include zip code or city. Numbers of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH RoomStats AS (\n    SELECT \n        fr.BUILDING_KEY,\n        fr.FLOOR_KEY,\n        COUNT(fr.FAC_ROOM_KEY) AS num_of_rooms,\n        ROUND(SUM(fr.AREA)) AS total_area\n    FROM \n        FAC_ROOMS fr\n    JOIN \n        FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY\n    WHERE \n        fo.ORGANIZATION_NAME = 'FACILITIES'\n    GROUP BY \n        fr.BUILDING_KEY, \n        fr.FLOOR_KEY\n),\nBuildingInfo AS (\n    SELECT \n        fb.BUILDING_KEY,\n        fb.BUILDING_NAME_LONG,\n        fb.ACCESS_LEVEL_NAME,\n        fa.POSTAL_CODE,\n        fa.CITY\n    FROM \n        FAC_BUILDING fb\n    JOIN \n        FAC_BUILDING_ADDRESS fa ON fb.FAC_BUILDING_KEY = fa.BUILDING_KEY\n)\nSELECT \n    bi.BUILDING_KEY,\n    rs.FLOOR_KEY,\n    FORMAT(rs.num_of_rooms, 'N0') AS num_of_rooms,\n    FORMAT(rs.total_area, 'N0') AS total_area,\n    ROUND(rs.total_area / COUNT(DISTINCT rs.FLOOR_KEY)) AS avg_area_per_floor,\n    bi.BUILDING_NAME_LONG,\n    bi.ACCESS_LEVEL_NAME,\n    bi.POSTAL_CODE,\n    bi.CITY\nFROM \n    RoomStats rs\nJOIN \n    BuildingInfo bi ON rs.BUILDING_KEY = bi.BUILDING_KEY\nGROUP BY \n    bi.BUILDING_KEY, \n    rs.FLOOR_KEY, \n    rs.num_of_rooms, \n    rs.total_area,\n    bi.BUILDING_NAME_LONG,\n    bi.ACCESS_LEVEL_NAME,\n    bi.POSTAL_CODE,\n    bi.CITY\nWITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "List the department, school, course number, subject title, total number of enrolled students, term code, and count of distinct catalog ISBNs. Add a summary row at the bottom showing the total number of students and distinct catalog ISBNs for the current term in the format of ('TOTAL:', null, null, null, total number of students, null, number of distinct catalog ISBNs).",
        "predicted_sql": "SELECT \n    so.OFFER_DEPT_NAME AS department,\n    so.OFFER_SCHOOL_NAME AS school,\n    so.COURSE_NUMBER AS course_number,\n    so.SUBJECT_TITLE AS subject_title,\n    SUM(so.NUM_ENROLLED_STUDENTS) AS total_enrolled_students,\n    so.TERM_CODE AS term_code,\n    COUNT(DISTINCT rc.CATALOG_ISBN) AS distinct_catalog_isbns\nFROM \n    LIBRARY_SUBJECT_OFFERED so\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL md ON so.LIBRARY_SUBJECT_OFFERED_KEY = md.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG rc ON md.LIBRARY_RESERVE_CATALOG_KEY = rc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    ACADEMIC_TERM_PARAMETER tp ON so.TERM_CODE = tp.TERM_CODE\nWHERE \n    tp.IS_CURRENT_TERM = 'Y'\nGROUP BY \n    so.OFFER_DEPT_NAME, so.OFFER_SCHOOL_NAME, so.COURSE_NUMBER, so.SUBJECT_TITLE, so.TERM_CODE\nUNION ALL\nSELECT \n    'TOTAL:' AS department, \n    NULL AS school, \n    NULL AS course_number, \n    NULL AS subject_title, \n    SUM(so.NUM_ENROLLED_STUDENTS) AS total_enrolled_students, \n    NULL AS term_code, \n    COUNT(DISTINCT rc.CATALOG_ISBN) AS distinct_catalog_isbns\nFROM \n    LIBRARY_SUBJECT_OFFERED so\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL md ON so.LIBRARY_SUBJECT_OFFERED_KEY = md.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG rc ON md.LIBRARY_RESERVE_CATALOG_KEY = rc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    ACADEMIC_TERM_PARAMETER tp ON so.TERM_CODE = tp.TERM_CODE\nWHERE \n    tp.IS_CURRENT_TERM = 'Y';"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list that involves subscribers that work in departments with names starting with 'Computer Science', state the ownership type, the list name, the number of owners, and the number of subscribers. Display the ownership type only if it differs from the previous entry. Include subtotals (the corresponding type field shoud be 'SUBTOTAL') for each ownership type and a grand total (the corresponding type field shoud be 'TOTAL') across all ownership types.",
        "predicted_sql": "WITH DeptSubscribers AS (\n    SELECT \n        OWNER_TYPE,\n        MOIRA_LIST.MOIRA_LIST_NAME,\n        COUNT(DISTINCT MOIRA_LIST_OWNER.OWNER) AS number_of_owners,\n        COUNT(DISTINCT MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER_MIT_ID) AS number_of_subscribers\n    FROM \n        MOIRA_LIST\n    JOIN \n        MOIRA_LIST_OWNER ON MOIRA_LIST.MOIRA_LIST_KEY = MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY\n    JOIN \n        MOIRA_LIST_DETAIL ON MOIRA_LIST.MOIRA_LIST_KEY = MOIRA_LIST_DETAIL.MOIRA_LIST_KEY\n    JOIN \n        EMPLOYEE_DIRECTORY ON EMPLOYEE_DIRECTORY.MIT_ID = MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER_MIT_ID\n    WHERE \n        EMPLOYEE_DIRECTORY.DEPARTMENT_NAME LIKE 'Computer Science%'\n    GROUP BY \n        OWNER_TYPE, MOIRA_LIST.MOIRA_LIST_NAME\n),\nOwnerTypeSubtotals AS (\n    SELECT \n        OWNER_TYPE,\n        NULL AS MOIRA_LIST_NAME,\n        COUNT(DISTINCT OWNER_TYPE) AS number_of_owners,\n        SUM(number_of_subscribers) AS number_of_subscribers\n    FROM \n        DeptSubscribers\n    GROUP BY \n        OWNER_TYPE\n),\nGrandTotal AS (\n    SELECT \n        'TOTAL' AS OWNER_TYPE,\n        NULL AS MOIRA_LIST_NAME,\n        COUNT(*) AS number_of_owners,\n        SUM(number_of_subscribers) AS number_of_subscribers\n    FROM \n        DeptSubscribers\n)\nSELECT \n    OWNER_TYPE, \n    MOIRA_LIST_NAME, \n    number_of_owners, \n    number_of_subscribers \nFROM \n    DeptSubscribers\n\nUNION ALL\n\nSELECT \n    OWNER_TYPE, \n    MOIRA_LIST_NAME, \n    number_of_owners, \n    number_of_subscribers \nFROM \n    OwnerTypeSubtotals\n\nUNION ALL\n\nSELECT \n    OWNER_TYPE, \n    MOIRA_LIST_NAME, \n    number_of_owners, \n    number_of_subscribers \nFROM \n    GrandTotal\n\nORDER BY \n    OWNER_TYPE, MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list its name, number of unique sessions, total number of attendees, active period (in the format of 'beginning term code-end term code'), the most common sponsor name, and the most common session start time. Include a grand total row showing the total number of sessions and attendees across all categories in the format of ('TOTAL', number of sessions, number of attendees, null, null, null).",
        "predicted_sql": "SELECT \n    c.IAP_CATEGORY_NAME AS name,\n    COUNT(DISTINCT s.IAP_SUBJECT_SESSION_KEY) AS num_unique_sessions,\n    SUM(d.MAX_ENROLLMENT) AS total_attendees,\n    MIN(d.TERM_CODE) || '-' || MAX(d.TERM_CODE) AS active_period,\n    (SELECT SPONSOR_NAME \n     FROM IAP_SUBJECT_SPONSOR sp \n     JOIN IAP_SUBJECT_DETAIL d2 ON sp.IAP_SUBJECT_SPONSOR_KEY = d2.IAP_SUBJECT_SPONSOR_KEY \n     WHERE d2.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY \n     GROUP BY SPONSOR_NAME \n     ORDER BY COUNT(*) DESC \n     LIMIT 1) AS most_common_sponsor_name,\n    (SELECT SESSION_START_TIME \n     FROM IAP_SUBJECT_SESSION s2 \n     JOIN IAP_SUBJECT_DETAIL d2 ON s2.IAP_SUBJECT_SESSION_KEY = d2.IAP_SUBJECT_SESSION_KEY \n     WHERE d2.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY \n     GROUP BY SESSION_START_TIME \n     ORDER BY COUNT(*) DESC \n     LIMIT 1) AS most_common_session_start_time\nFROM \n    IAP_SUBJECT_CATEGORY c\nJOIN \n    IAP_SUBJECT_DETAIL d ON c.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    c.IAP_CATEGORY_NAME\n\nUNION ALL\n\nSELECT \n    'TOTAL',\n    COUNT(DISTINCT s.IAP_SUBJECT_SESSION_KEY) AS num_unique_sessions,\n    SUM(d.MAX_ENROLLMENT) AS total_attendees,\n    NULL AS active_period,\n    NULL AS most_common_sponsor_name,\n    NULL AS most_common_session_start_time\nFROM \n    IAP_SUBJECT_DETAIL d\nJOIN \n    IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "For each building type, list the name of the building type, the number of buildings that are not subdivisions, number of employees, number of unique building street address, number of unique city, number of unique state, number of unique postal code, and average gross square footage per employee. For building type of 'resident', display it as 'RESIDENTIAL'. Include a grand total across all building types (the corresponding type field is 'TOTAL').",
        "predicted_sql": "WITH BuildingCounts AS (\n    SELECT\n        CASE \n            WHEN FCLT.BUILDING_TYPE = 'resident' THEN 'RESIDENTIAL'\n            ELSE FCLT.BUILDING_TYPE \n        END AS Building_Type,\n        COUNT(DISTINCT FCLT.FCLT_BUILDING_KEY) AS Total_Buildings,\n        COUNT(DISTINCT EMP.MIT_ID) AS Total_Employees,\n        COUNT(DISTINCT B.BUILDING_STREET_ADDRESS) AS Unique_Street_Addresses,\n        COUNT(DISTINCT A.CITY) AS Unique_Cities,\n        COUNT(DISTINCT A.STATE) AS Unique_States,\n        COUNT(DISTINCT A.POSTAL_CODE) AS Unique_Postal_Codes,\n        AVG(FCLT.EXT_GROSS_AREA) AS Avg_Gross_Square_Footage_Per_Employee\n    FROM \n        FCLT_BUILDING_HIST FCLT\n    LEFT JOIN \n        FAC_BUILDING_ADDRESS A ON FCLT.FCLT_BUILDING_KEY = A.BUILDING_KEY\n    LEFT JOIN \n        BUILDINGS B ON A.BUILDING_KEY = B.BUILDING_KEY\n    LEFT JOIN \n        FAC_ROOMS R ON B.BUILDING_KEY = R.BUILDING_KEY\n    LEFT JOIN \n        EMPLOYEE_DIRECTORY EMP ON R.FAC_ROOM_KEY = EMP.OFFICE_LOCATION\n    WHERE \n        FCLT.PARENT_BUILDING_NUMBER IS NULL\n    GROUP BY \n        Building_Type\n),\nGrandTotal AS (\n    SELECT\n        'TOTAL' AS Building_Type,\n        SUM(Total_Buildings) AS Total_Buildings,\n        SUM(Total_Employees) AS Total_Employees,\n        SUM(Unique_Street_Addresses) AS Unique_Street_Addresses,\n        SUM(Unique_Cities) AS Unique_Cities,\n        SUM(Unique_States) AS Unique_States,\n        SUM(Unique_Postal_Codes) AS Unique_Postal_Codes,\n        AVG(NULLIF(Avg_Gross_Square_Footage_Per_Employee, 0)) AS Avg_Gross_Square_Footage_Per_Employee\n    FROM \n        BuildingCounts\n)\nSELECT * FROM BuildingCounts\nUNION ALL\nSELECT * FROM GrandTotal;"
    },
    {
        "db_id": "dw",
        "question": "Group spaces in the Stata building by the access level and usage type. For each group, state the access level, usage type, name of the space, the number of spaces, total area across all rooms in the space, and average area across all rooms in the space. Display the access level only if it differs from the previous entry. Include subtotals for each access level, usage type, and space name, subtotals for each access level, and a grand total across all access levels. Exclude usage type that includes \"STORAGE\". All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH SpaceDetails AS (\n    SELECT \n        Z.BUILDING_ROOM,\n        Z.BUILDING_COMPONENT,\n        Z.FLOOR,\n        U.SPACE_USAGE,\n        O.DLC_NAME,\n        U.SPACE_UNIT AS SPACE_NAME,\n        D.ROOM_SQUARE_FOOTAGE\n    FROM \n        ZPM_ROOMS_LOAD Z\n    JOIN \n        SPACE_UNIT U ON Z.SPACE_UNIT_CODE = U.SPACE_UNIT_CODE\n    JOIN \n        SPACE_DETAIL D ON U.SPACE_UNIT_KEY = D.SPACE_UNIT_KEY\n    JOIN \n        SPACE_USAGE S ON S.SPACE_USAGE_KEY = D.SPACE_USAGE_KEY\n    JOIN \n        FCLT_ORGANIZATION O ON O.ORGANIZATION_ID = U.FCLT_ORGANIZATION_KEY\n    WHERE \n        Z.BUILDING_COMPONENT = '1' AND \n        S.SPACE_USAGE NOT LIKE '%STORAGE%'\n),\nAggregatedData AS (\n    SELECT \n        Z.ACCESS_LEVEL,\n        SD.SPACE_USAGE,\n        SD.SPACE_NAME,\n        COUNT(*) AS NumberOfSpaces,\n        SUM(SD.ROOM_SQUARE_FOOTAGE) AS TotalArea,\n        AVG(SD.ROOM_SQUARE_FOOTAGE) AS AvgArea\n    FROM \n        SpaceDetails SD\n    JOIN \n        ZPM_ROOMS_LOAD Z ON SD.BUILDING_ROOM = Z.BUILDING_ROOM\n    GROUP BY \n        Z.ACCESS_LEVEL, SD.SPACE_USAGE, SD.SPACE_NAME\n)\nSELECT \n    CASE \n        WHEN ACCESS_LEVEL <> LAG(ACCESS_LEVEL) OVER (ORDER BY ACCESS_LEVEL, SPACE_USAGE, SPACE_NAME) THEN ACCESS_LEVEL\n        ELSE NULL\n    END AS ACCESS_LEVEL,\n    SPACE_USAGE,\n    SPACE_NAME,\n    NumberOfSpaces,\n    totalArea AS TotalArea,\n    ROUND(totalArea) AS RoundedTotalArea,\n    ROUND(AvgArea) AS RoundedAvgArea\nFROM \n    AggregatedData\nORDER BY \n    ACCESS_LEVEL, SPACE_USAGE, SPACE_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List each organization's break group, ID, name, and formatted name according to its level, along with whether its members are emeritus or non-emeritus. Also, include the organization number, level, employer count, and hierarchy type for each organization. Exclude organizations '139' and '250'. Sort the results by hierarchy type and ensure totals for employer counts are displayed.",
        "predicted_sql": "SELECT \n    FCLT_ORGANIZATION.ORGANIZATION_SORT AS break_group,\n    FCLT_ORGANIZATION.ORGANIZATION_ID AS ID,\n    FCLT_ORGANIZATION.ORGANIZATION_NAME AS name,\n    FCLT_ORGANIZATION.ORGANIZATION_LEVEL AS level,\n    FCLT_ORGANIZATION.ORGANIZATION_NUMBER AS number,\n    COUNT(DISTINCT HR_FACULTY_ROSTER.MIT_ID) AS employer_count,\n    MASTER_DEPT_HIERARCHY.HIERARCHY_TYPE\nFROM \n    FCLT_ORGANIZATION\nJOIN \n    MASTER_DEPT_HIERARCHY ON FCLT_ORGANIZATION.DLC_KEY = MASTER_DEPT_HIERARCHY.DLC_KEY\nJOIN \n    HR_ORG_UNIT ON FCLT_ORGANIZATION.DLC_KEY = HR_ORG_UNIT.DLC_KEY\nJOIN \n    HR_FACULTY_ROSTER ON HR_ORG_UNIT.HR_ORG_UNIT_TITLE = HR_FACULTY_ROSTER.HR_ORG_UNIT_TITLE\nWHERE \n    FCLT_ORGANIZATION.ORGANIZATION_ID NOT IN ('139', '250')\nGROUP BY \n    FCLT_ORGANIZATION.ORGANIZATION_SORT,\n    FCLT_ORGANIZATION.ORGANIZATION_ID,\n    FCLT_ORGANIZATION.ORGANIZATION_NAME,\n    FCLT_ORGANIZATION.ORGANIZATION_LEVEL,\n    FCLT_ORGANIZATION.ORGANIZATION_NUMBER,\n    MASTER_DEPT_HIERARCHY.HIERARCHY_TYPE\nORDER BY \n    MASTER_DEPT_HIERARCHY.HIERARCHY_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its title, name of the building of the course location, duration (in terms of days), and a running average of the duration (in terms of days) using a window of two preceding and two following courses (partitioned by academic year and sorted by course start date).",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE AS title,\n    b.BUILDING_NAME AS building_name,\n    (julianday(t.TERM_END_DATE) - julianday(t.TERM_START_DATE)) AS duration,\n    AVG(julianday(t2.TERM_END_DATE) - julianday(t2.TERM_START_DATE)) OVER (PARTITION BY c.ACADEMIC_YEAR ORDER BY t.TERM_START_DATE ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS running_average_duration\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS t ON c.EFFECTIVE_TERM_CODE = t.TERM_CODE\nJOIN \n    FCLT_ROOMS r ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nJOIN \n    FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nORDER BY \n    t.TERM_START_DATE;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, the start date, the name of the course before it, and the name of the course after it, access level of the building, and the assignable area of the room used for the course, sorted by the ascending order start date and course name.",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE AS course_name,\n    b.BUILDING_NAME_LONG AS building_name,\n    t.TERM_START_DATE AS start_date,\n    LAG(c.SUBJECT_TITLE) OVER (ORDER BY t.TERM_START_DATE, c.SUBJECT_TITLE) AS previous_course,\n    LEAD(c.SUBJECT_TITLE) OVER (ORDER BY t.TERM_START_DATE, c.SUBJECT_TITLE) AS next_course,\n    b.ACCESS_LEVEL_NAME AS access_level,\n    r.AREA AS assignable_area\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS t ON c.TERM_CODE = t.TERM_CODE\nJOIN \n    FCLT_ROOMS r ON r.BUILDING_ROOM = c.SUBJECT_CODE\nJOIN \n    FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nORDER BY \n    t.TERM_START_DATE ASC, c.SUBJECT_TITLE ASC;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, and the cumulative number of courses, including the course itself, held in the same year or preceding years (partitioned by academic year and sorted in the ascending order of course start date).",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE AS course_name, \n    b.BUILDING_NAME AS building_name, \n    COUNT(*) OVER (PARTITION BY c.ACADEMIC_YEAR ORDER BY t.TERM_START_DATE) AS cumulative_courses\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS t ON c.EFFECTIVE_TERM_CODE = t.TERM_CODE\nJOIN \n    FCLT_ROOMS r ON c.MEET_PLACE = r.FCLT_ROOM_KEY\nJOIN \n    FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nORDER BY \n    t.TERM_START_DATE;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the cluster type. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), cluster type, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and cluster type.",
        "predicted_sql": "WITH CourseDurations AS (\n    SELECT \n        s.CLUSTER_TYPE,\n        a.IS_CURRENT_TERM,\n        MAX(julianday(a.TERM_END_DATE) - julianday(a.TERM_START_DATE)) AS max_duration,\n        AVG(julianday(a.TERM_END_DATE) - julianday(a.TERM_START_DATE)) AS avg_duration,\n        MAX(s.TOTAL_UNITS) AS max_units,\n        AVG(s.TOTAL_UNITS) AS avg_units\n    FROM \n        SUBJECT_SUMMARY s\n    JOIN \n        ACADEMIC_TERMS_ALL a ON s.TERM_CODE = a.TERM_CODE\n    WHERE \n        a.IS_CURRENT_TERM IN ('Y', 'N') AND \n        (s.DEPARTMENT_NAME = 'Biology' OR s.DEPARTMENT_NAME = 'Chemistry')\n    GROUP BY \n        s.CLUSTER_TYPE, a.IS_CURRENT_TERM\n), \nSubtotals AS (\n    SELECT \n        CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END AS current_status,\n        CLUSTER_TYPE,\n        MAX(max_duration) AS max_duration,\n        MAX(max_units) AS max_units,\n        AVG(avg_duration) AS avg_duration,\n        AVG(avg_units) AS avg_units\n    FROM \n        CourseDurations\n    GROUP BY \n        current_status, CLUSTER_TYPE\n), \nGrandTotal AS (\n    SELECT \n        'TOTAL' AS current_status,\n        NULL AS CLUSTER_TYPE,\n        SUM(max_duration) AS max_duration,\n        SUM(max_units) AS max_units,\n        AVG(avg_duration) AS avg_duration,\n        AVG(avg_units) AS avg_units\n    FROM \n        Subtotals\n)\nSELECT * FROM Subtotals\nUNION ALL\nSELECT * FROM GrandTotal\nORDER BY current_status, CLUSTER_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the department name. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), department name, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and department.",
        "predicted_sql": "WITH CourseDurations AS (\n    SELECT \n        A.IS_CURRENT_TERM,\n        S.DEPARTMENT_NAME,\n        JULIANDAY(A.TERM_END_DATE) - JULIANDAY(A.TERM_START_DATE) AS DURATION,\n        S.TOTAL_UNITS\n    FROM \n        ACADEMIC_TERMS_ALL A\n    JOIN \n        SUBJECT_SUMMARY S ON A.TERM_CODE = S.TERM_CODE\n    JOIN \n        SUBJECT_OFFERED O ON S.SUBJECT_ID = O.SUBJECT_ID\n    WHERE \n        O.OFFER_DEPT_NAME IN ('Biology', 'Chemistry')\n),\nAggregatedData AS (\n    SELECT \n        ISNULL(IS_CURRENT_TERM, 'SUBTOTAL') AS STATUS,\n        DEPARTMENT_NAME,\n        MAX(DURATION) AS MAX_DURATION,\n        MAX(TOTAL_UNITS) AS MAX_UNITS,\n        AVG(DURATION) AS AVG_DURATION,\n        AVG(TOTAL_UNITS) AS AVG_UNITS\n    FROM \n        CourseDurations\n    GROUP BY \n        IS_CURRENT_TERM, DEPARTMENT_NAME\n)\n\nSELECT \n    CASE \n        WHEN STATUS IS NULL THEN 'SUBTOTAL'\n        ELSE STATUS \n    END AS CURRENT_STATUS,\n    DEPARTMENT_NAME,\n    MAX_DURATION,\n    MAX_UNITS,\n    AVG_DURATION,\n    AVG_UNITS\nFROM \n    AggregatedData\n\nUNION ALL\n\nSELECT \n    'TOTAL' AS CURRENT_STATUS,\n    DEPARTMENT_NAME,\n    SUM(MAX_DURATION) AS MAX_DURATION,\n    SUM(MAX_UNITS) AS MAX_UNITS,\n    AVG(AVG_DURATION) AS AVG_DURATION,\n    AVG(AVG_UNITS) AS AVG_UNITS\nFROM \n    AggregatedData\nGROUP BY \n    DEPARTMENT_NAME\n\nORDER BY \n    CURRENT_STATUS, DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Group master courses by department. For each group, state the name of the department, the master course code, the number of subjects, the total new shelf price of associated TIP materials, and the number of unique TIP materials. Display the department and master course only if it differs from the previous entry. Include subtotals for each department and a grand total across all departments. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH MaterialTotals AS (\n    SELECT \n        so.OFFER_DEPT_NAME,\n        so.MASTER_COURSE_NUMBER,\n        COUNT(DISTINCT so.SUBJECT_ID) AS num_subjects,\n        SUM(COALESCE(tm.NEW_SHELF_PRICE, 0)) AS total_new_shelf_price,\n        COUNT(DISTINCT tm.ISBN) AS unique_materials\n    FROM \n        TIP_SUBJECT_OFFERED so\n    LEFT JOIN \n        TIP_DETAIL td ON so.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\n    LEFT JOIN \n        TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\n    GROUP BY \n        so.OFFER_DEPT_NAME, so.MASTER_COURSE_NUMBER\n),\nDepartmentTotals AS (\n    SELECT \n        OFFER_DEPT_NAME,\n        SUM(num_subjects) AS total_subjects,\n        SUM(total_new_shelf_price) AS total_new_shelf_price,\n        SUM(unique_materials) AS total_unique_materials\n    FROM \n        MaterialTotals\n    GROUP BY \n        OFFER_DEPT_NAME\n)\nSELECT \n    DISTINCT mt.OFFER_DEPT_NAME,\n    mt.MASTER_COURSE_NUMBER,\n    mt.num_subjects,\n    CAST(mt.total_new_shelf_price AS INTEGER) AS total_new_shelf_price,\n    mt.unique_materials\nFROM \n    MaterialTotals mt\nJOIN \n    DepartmentTotals dt ON mt.OFFER_DEPT_NAME = dt.OFFER_DEPT_NAME\nORDER BY \n    mt.OFFER_DEPT_NAME, mt.MASTER_COURSE_NUMBER;\n\nSELECT \n    NULL AS OFFER_DEPT_NAME,\n    NULL AS MASTER_COURSE_NUMBER,\n    dt.total_subjects AS total_subjects,\n    CAST(dt.total_new_shelf_price AS INTEGER) AS total_new_shelf_price,\n    dt.total_unique_materials AS total_unique_materials\nFROM \n    DepartmentTotals dt;\n\nSELECT \n    'Grand Total' AS OFFER_DEPT_NAME,\n    NULL AS MASTER_COURSE_NUMBER,\n    COUNT(DISTINCT mt.SUBJECT_ID) AS grand_total_subjects,\n    CAST(SUM(mt.total_new_shelf_price) AS INTEGER) AS grand_total_new_shelf_price,\n    COUNT(DISTINCT mt.ISBN) AS grand_total_unique_materials\nFROM \n    MaterialTotals mt;"
    },
    {
        "db_id": "dw",
        "question": "For each term and department, list the term, department, the number of courses, average number of equivalent subjects, the school name, and department phone number. Include subtotals for each term (the corresponding term field is 'SUBTOTAL') and a grand total across all terms (the corresponding term field is 'TOTAL'). Do not repeat the term if it is the same as the previous row. Sort the table by term and department.",
        "predicted_sql": "WITH CourseStats AS (\n    SELECT \n        C.TERM_CODE,\n        C.DEPARTMENT_NAME,\n        COUNT(DISTINCT C.SUBJECT_ID) AS course_count,\n        AVG(CASE WHEN C.EQUIVALENT_SUBJECTS IS NOT NULL THEN 1 ELSE 0 END) AS avg_equivalent_subjects,\n        D.SCHOOL_NAME,\n        A.DEPARTMENT_PHONE_NUMBER\n    FROM \n        COURSE_CATALOG_SUBJECT_OFFERED C\n    JOIN \n        SIS_DEPARTMENT D ON C.DEPARTMENT_CODE = D.DEPARTMENT_CODE\n    JOIN \n        SIS_ADMIN_DEPARTMENT A ON A.SIS_ADMIN_DEPARTMENT_CODE = D.DEPARTMENT_CODE\n    GROUP BY \n        C.TERM_CODE, C.DEPARTMENT_NAME, D.SCHOOL_NAME, A.DEPARTMENT_PHONE_NUMBER\n),\nSubtotal AS (\n    SELECT \n        TERM_CODE,\n        DEPARTMENT_NAME,\n        SUM(course_count) AS course_count,\n        AVG(avg_equivalent_subjects) AS avg_equivalent_subjects,\n        SCHOOL_NAME,\n        DEPARTMENT_PHONE_NUMBER\n    FROM \n        CourseStats\n    GROUP BY \n        TERM_CODE, DEPARTMENT_NAME, SCHOOL_NAME, DEPARTMENT_PHONE_NUMBER\n),\nGrandTotal AS (\n    SELECT \n        'TOTAL' AS TERM_CODE,\n        NULL AS DEPARTMENT_NAME,\n        SUM(course_count) AS course_count,\n        AVG(avg_equivalent_subjects) AS avg_equivalent_subjects,\n        NULL AS SCHOOL_NAME,\n        NULL AS DEPARTMENT_PHONE_NUMBER\n    FROM \n        Subtotal\n)\n\nSELECT \n    TERM_CODE,\n    DEPARTMENT_NAME,\n    course_count,\n    avg_equivalent_subjects,\n    SCHOOL_NAME,\n    DEPARTMENT_PHONE_NUMBER\nFROM \n    Subtotal\n\nUNION ALL\n\nSELECT \n    TERM_CODE,\n    DEPARTMENT_NAME,\n    course_count,\n    avg_equivalent_subjects,\n    SCHOOL_NAME,\n    DEPARTMENT_PHONE_NUMBER\nFROM \n    GrandTotal\nORDER BY \n    TERM_CODE, DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Group sessions by their current term status. For each group, state the status ('CURRENT' if is current term and 'NOT CURRENT' otherwise), name of the session, number of IAP sessions, total IAP session time in days, and average IAP session time in days. Show a subtotal for each current status and a grand total row across all status. Order the results by current status and cluster type. Display the the current status only if it differs from the previous entry.",
        "predicted_sql": "WITH SessionStatistics AS (\n    SELECT \n        CASE \n            WHEN AT.IS_CURRENT_TERM = 'Y' THEN 'CURRENT'\n            ELSE 'NOT CURRENT'\n        END AS Current_Status,\n        ISC.IAP_CATEGORY_NAME AS Session_Name,\n        COUNT(DISTINCT ISS.IAP_SUBJECT_SESSION_KEY) AS Number_of_IAP_Sessions,\n        JULIANDAY(MAX(ISS.SESSION_DATE)) - JULIANDAY(MIN(ISS.SESSION_DATE)) AS Total_Session_Time,\n        (JULIANDAY(MAX(ISS.SESSION_DATE)) - JULIANDAY(MIN(ISS.SESSION_DATE))) / COUNT(DISTINCT ISS.IAP_SUBJECT_SESSION_KEY) AS Average_Session_Time\n    FROM \n        ACADEMIC_TERMS AT\n    JOIN \n        IAP_SUBJECT_DETAIL ISD ON AT.TERM_CODE = ISD.TERM_CODE\n    JOIN \n        IAP_SUBJECT_SESSION ISS ON ISD.IAP_SUBJECT_SESSION_KEY = ISS.IAP_SUBJECT_SESSION_KEY\n    JOIN \n        IAP_SUBJECT_CATEGORY ISC ON ISD.IAP_SUBJECT_CATEGORY_KEY = ISC.IAP_SUBJECT_CATEGORY_KEY\n    GROUP BY \n        Current_Status, Session_Name\n),\nSubtotal AS (\n    SELECT \n        Current_Status,\n        NULL AS Session_Name,\n        SUM(Number_of_IAP_Sessions) AS Number_of_IAP_Sessions,\n        SUM(Total_Session_Time) AS Total_Session_Time,\n        AVG(Average_Session_Time) AS Average_Session_Time\n    FROM \n        SessionStatistics\n    GROUP BY \n        Current_Status\n)\nSELECT \n    Current_Status,\n    Session_Name,\n    Number_of_IAP_Sessions,\n    Total_Session_Time,\n    Average_Session_Time\nFROM \n    SessionStatistics\nUNION ALL\nSELECT \n    Current_Status,\n    Session_Name,\n    Number_of_IAP_Sessions,\n    Total_Session_Time,\n    Average_Session_Time\nFROM \n    Subtotal\nORDER BY \n    CASE Current_Status WHEN 'CURRENT' THEN 1 ELSE 2 END, Session_Name;"
    },
    {
        "db_id": "dw",
        "question": "List each academic year, the term code, and the number of newly introduced subjects in this term. Display the academic year only if it differs from the previous entry. Include a grand total (the corresponding year field should be 'TOTAL') stating the total number of subjects across all academic years.",
        "predicted_sql": "SELECT \n    CASE WHEN academic_year = LAG(academic_year) OVER (ORDER BY academic_year) THEN NULL ELSE academic_year END AS academic_year,\n    term_code,\n    COUNT(DISTINCT subject_id) AS newly_introduced_subjects\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED\nJOIN \n    ACADEMIC_TERMS_ALL ON COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE = ACADEMIC_TERMS_ALL.TERM_CODE\nGROUP BY \n    academic_year, term_code\nUNION ALL\nSELECT \n    'TOTAL' AS academic_year,\n    NULL AS term_code,\n    COUNT(DISTINCT subject_id) AS newly_introduced_subjects\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED\nJOIN \n    ACADEMIC_TERMS_ALL ON COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE = ACADEMIC_TERMS_ALL.TERM_CODE\nORDER BY \n    academic_year;"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with e (case insensitive), containing 10 to 20 members inclusive, and where over 75% are computer science students, provide the list name, owner, and member count.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME, \n    mlo.OWNER, \n    COUNT(mld.MOIRA_LIST_MEMBER) AS member_count\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN \n    MIT_STUDENT_DIRECTORY msd ON sp.FULL_NAME = msd.FULL_NAME\nWHERE \n    LOWER(ml.MOIRA_LIST_NAME) LIKE 'e%' \nGROUP BY \n    ml.MOIRA_LIST_NAME, \n    mlo.OWNER\nHAVING \n    COUNT(mld.MOIRA_LIST_MEMBER) BETWEEN 10 AND 20 AND \n    SUM(CASE WHEN msd.DEPARTMENT = '11' THEN 1 ELSE 0 END) * 1.0 / COUNT(mld.MOIRA_LIST_MEMBER) > 0.75;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with K, list their names, the phone numbers of departments they belong to, total number of mailing lists each student is in, and the average size of the mailing lists each student is in.",
        "predicted_sql": "SELECT \n    msd.FULL_NAME AS student_name,\n    sad.DEPARTMENT_PHONE_NUMBER AS department_phone,\n    COUNT(DISTINCT mld.MOIRA_LIST_KEY) AS mailing_list_count,\n    AVG(mld.COUNTER) AS average_mailing_list_size\nFROM \n    MIT_STUDENT_DIRECTORY msd\nJOIN \n    SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE\nJOIN \n    MOIRA_LIST_DETAIL mld ON msd.FULL_NAME = mld.MOIRA_LIST_MEMBER_FULL_NAME\nWHERE \n    msd.LAST_NAME LIKE 'K%'\nGROUP BY \n    msd.FULL_NAME, sad.DEPARTMENT_PHONE_NUMBER;"
    },
    {
        "db_id": "dw",
        "question": "From the 100 email lists with the most number of subscribers, list their names, their total number of subscribers, their public status, the name of the department with the most presence in the list, and the number of students from this department in the list.",
        "predicted_sql": "SELECT ml.MOIRA_LIST_NAME, \n       COUNT(mld.MOIRA_LIST_MEMBER) AS total_subscribers, \n       ml.IS_PUBLIC, \n       sd.DEPARTMENT_NAME, \n       COUNT(DISTINCT ms.FULL_NAME) AS student_count\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN MIT_STUDENT_DIRECTORY ms ON mld.MOIRA_LIST_MEMBER_MIT_ID = ms.FULL_NAME\nJOIN SIS_DEPARTMENT sd ON ms.DEPARTMENT = sd.DEPARTMENT_CODE\nGROUP BY ml.MOIRA_LIST_NAME, ml.IS_PUBLIC, sd.DEPARTMENT_NAME\nORDER BY total_subscribers DESC\nLIMIT 100;"
    },
    {
        "db_id": "dw",
        "question": "Calculate the total assignable and non-assignable area for each building by summing up the respective areas of all its floors. For each building, list the building name, building number, total assignable area, total non-assignable area, and total room count, sorted in descending order of the total assignable area.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME AS building_name,\n    b.BUILDING_NUMBER AS building_number,\n    SUM(f.ASSIGNABLE_AREA) AS total_assignable_area,\n    SUM(f.NON_ASSIGNABLE_AREA) AS total_non_assignable_area,\n    COUNT(r.FAC_ROOM_KEY) AS total_room_count\nFROM \n    FAC_BUILDING b\nJOIN \n    FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nJOIN \n    FAC_ROOMS r ON f.BUILDING_KEY = r.BUILDING_KEY AND f.FLOOR = r.FLOOR\nGROUP BY \n    b.BUILDING_NAME, b.BUILDING_NUMBER\nORDER BY \n    total_assignable_area DESC;"
    },
    {
        "db_id": "dw",
        "question": "List all rooms in building 45, including their full name, area, major use, the organization that occupies them, the count of rooms per major use, and the total area occupied by rooms for each organization.",
        "predicted_sql": "SELECT \n    r.ROOM_FULL_NAME, \n    r.AREA, \n    mu.MAJOR_USE, \n    org.ORGANIZATION_NAME, \n    COUNT(r.FAC_ROOM_KEY) OVER(PARTITION BY mu.MAJOR_USE) AS ROOM_COUNT_PER_MAJOR_USE, \n    SUM(r.AREA) OVER(PARTITION BY org.ORGANIZATION_NAME) AS TOTAL_AREA_OCCUPIED \nFROM \n    FAC_ROOMS r\nJOIN \n    FAC_MAJOR_USE mu ON r.MAJOR_USE_KEY = mu.MAJOR_USE_KEY\nJOIN \n    FAC_ORGANIZATION org ON r.ORGANIZATION_KEY = org.ORGANIZATION_KEY\nWHERE \n    r.BUILDING_KEY = '45';"
    },
    {
        "db_id": "dw",
        "question": "List the name, number, construction date, and type of all buildings, along with the count of addresses associated with each building, the average gross area of the buildings, and the total number of rooms in each building. Sort the results by building name.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME AS name,\n    b.BUILDING_NUMBER AS number,\n    b.DATE_BUILT AS construction_date,\n    b.BUILDING_TYPE AS type,\n    COUNT(a.BUILDING_ADDRESS_KEY) AS address_count,\n    AVG(CAST(b.EXT_GROSS_AREA AS FLOAT)) AS average_gross_area,\n    COUNT(r.FAC_ROOM_KEY) AS total_rooms\nFROM \n    FAC_BUILDING b\nLEFT JOIN \n    FAC_BUILDING_ADDRESS a ON b.FAC_BUILDING_KEY = a.BUILDING_KEY\nLEFT JOIN \n    FAC_ROOMS r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY\nGROUP BY \n    b.BUILDING_NAME, b.BUILDING_NUMBER, b.DATE_BUILT, b.BUILDING_TYPE\nORDER BY \n    b.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list its name, number of unique courses offered, the number of unique reserved materials, and the number of unique instructors associated with those courses, sorted by the number of unique courses offered in descending order.",
        "predicted_sql": "SELECT \n    so.OFFER_DEPT_NAME AS department_name,\n    COUNT(DISTINCT so.MASTER_COURSE_NUMBER) AS unique_courses,\n    COUNT(DISTINCT rc.CATALOG_TITLE) AS unique_reserved_materials,\n    COUNT(DISTINCT ci.INSTRUCTOR_NAME) AS unique_instructors\nFROM \n    LIBRARY_SUBJECT_OFFERED so\nLEFT JOIN \n    LIBRARY_RESERVE_MATRL_DETAIL rmd ON so.LIBRARY_SUBJECT_OFFERED_KEY = rmd.LIBRARY_SUBJECT_OFFERED_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_CATALOG rc ON rmd.LIBRARY_RESERVE_CATALOG_KEY = rc.LIBRARY_RESERVE_CATALOG_KEY\nLEFT JOIN \n    LIBRARY_COURSE_INSTRUCTOR ci ON rmd.LIBRARY_COURSE_INSTRUCTOR_KEY = ci.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    so.OFFER_DEPT_NAME\nORDER BY \n    unique_courses DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each course title, list the title, the total number of reserved materials, and the count of distinct material status associated with those materials, sorted by the total number of reserved materials in descending order.",
        "predicted_sql": "SELECT \n    SO.SUBJECT_TITLE, \n    COUNT(RD.LIBRARY_RESERVE_CATALOG_KEY) AS total_reserved_materials, \n    COUNT(DISTINCT M.LIBRARY_MATERIAL_STATUS) AS distinct_material_status_count\nFROM \n    LIBRARY_SUBJECT_OFFERED SO\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL RD ON SO.LIBRARY_SUBJECT_OFFERED_KEY = RD.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS M ON RD.LIBRARY_MATERIAL_STATUS_KEY = M.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    SO.SUBJECT_TITLE\nORDER BY \n    total_reserved_materials DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each instructor, list their name, the number of unique courses they teach, the total number of material assignments, average publication year, and number of distinct status, sorted by the number of unique courses in descending order.",
        "predicted_sql": "SELECT \n    lci.INSTRUCTOR_NAME,\n    COUNT(DISTINCT lci.COURSE_NAME) AS unique_courses,\n    COUNT(lrm.LIBRARY_RESERVE_CATALOG_KEY) AS total_material_assignments,\n    AVG(CAST(lrc.CATALOG_YEAR AS INTEGER)) AS average_publication_year,\n    COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS_KEY) AS distinct_status_count\nFROM \n    LIBRARY_COURSE_INSTRUCTOR lci\nLEFT JOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrm ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrm.LIBRARY_COURSE_INSTRUCTOR_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrm.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nLEFT JOIN \n    LIBRARY_MATERIAL_STATUS lms ON lrm.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    lci.INSTRUCTOR_NAME\nORDER BY \n    unique_courses DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each publication year, list the year, the total number of reserved materials, the average length of their titles, distinct number of status, and number of courses, sorted by publication year in descending order.",
        "predicted_sql": "SELECT \n    CATALOG_YEAR,\n    COUNT(DISTINCT R.LIBRARY_RESERVE_CATALOG_KEY) AS total_reserved_materials,\n    AVG(LENGTH(R.CATALOG_TITLE)) AS average_title_length,\n    COUNT(DISTINCT M.LIBRARY_MATERIAL_STATUS) AS distinct_status_count,\n    COUNT(DISTINCT I.COURSE_NAME) AS total_courses\nFROM \n    LIBRARY_RESERVE_CATALOG R\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL D ON R.LIBRARY_RESERVE_CATALOG_KEY = D.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS M ON D.LIBRARY_MATERIAL_STATUS_KEY = M.LIBRARY_MATERIAL_STATUS_KEY\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR I ON D.LIBRARY_COURSE_INSTRUCTOR_KEY = I.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    CATALOG_YEAR\nORDER BY \n    CATALOG_YEAR DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list the category name, the sponsor name, the number of activities offered, and the average fee per activity, sorted by the number of activities in descending order.",
        "predicted_sql": "SELECT \n    isc.IAP_CATEGORY_NAME,\n    iss.SPONSOR_NAME,\n    COUNT(isd.ACTIVITY_TITLE) AS number_of_activities,\n    AVG(isd.FEE) AS average_fee_per_activity\nFROM \n    IAP_SUBJECT_CATEGORY isc\nJOIN \n    IAP_SUBJECT_DETAIL isd ON isc.IAP_SUBJECT_CATEGORY_KEY = isd.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    IAP_SUBJECT_SPONSOR iss ON isd.IAP_SUBJECT_SPONSOR_KEY = iss.IAP_SUBJECT_SPONSOR_KEY\nGROUP BY \n    isc.IAP_CATEGORY_NAME, iss.SPONSOR_NAME\nORDER BY \n    number_of_activities DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor, list the sponsor name, the number of IAP sessions hosted, and the number of unique subjects organized.",
        "predicted_sql": "SELECT \n    s.SPONSOR_NAME,\n    COUNT(DISTINCT ses.IAP_SUBJECT_SESSION_KEY) AS session_count,\n    COUNT(DISTINCT det.IAP_SUBJECT_CATEGORY_KEY) AS subject_count\nFROM \n    IAP_SUBJECT_SPONSOR s\nLEFT JOIN \n    IAP_SUBJECT_DETAIL det ON s.IAP_SUBJECT_SPONSOR_KEY = det.IAP_SUBJECT_SPONSOR_KEY\nLEFT JOIN \n    IAP_SUBJECT_SESSION ses ON det.IAP_SUBJECT_SESSION_KEY = ses.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    s.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each person role and IAP category, list the role, the category name, the number of people in this role, and the average fee, sorted by the role count in descending order.",
        "predicted_sql": "SELECT \n    sp.PERSON_ROLE, \n    sc.IAP_CATEGORY_NAME, \n    COUNT(sp.IAP_SUBJECT_PERSON_KEY) AS number_of_people, \n    AVG(sd.FEE) AS average_fee\nFROM \n    IAP_SUBJECT_PERSON sp\nJOIN \n    IAP_SUBJECT_DETAIL sd ON sp.IAP_SUBJECT_PERSON_KEY = sd.IAP_SUBJECT_PERSON_KEY\nJOIN \n    IAP_SUBJECT_CATEGORY sc ON sd.IAP_SUBJECT_CATEGORY_KEY = sc.IAP_SUBJECT_CATEGORY_KEY\nGROUP BY \n    sp.PERSON_ROLE, sc.IAP_CATEGORY_NAME\nORDER BY \n    number_of_people DESC;"
    },
    {
        "db_id": "dw",
        "question": "List the names of the buildings with the most floors. If there are ties, list each one separately.",
        "predicted_sql": "SELECT fb.BUILDING_NAME\nFROM FAC_BUILDING fb\nJOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY\nJOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY\nGROUP BY fb.BUILDING_NAME\nHAVING COUNT(DISTINCT ff.FLOOR) = (\n    SELECT MAX(floor_count)\n    FROM (\n        SELECT COUNT(DISTINCT ff2.FLOOR) AS floor_count\n        FROM FAC_BUILDING fb2\n        JOIN FAC_ROOMS fr2 ON fb2.FAC_BUILDING_KEY = fr2.BUILDING_KEY\n        JOIN FAC_FLOOR ff2 ON fr2.FLOOR_KEY = ff2.FLOOR_KEY\n        GROUP BY fb2.BUILDING_NAME\n    ) AS subquery\n);"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered in the summer term, list the subject titles, number of instructors, and the length of the longest instructor name.",
        "predicted_sql": "SELECT \n    CCSO.SUBJECT_TITLE,\n    COUNT(ED.FULL_NAME) AS Number_of_Instructors,\n    MAX(LENGTH(ED.FULL_NAME)) AS Length_of_Longest_Instructor_Name\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED CCSO\nJOIN \n    EMPLOYEE_DIRECTORY ED ON CCSO.RESPONSIBLE_FACULTY_MIT_ID = ED.MIT_ID\nJOIN \n    ACADEMIC_TERMS_ALL ATA ON CCSO.TERM_CODE = ATA.TERM_CODE\nWHERE \n    ATA.TERM_CODE LIKE '%SU' \nGROUP BY \n    CCSO.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For the mailing list with owner key LIST69.377-keeper-xenon, list the owner, total number of mailing lists, and total number of members across all these mailing lists.",
        "predicted_sql": "SELECT \n    o.OWNER, \n    COUNT(DISTINCT l.MOIRA_LIST_KEY) AS total_mailing_lists, \n    COUNT(d.MOIRA_LIST_MEMBER) AS total_members\nFROM \n    MOIRA_LIST_OWNER o\nJOIN \n    MOIRA_LIST l ON o.MOIRA_LIST_OWNER_KEY = l.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\nWHERE \n    o.MOIRA_LIST_OWNER_KEY = 'LIST69.377-keeper-xenon'\nGROUP BY \n    o.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For each school, list the school name, total number of courses that appear in SIS subject code catalog, and the total number of degree-granting courses that appear in SIS subject code catalog.",
        "predicted_sql": "SELECT \n    sd.SCHOOL_NAME,\n    COUNT(DISTINCT sc.COURSE) AS total_courses,\n    COUNT(DISTINCT CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN sc.COURSE END) AS total_degree_granting_courses\nFROM \n    SIS_DEPARTMENT sd\nJOIN \n    SIS_COURSE_DESCRIPTION scd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT\nJOIN \n    SIS_SUBJECT_CODE sc ON scd.COURSE = sc.COURSE_NUMBER\nGROUP BY \n    sd.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the department name, department phone number, number of students, and the length of the longest student full name in that department.",
        "predicted_sql": "SELECT \n    SD.DEPARTMENT_NAME, \n    SAD.DEPARTMENT_PHONE_NUMBER, \n    COUNT(MSD.EMAIL_ADDRESS) AS number_of_students, \n    MAX(LENGTH(MSD.FULL_NAME)) AS longest_student_full_name_length\nFROM \n    SIS_DEPARTMENT SD\nJOIN \n    SIS_ADMIN_DEPARTMENT SAD ON SD.DEPARTMENT_CODE = SAD.SIS_ADMIN_DEPARTMENT_CODE\nLEFT JOIN \n    MIT_STUDENT_DIRECTORY MSD ON MSD.DEPARTMENT = SD.DEPARTMENT_CODE\nGROUP BY \n    SD.DEPARTMENT_NAME, \n    SAD.DEPARTMENT_PHONE_NUMBER;"
    }
]