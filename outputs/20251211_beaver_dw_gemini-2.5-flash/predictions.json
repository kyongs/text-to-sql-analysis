[
    {
        "db_id": "dw",
        "question": "What is the current building key, building street address, city, state, and postal code of the history department?",
        "predicted_sql": "SELECT DISTINCT\n  B.BUILDING_KEY,\n  B.BUILDING_STREET_ADDRESS,\n  FBA.CITY,\n  FBA.STATE,\n  FBA.POSTAL_CODE\nFROM MASTER_DEPT_HIERARCHY AS MDH\nJOIN FCLT_ORG_DLC_KEY AS FODK\n  ON MDH.DLC_KEY = FODK.DLC_KEY\nJOIN FCLT_ROOMS AS FR\n  ON FODK.FCLT_ORGANIZATION_KEY = FR.FCLT_ORGANIZATION_KEY\nJOIN FCLT_BUILDING_ADDRESS AS FBA\n  ON FR.FCLT_BUILDING_KEY = FBA.FCLT_BUILDING_KEY\nJOIN BUILDINGS AS B\n  ON FR.FCLT_BUILDING_KEY = B.BUILDING_KEY\nWHERE\n  MDH.DLC_NAME = 'History Department' AND FBA.ADDRESS_PURPOSE = 'STREET';"
    },
    {
        "db_id": "dw",
        "question": "Show the unique activity titles, locations, term start date, and supervisor name for all independent activities, sorted by the ascending order of start date.",
        "predicted_sql": "SELECT DISTINCT\n  T1.ACTIVITY_TITLE,\n  T3.SESSION_LOCATION,\n  T2.TERM_START_DATE,\n  T4.PERSON_NAME\nFROM IAP_SUBJECT_DETAIL AS T1\nINNER JOIN ACADEMIC_TERMS_ALL AS T2\n  ON T1.TERM_CODE = T2.TERM_CODE\nINNER JOIN IAP_SUBJECT_SESSION AS T3\n  ON T1.IAP_SUBJECT_SESSION_KEY = T3.IAP_SUBJECT_SESSION_KEY\nINNER JOIN IAP_SUBJECT_PERSON AS T4\n  ON T1.IAP_SUBJECT_PERSON_KEY = T4.IAP_SUBJECT_PERSON_KEY\nWHERE\n  T4.PERSON_ROLE = 'Activity leader' AND T1.IS_MULTIPLE_SESSION = 'N'\nORDER BY\n  T2.TERM_START_DATE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the unique course instructor names, course titles, and the amount of material for each course instructor key and the key of subject offered.",
        "predicted_sql": "SELECT\n  T1.INSTRUCTOR_NAME,\n  T4.SUBJECT_TITLE,\n  T1.LIBRARY_COURSE_INSTRUCTOR_KEY,\n  T4.LIBRARY_SUBJECT_OFFERED_KEY,\n  COUNT(DISTINCT T3.CATALOG_ISBN) AS amount_of_material\nFROM LIBRARY_COURSE_INSTRUCTOR AS T1\nINNER JOIN LIBRARY_RESERVE_MATRL_DETAIL AS T2\n  ON T1.LIBRARY_COURSE_INSTRUCTOR_KEY = T2.LIBRARY_COURSE_INSTRUCTOR_KEY\nINNER JOIN LIBRARY_RESERVE_CATALOG AS T3\n  ON T2.LIBRARY_RESERVE_CATALOG_KEY = T3.LIBRARY_RESERVE_CATALOG_KEY\nINNER JOIN LIBRARY_SUBJECT_OFFERED AS T4\n  ON T2.LIBRARY_SUBJECT_OFFERED_KEY = T4.LIBRARY_SUBJECT_OFFERED_KEY\nGROUP BY\n  T1.INSTRUCTOR_NAME,\n  T4.SUBJECT_TITLE,\n  T1.LIBRARY_COURSE_INSTRUCTOR_KEY,\n  T4.LIBRARY_SUBJECT_OFFERED_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What is the room, floor, building key, building street address, city, state, and postal code of Professor Summer Haynes's office?",
        "predicted_sql": "SELECT\n  T2.ROOM,\n  T2.FLOOR,\n  T3.BUILDING_KEY,\n  T4.BUILDING_STREET_ADDRESS,\n  T3.CITY,\n  T3.STATE,\n  T3.POSTAL_CODE\nFROM EMPLOYEE_DIRECTORY AS T1\nINNER JOIN FAC_ROOMS AS T2\n  ON T1.OFFICE_LOCATION = T2.FAC_ROOM_KEY\nINNER JOIN FAC_BUILDING_ADDRESS AS T3\n  ON T2.BUILDING_KEY = T3.BUILDING_KEY\nINNER JOIN BUILDINGS AS T4\n  ON T3.BUILDING_KEY = T4.BUILDING_KEY\nWHERE\n  T1.FULL_NAME = 'Haynes, Summer' AND T3.ADDRESS_PURPOSE = 'STREET';"
    },
    {
        "db_id": "dw",
        "question": "List the unique full room names, their corresponding building names, street addresses, cities, states, postal codes, and building heights for rooms associated with subjects that Computer Science students can enroll in.",
        "predicted_sql": "```mysql\nSELECT DISTINCT\n  T1.ROOM_FULL_NAME,\n  T3.BUILDING_NAME,\n  T3.BUILDING_STREET_ADDRESS,\n  T4.CITY,\n  T4.STATE,\n  T4.POSTAL_CODE,\n  T2.BUILDING_HEIGHT\nFROM FCLT_ROOMS AS T1\nINNER JOIN FCLT_BUILDING AS T2\n  ON T1.FCLT_BUILDING_KEY = T2.FCLT_BUILDING_KEY\nINNER JOIN BUILDINGS AS T3\n  ON T1.FCLT_BUILDING_KEY = T3.BUILDING_KEY\nINNER JOIN FCLT_BUILDING_ADDRESS AS T4\n  ON T1.FCLT_BUILDING_KEY = T4.FCLT_BUILDING_KEY\nINNER JOIN COURSE_CATALOG_SUBJECT_OFFERED AS T5\n  ON T1.FCLT_ROOM_KEY = T5.MEET_PLACE\nWHERE\n  T5.DEPARTMENT_NAME LIKE '%Computer Science%' AND T4.ADDRESS_PURPOSE = 'STREET';"
    },
    {
        "db_id": "dw",
        "question": "List the unique term code, subject title, room, floor, building key, building street address, city, state, and postal code, formats, and number of enrolled students for all courses with more than 300 attendees.",
        "predicted_sql": "SELECT DISTINCT\n  T1.TERM_CODE,\n  T1.SUBJECT_TITLE,\n  T2.ROOM,\n  T2.FLOOR,\n  T3.BUILDING_KEY,\n  T3.BUILDING_STREET_ADDRESS,\n  T4.CITY,\n  T4.STATE,\n  T4.POSTAL_CODE,\n  T1.FORM_TYPE,\n  T1.NUM_ENROLLED_STUDENTS\nFROM SUBJECT_OFFERED AS T1\nINNER JOIN FCLT_ROOMS AS T2\n  ON T1.MEET_PLACE = T2.FCLT_ROOM_KEY\nINNER JOIN BUILDINGS AS T3\n  ON T2.FCLT_BUILDING_KEY = T3.BUILDING_KEY\nINNER JOIN FCLT_BUILDING_ADDRESS AS T4\n  ON T3.BUILDING_KEY = T4.FCLT_BUILDING_KEY\nWHERE\n  T1.NUM_ENROLLED_STUDENTS > 300 AND T4.ADDRESS_PURPOSE = 'STREET';"
    },
    {
        "db_id": "dw",
        "question": "What are the subject titles, their material titles, ISBN numbers, new shelf prices, and total costs of new materials for each subject title, sorted by individual item prices in ascending order?",
        "predicted_sql": "SELECT\n  T1.SUBJECT_TITLE,\n  T2.TITLE,\n  T2.ISBN,\n  T2.NEW_SHELF_PRICE,\n  SUM(T2.NEW_SHELF_PRICE) OVER (PARTITION BY T1.SUBJECT_TITLE) AS total_new_material_cost\nFROM TIP_SUBJECT_OFFERED AS T1\nJOIN TIP_DETAIL AS T3\n  ON T1.SUBJECT_ID = T3.SUBJECT_ID\nJOIN TIP_MATERIAL AS T2\n  ON T3.TIP_MATERIAL_KEY = T2.TIP_MATERIAL_KEY\nORDER BY\n  T2.NEW_SHELF_PRICE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the long names of buildings constructed before 1950 that have more than 100 employees, the built year of the building, and number of employees.",
        "predicted_sql": "SELECT\n  T1.BUILDING_NAME_LONG,\n  SUBSTRING(T1.DATE_BUILT, 7, 4) AS built_year,\n  COUNT(T3.MIT_ID) AS num_employees\nFROM FCLT_BUILDING_HIST AS T1\nINNER JOIN FCLT_ROOMS AS T2\n  ON T1.FCLT_BUILDING_KEY = T2.FCLT_BUILDING_KEY\nINNER JOIN EMPLOYEE_DIRECTORY AS T3\n  ON T2.BUILDING_ROOM = T3.OFFICE_LOCATION\nWHERE\n  CAST(SUBSTRING(T1.DATE_BUILT, 7, 4) AS UNSIGNED) < 1950\nGROUP BY\n  T1.BUILDING_NAME_LONG,\n  built_year\nHAVING\n  COUNT(T3.MIT_ID) > 100;"
    },
    {
        "db_id": "dw",
        "question": "For each building key, what is the building name and the number of courses offered by the Center for International Studies?",
        "predicted_sql": "```mysql\nSELECT\n  T1.FCLT_BUILDING_KEY,\n  T1.BUILDING_NAME,\n  COUNT(DISTINCT T3.SUBJECT_ID)\nFROM FCLT_BUILDING AS T1\nINNER JOIN FCLT_ROOMS AS T2\n  ON T1.FCLT_BUILDING_KEY = T2.FCLT_BUILDING_KEY\nINNER JOIN COURSE_CATALOG_SUBJECT_OFFERED AS T3\n  ON T2.FCLT_ROOM_KEY = T3.MEET_PLACE\nWHERE\n  T3.DEPARTMENT_NAME = 'Center for International Studies'\nGROUP BY\n  T1.FCLT_BUILDING_KEY,\n  T1.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building that accomodates the most students, and how many students does it accomodate?",
        "predicted_sql": "SELECT\n  T1.BUILDING_NAME,\n  COUNT(T3.FULL_NAME) AS num_students\nFROM FCLT_BUILDING AS T1\nINNER JOIN FCLT_ROOMS AS T2\n  ON T1.FCLT_BUILDING_KEY = T2.FCLT_BUILDING_KEY\nINNER JOIN MIT_STUDENT_DIRECTORY AS T3\n  ON T2.BUILDING_ROOM = T3.OFFICE_LOCATION\nGROUP BY\n  T1.BUILDING_NAME\nORDER BY\n  num_students DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "List the name and floor of the building with the largest floor number.",
        "predicted_sql": "SELECT\n  T1.BUILDING_NAME,\n  T2.FLOOR\nFROM FAC_BUILDING AS T1\nJOIN FAC_FLOOR AS T2\n  ON T1.FAC_BUILDING_KEY = T2.BUILDING_KEY\nORDER BY\n  CAST(T2.FLOOR AS UNSIGNED) DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category and academic year, list the category name, academic year, total fee collected, total number of IAP subjects, and the minimum and maximum enrollment.",
        "predicted_sql": "SELECT\n  T1.IAP_CATEGORY_NAME,\n  T3.ACADEMIC_YEAR,\n  SUM(T2.FEE),\n  COUNT(T2.ACTIVITY_TITLE),\n  MIN(T2.MAX_ENROLLMENT),\n  MAX(T2.MAX_ENROLLMENT)\nFROM IAP_SUBJECT_CATEGORY AS T1\nINNER JOIN IAP_SUBJECT_DETAIL AS T2\n  ON T1.IAP_SUBJECT_CATEGORY_KEY = T2.IAP_SUBJECT_CATEGORY_KEY\nINNER JOIN TIME_DAY AS T3\n  ON T2.TERM_CODE = T3.ACADEMIC_TERM_CODE\nGROUP BY\n  T1.IAP_CATEGORY_NAME,\n  T3.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor of the independent activity periods, list the sponsor name, number of sessions held, the total number of enrollment, the minimum and maximum fee, the number of sessions with info, and the number of sessions without info.",
        "predicted_sql": "WITH detail_agg AS (\n  SELECT\n    IAP_SUBJECT_SPONSOR_KEY,\n    SUM(MAX_ENROLLMENT) AS total_enrollment,\n    MIN(FEE) AS min_fee,\n    MAX(FEE) AS max_fee\n  FROM IAP_SUBJECT_DETAIL\n  GROUP BY\n    IAP_SUBJECT_SPONSOR_KEY\n), session_agg AS (\n  SELECT\n    isd.IAP_SUBJECT_SPONSOR_KEY,\n    COUNT(*) AS num_sessions_held,\n    SUM(CASE WHEN issn.HAS_SESSION_INFO = 'Y' THEN 1 ELSE 0 END) AS sessions_with_info,\n    SUM(CASE WHEN issn.HAS_SESSION_INFO = 'N' THEN 1 ELSE 0 END) AS sessions_without_info\n  FROM IAP_SUBJECT_DETAIL AS isd\n  JOIN IAP_SUBJECT_SESSION AS issn\n    ON isd.IAP_SUBJECT_SESSION_KEY = issn.IAP_SUBJECT_SESSION_KEY\n  GROUP BY\n    isd.IAP_SUBJECT_SPONSOR_KEY\n)\nSELECT\n  iss.SPONSOR_NAME,\n  COALESCE(da.total_enrollment, 0) AS total_enrollment,\n  da.min_fee,\n  da.max_fee,\n  COALESCE(sa.num_sessions_held, 0) AS num_sessions_held,\n  COALESCE(sa.sessions_with_info, 0) AS sessions_with_info,\n  COALESCE(sa.sessions_without_info, 0) AS sessions_without_info\nFROM IAP_SUBJECT_SPONSOR AS iss\nLEFT JOIN detail_agg AS da\n  ON iss.IAP_SUBJECT_SPONSOR_KEY = da.IAP_SUBJECT_SPONSOR_KEY\nLEFT JOIN session_agg AS sa\n  ON iss.IAP_SUBJECT_SPONSOR_KEY = sa.IAP_SUBJECT_SPONSOR_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What are the individual's email and name, academic year, total number of IAP subjects, the minimum and maximum fees, and the total course enrollment for each individual and academic year?",
        "predicted_sql": "SELECT\n  T2.PERSON_EMAIL,\n  T2.PERSON_NAME,\n  T3.ACADEMIC_YEAR,\n  COUNT(T1.IAP_SUBJECT_PERSON_KEY) AS total_iap_subjects,\n  MIN(T1.FEE) AS min_fee,\n  MAX(T1.FEE) AS max_fee,\n  SUM(T1.MAX_ENROLLMENT) AS total_course_enrollment\nFROM IAP_SUBJECT_DETAIL AS T1\nINNER JOIN IAP_SUBJECT_PERSON AS T2\n  ON T1.IAP_SUBJECT_PERSON_KEY = T2.IAP_SUBJECT_PERSON_KEY\nINNER JOIN TIME_DAY AS T3\n  ON T1.TERM_CODE = T3.ACADEMIC_TERM_CODE\nGROUP BY\n  T2.PERSON_EMAIL,\n  T2.PERSON_NAME,\n  T3.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "What is the term code, term description, total number of IAP sessions, total fee collected, and minimum and maximum enrollment for each term code?",
        "predicted_sql": "SELECT\n  T1.TERM_CODE,\n  T1.TERM_DESCRIPTION,\n  COUNT(DISTINCT T3.IAP_SUBJECT_SESSION_KEY) AS total_iap_sessions,\n  SUM(T2.FEE) AS total_fee_collected,\n  MIN(T2.MAX_ENROLLMENT) AS minimum_enrollment,\n  MAX(T2.MAX_ENROLLMENT) AS maximum_enrollment\nFROM ACADEMIC_TERMS_ALL AS T1\nJOIN IAP_SUBJECT_DETAIL AS T2\n  ON T1.TERM_CODE = T2.TERM_CODE\nJOIN IAP_SUBJECT_SESSION AS T3\n  ON T2.IAP_SUBJECT_SESSION_KEY = T3.IAP_SUBJECT_SESSION_KEY\nGROUP BY\n  T1.TERM_CODE,\n  T1.TERM_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building, total number of subjects, total fee, and shortest and longest sessions for each physical IAP session location?",
        "predicted_sql": "```mysql\nSELECT\n  T3.BUILDING_NAME,\n  COUNT(DISTINCT T1.ACTIVITY_TITLE) AS total_subjects,\n  SUM(T1.FEE) AS total_fee,\n  MIN(TIME_TO_SEC(TIMEDIFF(STR_TO_DATE(T2.SESSION_END_TIME, '%h%i%p'), STR_TO_DATE(T2.SESSION_START_TIME, '%h%i%p')))) AS shortest_session_seconds,\n  MAX(TIME_TO_SEC(TIMEDIFF(STR_TO_DATE(T2.SESSION_END_TIME, '%h%i%p'), STR_TO_DATE(T2.SESSION_START_TIME, '%h%i%p')))) AS longest_session_seconds\nFROM IAP_SUBJECT_DETAIL AS T1\nJOIN IAP_SUBJECT_SESSION AS T2\n  ON T1.IAP_SUBJECT_SESSION_KEY = T2.IAP_SUBJECT_SESSION_KEY\nJOIN BUILDINGS AS T3\n  ON T2.SESSION_LOCATION = T3.BUILDING_NUMBER\nGROUP BY\n  T3.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is total number of subjects, the total fee, and the shortest and longest sessions, for all virtual IAP sessions?",
        "predicted_sql": "SELECT\n  COUNT(DISTINCT T1.ACTIVITY_TITLE),\n  SUM(T1.FEE),\n  MIN(TIME_TO_SEC(TIMEDIFF(STR_TO_DATE(T2.SESSION_END_TIME, '%h%i%p'), STR_TO_DATE(T2.SESSION_START_TIME, '%h%i%p')))),\n  MAX(TIME_TO_SEC(TIMEDIFF(STR_TO_DATE(T2.SESSION_END_TIME, '%h%i%p'), STR_TO_DATE(T2.SESSION_START_TIME, '%h%i%p'))))\nFROM IAP_SUBJECT_DETAIL AS T1\nINNER JOIN IAP_SUBJECT_SESSION AS T2\n  ON T1.IAP_SUBJECT_SESSION_KEY = T2.IAP_SUBJECT_SESSION_KEY\nWHERE\n  T2.SESSION_LOCATION IN ('https://mit.zoom.us/', 'On line');"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, full name of the department, course level, total number of courses, and total number of degree-granting courses for each school code, department, and course level?",
        "predicted_sql": "SELECT\n  T3.SCHOOL_CODE,\n  T3.SCHOOL_NAME,\n  T2.DEPARTMENT_FULL_NAME,\n  T1.COURSE_LEVEL,\n  COUNT(T1.COURSE) AS total_number_of_courses,\n  SUM(CASE WHEN T1.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS total_number_of_degree_granting_courses\nFROM SIS_COURSE_DESCRIPTION AS T1\nINNER JOIN SIS_DEPARTMENT AS T2\n  ON T1.DEPARTMENT = T2.DEPARTMENT_CODE\nINNER JOIN SIS_SUBJECT_CODE AS T3\n  ON T1.COURSE = T3.SUBJECT_CODE\nGROUP BY\n  T3.SCHOOL_CODE,\n  T3.SCHOOL_NAME,\n  T2.DEPARTMENT_FULL_NAME,\n  T1.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What are the different schools and departments that offer SIS courses? List their school code, school name, department code, department name, the total number of phone numbers, and the most common course level.",
        "predicted_sql": "WITH DepartmentCourseLevelCounts AS (\n    SELECT\n        T1.SCHOOL_CODE,\n        T1.SCHOOL_NAME,\n        T2.DEPARTMENT_CODE,\n        T3.SIS_ADMIN_DEPARTMENT_NAME,\n        T4.COURSE_LEVEL,\n        COUNT(T4.COURSE_LEVEL) AS level_frequency\n    FROM\n        SIS_SUBJECT_CODE AS T1\n    JOIN\n        SIS_COURSE_DESCRIPTION AS T4\n        ON T1.SUBJECT_CODE = T4.COURSE\n    JOIN\n        SIS_DEPARTMENT AS T2\n        ON T4.DEPARTMENT = T2.DEPARTMENT_CODE\n    JOIN\n        SIS_ADMIN_DEPARTMENT AS T3\n        ON T2.DEPARTMENT_CODE = T3.SIS_ADMIN_DEPARTMENT_CODE\n    GROUP BY\n        T1.SCHOOL_CODE,\n        T1.SCHOOL_NAME,\n        T2.DEPARTMENT_CODE,\n        T3.SIS_ADMIN_DEPARTMENT_NAME,\n        T4.COURSE_LEVEL\n),\nMostCommonCourseLevel AS (\n    SELECT\n        SCHOOL_CODE,\n        SCHOOL_NAME,\n        DEPARTMENT_CODE,\n        SIS_ADMIN_DEPARTMENT_NAME,\n        COURSE_LEVEL AS most_common_course_level\n    FROM (\n        SELECT\n            SCHOOL_CODE,\n            SCHOOL_NAME,\n            DEPARTMENT_CODE,\n            SIS_ADMIN_DEPARTMENT_NAME,\n            COURSE_LEVEL,\n            ROW_NUMBER() OVER (PARTITION BY SCHOOL_CODE, SCHOOL_NAME, DEPARTMENT_CODE, SIS_ADMIN_DEPARTMENT_NAME ORDER BY level_frequency DESC, COURSE_LEVEL ASC) AS rn\n        FROM\n            DepartmentCourseLevelCounts\n    ) AS RankedLevels\n    WHERE\n        rn = 1\n)\nSELECT\n    T1.SCHOOL_CODE,\n    T1.SCHOOL_NAME,\n    T2.DEPARTMENT_CODE,\n    T3.SIS_ADMIN_DEPARTMENT_NAME,\n    COUNT(DISTINCT T3.DEPARTMENT_PHONE_NUMBER) AS total_phone_numbers,\n    MCL.most_common_course_level\nFROM\n    SIS_SUBJECT_CODE AS T1\nJOIN\n    SIS_COURSE_DESCRIPTION AS T4\n    ON T1.SUBJECT_CODE = T4.COURSE\nJOIN\n    SIS_DEPARTMENT AS T2\n    ON T4.DEPARTMENT = T2.DEPARTMENT_CODE\nJOIN\n    SIS_ADMIN_DEPARTMENT AS T3\n    ON T2.DEPARTMENT_CODE = T3.SIS_ADMIN_DEPARTMENT_CODE\nJOIN\n    MostCommonCourseLevel AS MCL\n    ON T1.SCHOOL_CODE = MCL.SCHOOL_CODE AND T1.SCHOOL_NAME = MCL.SCHOOL_NAME AND T2.DEPARTMENT_CODE = MCL.DEPARTMENT_CODE AND T3.SIS_ADMIN_DEPARTMENT_NAME = MCL.SIS_ADMIN_DEPARTMENT_NAME\nGROUP BY\n    T1.SCHOOL_CODE,\n    T1.SCHOOL_NAME,\n    T2.DEPARTMENT_CODE,\n    T3.SIS_ADMIN_DEPARTMENT_NAME,\n    MCL.most_common_course_level\nORDER BY\n    T1.SCHOOL_CODE,\n    T1.SCHOOL_NAME,\n    T2.DEPARTMENT_CODE;"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, DLC key, the graduate level, total number of SIS subjects, the minimum and maximum course numbers, and the total number of departments offering subjects for each school?",
        "predicted_sql": "SELECT\n  T1.SCHOOL_CODE,\n  T1.SCHOOL_NAME,\n  GROUP_CONCAT(DISTINCT T3.DLC_KEY) AS DLC_keys,\n  GROUP_CONCAT(DISTINCT T2.GRADUATE_LEVEL) AS graduate_levels,\n  COUNT(DISTINCT T1.SUBJECT_CODE) AS total_number_of_SIS_subjects,\n  MIN(T1.COURSE_NUMBER) AS minimum_course_numbers,\n  MAX(T1.COURSE_NUMBER) AS maximum_course_numbers,\n  COUNT(DISTINCT T3.DEPARTMENT_CODE) AS total_number_of_departments_offering_subjects\nFROM SIS_SUBJECT_CODE AS T1\nJOIN SIS_COURSE_DESCRIPTION AS T2\n  ON T1.SUBJECT_CODE = T2.COURSE\nJOIN SIS_DEPARTMENT AS T3\n  ON T2.DEPARTMENT = T3.DEPARTMENT_CODE\nGROUP BY\n  T1.SCHOOL_CODE,\n  T1.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the building component, name of the building, square footage for all rooms, total number of floors, total number of rooms, total number of facility organizations, total number of supervisors, and total number of supervisees for each building component?",
        "predicted_sql": "```mysql\nWITH ComponentDLCs AS (\n  SELECT DISTINCT\n    SD.BUILDING_COMPONENT,\n    SU.DLC_KEY\n  FROM SPACE_DETAIL AS SD\n  JOIN SPACE_UNIT AS SU\n    ON SD.SPACE_UNIT_KEY = SU.SPACE_UNIT_KEY\n  WHERE\n    SU.DLC_KEY IS NOT NULL\n), SupervisorAggregates AS (\n  SELECT\n    CD.BUILDING_COMPONENT,\n    COUNT(DISTINCT SSU.MIT_ID) AS total_supervisors,\n    SUM(SSU.NUM_OF_SUPERVISEES) AS total_supervisees\n  FROM ComponentDLCs AS CD\n  JOIN SPACE_SUPERVISOR_USAGE AS SSU\n    ON CD.DLC_KEY = SSU.DEPT_NAMES\n  GROUP BY\n    CD.BUILDING_COMPONENT\n)\nSELECT\n  SD.BUILDING_COMPONENT,\n  ANY_VALUE(B.BUILDING_NAME) AS building_name,\n  SUM(SD.ROOM_SQUARE_FOOTAGE) AS total_room_square_footage,\n  COUNT(DISTINCT SD.FLOOR_KEY) AS total_number_of_floors,\n  COUNT(DISTINCT SD.BUILDING_ROOM) AS total_number_of_rooms,\n  COUNT(DISTINCT SU.FCLT_ORGANIZATION_KEY) AS total_number_of_facility_organizations,\n  COALESCE(SA.total_supervisors, 0) AS total_number_of_supervisors,\n  COALESCE(SA.total_supervisees, 0) AS total_number_of_supervisees\nFROM SPACE_DETAIL AS SD\nLEFT JOIN BUILDINGS AS B\n  ON SD.BUILDING_KEY = B.BUILDING_KEY\nLEFT JOIN SPACE_UNIT AS SU\n  ON SD.SPACE_UNIT_KEY = SU.SPACE_UNIT_KEY\nLEFT JOIN SupervisorAggregates AS SA\n  ON SD.BUILDING_COMPONENT = SA.BUILDING_COMPONENT\nGROUP BY\n  SD.BUILDING_COMPONENT;"
    },
    {
        "db_id": "dw",
        "question": "What is the DLC key, name of the DLC, total number of floors, total square footage, total number of facility organizations, total number of supervisors, total number of supervisees, and total building heights for each DLC?",
        "predicted_sql": "SELECT\n  T1.DLC_KEY AS `DLC key`,\n  T2.DLC_NAME AS `name of the DLC`,\n  COUNT(DISTINCT T4.FLOOR) AS `total number of floors`,\n  SUM(T3.ROOM_SQUARE_FOOTAGE) AS `total square footage`,\n  COUNT(DISTINCT T1.FCLT_ORGANIZATION_KEY) AS `total number of facility organizations`,\n  COUNT(DISTINCT T6.MIT_ID) AS `total number of supervisors`,\n  SUM(T6.NUM_OF_SUPERVISEES) AS `total number of supervisees`,\n  SUM(DISTINCT CAST(T5.BUILDING_HEIGHT AS DECIMAL(10, 2))) AS `total building heights`\nFROM SPACE_UNIT AS T1\nLEFT JOIN FCLT_ORGANIZATION AS T2\n  ON T1.FCLT_ORGANIZATION_KEY = T2.FCLT_ORGANIZATION_KEY\nLEFT JOIN SPACE_DETAIL AS T3\n  ON T1.SPACE_UNIT_KEY = T3.SPACE_UNIT_KEY\nLEFT JOIN SPACE_FLOOR AS T4\n  ON T3.FLOOR_KEY = T4.FLOOR_KEY\nLEFT JOIN FCLT_BUILDING AS T5\n  ON T3.BUILDING_KEY = T5.FCLT_BUILDING_KEY\nLEFT JOIN SPACE_SUPERVISOR_USAGE AS T6\n  ON T1.DLC_KEY = T6.DEPT_NAMES\nGROUP BY\n  T1.DLC_KEY,\n  T2.DLC_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the department name, total number of types of TIP subjects, total number of enrolled students, the minimum and maximum rental new price for each department?",
        "predicted_sql": "SELECT\n  T1.OFFER_DEPT_NAME,\n  COUNT(DISTINCT T1.SUBJECT_ID),\n  SUM(T1.NUM_ENROLLED_STUDENTS),\n  MIN(T3.RENTAL_NEW_PRICE),\n  MAX(T3.RENTAL_NEW_PRICE)\nFROM TIP_SUBJECT_OFFERED AS T1\nJOIN TIP_DETAIL AS T2\n  ON T1.TIP_SUBJECT_OFFERED_KEY = T2.TIP_SUBJECT_OFFERED_KEY\nJOIN TIP_MATERIAL AS T3\n  ON T2.TIP_MATERIAL_KEY = T3.TIP_MATERIAL_KEY\nGROUP BY\n  T1.OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the details of courses offered in the current academic term, including the academic year, term code, hgn code, the total number of types of courses, the average number of units, the department name, the name and email address of the person in charge?",
        "predicted_sql": "SELECT\n  T2.ACADEMIC_YEAR,\n  T2.TERM_CODE,\n  T3.HGN_CODE,\n  COUNT(DISTINCT T2.SUBJECT_ID) AS total_course_types,\n  AVG(T2.TOTAL_UNITS) AS average_units,\n  T2.DEPARTMENT_NAME,\n  T4.FULL_NAME,\n  T4.EMAIL_ADDRESS\nFROM ACADEMIC_TERMS AS T1\nINNER JOIN COURSE_CATALOG_SUBJECT_OFFERED AS T2\n  ON T1.TERM_CODE = T2.TERM_CODE\nINNER JOIN SUBJECT_OFFERED AS T3\n  ON T2.SUBJECT_ID = T3.SUBJECT_ID AND T2.TERM_CODE = T3.TERM_CODE\nINNER JOIN EMPLOYEE_DIRECTORY AS T4\n  ON T3.RESPONSIBLE_FACULTY_MIT_ID = T4.MIT_ID\nWHERE\n  T1.IS_CURRENT_TERM = 'Y'\nGROUP BY\n  T2.ACADEMIC_YEAR,\n  T2.TERM_CODE,\n  T3.HGN_CODE,\n  T2.DEPARTMENT_NAME,\n  T4.FULL_NAME,\n  T4.EMAIL_ADDRESS;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve information about the IAP subjects, including their titles, categories, session titles, session start time, session end time, sponsor names, and total number of sessions.",
        "predicted_sql": "SELECT\n  T1.ACTIVITY_TITLE,\n  T2.IAP_CATEGORY_NAME,\n  T3.SESSION_TITLE,\n  T3.SESSION_START_TIME,\n  T3.SESSION_END_TIME,\n  T4.SPONSOR_NAME,\n  COUNT(T1.IAP_SUBJECT_SESSION_KEY) OVER (PARTITION BY T1.ACTIVITY_TITLE) AS total_sessions\nFROM IAP_SUBJECT_DETAIL AS T1\nINNER JOIN IAP_SUBJECT_CATEGORY AS T2\n  ON T1.IAP_SUBJECT_CATEGORY_KEY = T2.IAP_SUBJECT_CATEGORY_KEY\nINNER JOIN IAP_SUBJECT_SESSION AS T3\n  ON T1.IAP_SUBJECT_SESSION_KEY = T3.IAP_SUBJECT_SESSION_KEY\nINNER JOIN IAP_SUBJECT_SPONSOR AS T4\n  ON T1.IAP_SUBJECT_SPONSOR_KEY = T4.IAP_SUBJECT_SPONSOR_KEY;"
    },
    {
        "db_id": "dw",
        "question": "Show the department names, the corresponding SIS subject code, subject code descriptions, graduate level, and the total number of courses per department.",
        "predicted_sql": "SELECT\n  T1.DEPARTMENT_NAME,\n  T3.SUBJECT_CODE,\n  T3.SUBJECT_CODE_DESC,\n  T2.GRADUATE_LEVEL,\n  COUNT(DISTINCT T2.COURSE) AS total_courses\nFROM SIS_DEPARTMENT AS T1\nINNER JOIN SIS_COURSE_DESCRIPTION AS T2\n  ON T1.DEPARTMENT_CODE = T2.DEPARTMENT\nINNER JOIN SIS_SUBJECT_CODE AS T3\n  ON T2.COURSE = T3.COURSE_NUMBER\nGROUP BY\n  T1.DEPARTMENT_NAME,\n  T3.SUBJECT_CODE,\n  T3.SUBJECT_CODE_DESC,\n  T2.GRADUATE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "For each term, list the term code, the term description, whether the term is current or not, and the total number of types of CIS courses.",
        "predicted_sql": "SELECT\n  T1.TERM_CODE,\n  T1.TERM_DESCRIPTION,\n  T1.IS_CURRENT_TERM,\n  COUNT(DISTINCT T2.SUBJECT_ID) AS total_cis_course_types\nFROM ACADEMIC_TERMS_ALL AS T1\nLEFT JOIN CIS_COURSE_CATALOG AS T2\n  ON T1.TERM_CODE = T2.EFFECTIVE_TERM_CODE\nGROUP BY\n  T1.TERM_CODE,\n  T1.TERM_DESCRIPTION,\n  T1.IS_CURRENT_TERM;"
    },
    {
        "db_id": "dw",
        "question": "What is the author, school name, material status, total record counts, and total number of types of courses for each author and school?",
        "predicted_sql": "SELECT\n  T3.AUTHOR,\n  T4.SCHOOL_NAME,\n  T2.TIP_MATERIAL_STATUS,\n  SUM(T1.RECORD_COUNT),\n  COUNT(DISTINCT T1.SUBJECT_ID)\nFROM TIP_DETAIL AS T1\nINNER JOIN TIP_MATERIAL_STATUS AS T2\n  ON T1.TIP_MATERIAL_STATUS_KEY = T2.TIP_MATERIAL_STATUS_KEY\nINNER JOIN TIP_MATERIAL AS T3\n  ON T1.TIP_MATERIAL_KEY = T3.TIP_MATERIAL_KEY\nINNER JOIN TIP_SUBJECT_OFFERED AS T5\n  ON T1.TIP_SUBJECT_OFFERED_KEY = T5.TIP_SUBJECT_OFFERED_KEY\nINNER JOIN STUDENT_DEPARTMENT AS T4\n  ON T5.OFFER_DEPT_CODE = T4.DEPARTMENT_CODE\nGROUP BY\n  T3.AUTHOR,\n  T4.SCHOOL_NAME,\n  T2.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is the course number, subject title, material status, the total, min, and max new shelf price, the total, min, and max used shelf price, total number of schools and the total number of materials for each TIP subject and material status?",
        "predicted_sql": "SELECT\n  T3.COURSE_NUMBER,\n  T3.SUBJECT_TITLE,\n  T2.TIP_MATERIAL_STATUS,\n  SUM(T1.NEW_SHELF_PRICE) AS total_new_shelf_price,\n  MIN(T1.NEW_SHELF_PRICE) AS min_new_shelf_price,\n  MAX(T1.NEW_SHELF_PRICE) AS max_new_shelf_price,\n  SUM(T1.USED_SHELF_PRICE) AS total_used_shelf_price,\n  MIN(T1.USED_SHELF_PRICE) AS min_used_shelf_price,\n  MAX(T1.USED_SHELF_PRICE) AS max_used_shelf_price,\n  COUNT(DISTINCT T3.OFFER_SCHOOL_NAME) AS total_number_of_schools,\n  COUNT(DISTINCT T4.TIP_MATERIAL_KEY) AS total_number_of_materials\nFROM TIP_MATERIAL AS T1\nINNER JOIN TIP_DETAIL AS T4\n  ON T1.TIP_MATERIAL_KEY = T4.TIP_MATERIAL_KEY\nINNER JOIN TIP_MATERIAL_STATUS AS T2\n  ON T4.TIP_MATERIAL_STATUS_KEY = T2.TIP_MATERIAL_STATUS_KEY\nINNER JOIN TIP_SUBJECT_OFFERED AS T3\n  ON T4.TIP_SUBJECT_OFFERED_KEY = T3.TIP_SUBJECT_OFFERED_KEY\nGROUP BY\n  T3.COURSE_NUMBER,\n  T3.SUBJECT_TITLE,\n  T2.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is material status, the total number of materials, the total number of subjects, the total number of schools, and the most recent publication year for each material status?",
        "predicted_sql": "SELECT\n  T1.TIP_MATERIAL_STATUS,\n  COUNT(DISTINCT T2.TIP_MATERIAL_KEY),\n  COUNT(DISTINCT T2.SUBJECT_ID),\n  COUNT(DISTINCT T5.SCHOOL_NAME),\n  MAX(T3.YEAR)\nFROM TIP_MATERIAL_STATUS AS T1\nINNER JOIN TIP_DETAIL AS T2\n  ON T1.TIP_MATERIAL_STATUS_KEY = T2.TIP_MATERIAL_STATUS_KEY\nINNER JOIN TIP_MATERIAL AS T3\n  ON T2.TIP_MATERIAL_KEY = T3.TIP_MATERIAL_KEY\nINNER JOIN TIP_SUBJECT_OFFERED AS T4\n  ON T2.TIP_SUBJECT_OFFERED_KEY = T4.TIP_SUBJECT_OFFERED_KEY\nINNER JOIN STUDENT_DEPARTMENT AS T5\n  ON T4.OFFER_DEPT_CODE = T5.DEPARTMENT_CODE\nGROUP BY\n  T1.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is the term description, whether the term is current or not, total number of types of TIP subjects offered and materials needed, the minimum and maximum number of enrolled students, the total number of schools offering subjects, and the total number of records for each term code?",
        "predicted_sql": "SELECT\n  T1.TERM_DESCRIPTION,\n  T1.IS_CURRENT_TERM,\n  COUNT(DISTINCT T2.COURSE_NUMBER) AS total_tip_subjects_offered,\n  COUNT(DISTINCT T4.ISBN) AS total_materials_needed,\n  MIN(T2.NUM_ENROLLED_STUDENTS) AS min_enrolled_students,\n  MAX(T2.NUM_ENROLLED_STUDENTS) AS max_enrolled_students,\n  COUNT(DISTINCT T2.OFFER_SCHOOL_NAME) AS total_schools_offering_subjects,\n  SUM(T3.RECORD_COUNT) AS total_records_for_term\nFROM ACADEMIC_TERMS_ALL AS T1\nJOIN TIP_SUBJECT_OFFERED AS T2\n  ON T1.TERM_CODE = T2.TERM_CODE\nJOIN TIP_DETAIL AS T3\n  ON T2.TIP_SUBJECT_OFFERED_KEY = T3.TIP_SUBJECT_OFFERED_KEY\nJOIN TIP_MATERIAL AS T4\n  ON T3.TIP_MATERIAL_KEY = T4.TIP_MATERIAL_KEY\nGROUP BY\n  T1.TERM_CODE,\n  T1.TERM_DESCRIPTION,\n  T1.IS_CURRENT_TERM;"
    },
    {
        "db_id": "dw",
        "question": "List all buildings with their names, building numbers, building height, street address, city, state, HR department name, assignable square footage, total and average square footage, ordered in descending order of assignable, total, and average square footage.",
        "predicted_sql": "SELECT\n  T1.BUILDING_NAME,\n  T1.BUILDING_NUMBER,\n  T2.BUILDING_HEIGHT,\n  T1.BUILDING_STREET_ADDRESS,\n  T3.CITY,\n  T3.STATE,\n  GROUP_CONCAT(DISTINCT T5.HR_DEPARTMENT_NAME ORDER BY T5.HR_DEPARTMENT_NAME SEPARATOR ', ') AS HR_DEPARTMENT_NAME,\n  T1.BLDG_ASSIGNABLE_SQUARE_FOOTAGE,\n  SUM(CAST(T4.AREA AS DECIMAL(10, 2))) AS TotalSquareFootage,\n  AVG(CAST(T4.AREA AS DECIMAL(10, 2))) AS AverageSquareFootage\nFROM BUILDINGS AS T1\nLEFT JOIN FAC_BUILDING AS T2\n  ON T1.BUILDING_KEY = T2.FAC_BUILDING_KEY\nLEFT JOIN FAC_BUILDING_ADDRESS AS T3\n  ON T1.BUILDING_KEY = T3.BUILDING_KEY\n  AND T3.ADDRESS_PURPOSE = 'STREET'\nLEFT JOIN FAC_ROOMS AS T4\n  ON T1.BUILDING_KEY = T4.BUILDING_KEY\nLEFT JOIN FAC_ORGANIZATION AS T5\n  ON T4.ORGANIZATION_KEY = T5.ORGANIZATION_KEY\nGROUP BY\n  T1.BUILDING_KEY,\n  T1.BUILDING_NAME,\n  T1.BUILDING_NUMBER,\n  T2.BUILDING_HEIGHT,\n  T1.BUILDING_STREET_ADDRESS,\n  T3.CITY,\n  T3.STATE,\n  T1.BLDG_ASSIGNABLE_SQUARE_FOOTAGE\nORDER BY\n  T1.BLDG_ASSIGNABLE_SQUARE_FOOTAGE DESC,\n  TotalSquareFootage DESC,\n  AverageSquareFootage DESC;"
    },
    {
        "db_id": "dw",
        "question": "For the 2023 Fall term, what are the unique term descriptions, subject titles along with their prerequisites, total number of types of subjects per term code, instructor of this course, and the number of types of courses ever taught by the instructor?",
        "predicted_sql": "```mysql\nWITH InstructorCourseCounts AS (\n    SELECT\n        FALL_INSTRUCTORS,\n        COUNT(DISTINCT SUBJECT_ID) AS num_courses_ever_taught\n    FROM\n        COURSE_CATALOG_SUBJECT_OFFERED\n    WHERE\n        FALL_INSTRUCTORS IS NOT NULL AND FALL_INSTRUCTORS != ''\n    GROUP BY\n        FALL_INSTRUCTORS\n)\nSELECT\n    AT.TERM_DESCRIPTION,\n    CCSO.SUBJECT_TITLE,\n    CCSO.PREREQUISITES,\n    (\n        SELECT\n            COUNT(DISTINCT SUBJECT_ID)\n        FROM\n            COURSE_CATALOG_SUBJECT_OFFERED\n        WHERE\n            TERM_CODE = '2023FA'\n    ) AS total_types_of_subjects_in_2023_fall,\n    CCSO.FALL_INSTRUCTORS,\n    ICC.num_courses_ever_taught\nFROM\n    ACADEMIC_TERMS AS AT\nJOIN\n    COURSE_CATALOG_SUBJECT_OFFERED AS CCSO\nON\n    AT.TERM_CODE = CCSO.TERM_CODE\nLEFT JOIN\n    InstructorCourseCounts AS ICC\nON\n    CCSO.FALL_INSTRUCTORS = ICC.FALL_INSTRUCTORS\nWHERE\n    CCSO.TERM_CODE = '2023FA';"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the assignable floor area and building.",
        "predicted_sql": "SELECT\n  T1.ROOM_FULL_NAME,\n  T2.BUILDING_NAME,\n  T3.FLOOR,\n  T4.ORGANIZATION_NAME,\n  T4.HR_DEPARTMENT_NAME,\n  (CAST(T1.AREA AS DECIMAL (10, 2)) / CAST(T3.ASSIGNABLE_AREA AS DECIMAL (10, 2))) * 100 AS room_area_percentage_of_floor_area,\n  (CAST(T1.AREA AS DECIMAL (10, 2)) / CAST(T2.ASSIGNABLE_AREA AS DECIMAL (10, 2))) * 100 AS room_area_percentage_of_building_area\nFROM FAC_ROOMS AS T1\nINNER JOIN FAC_BUILDING AS T2\n  ON T1.BUILDING_KEY = T2.FAC_BUILDING_KEY\nINNER JOIN FAC_FLOOR AS T3\n  ON T1.FLOOR_KEY = T3.FLOOR_KEY\nINNER JOIN FAC_ORGANIZATION AS T4\n  ON T1.ORGANIZATION_KEY = T4.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the floor area and building.",
        "predicted_sql": "SELECT\n  T1.ROOM_FULL_NAME,\n  T2.BUILDING_NAME,\n  T3.FLOOR,\n  T4.ORGANIZATION_NAME,\n  T4.HR_DEPARTMENT_NAME,\n  (\n    CAST(T1.AREA AS DECIMAL(10, 2)) / SUM(CAST(T1.AREA AS DECIMAL(10, 2))) OVER (PARTITION BY\n      T1.BUILDING_KEY,\n      T1.FLOOR_KEY\n    )\n  ) * 100 AS Room_Area_Percentage_Of_Floor,\n  (\n    CAST(T1.AREA AS DECIMAL(10, 2)) / SUM(CAST(T1.AREA AS DECIMAL(10, 2))) OVER (PARTITION BY\n      T1.BUILDING_KEY\n    )\n  ) * 100 AS Room_Area_Percentage_Of_Building\nFROM FAC_ROOMS AS T1\nJOIN FAC_BUILDING AS T2\n  ON T1.BUILDING_KEY = T2.FAC_BUILDING_KEY\nJOIN FAC_FLOOR AS T3\n  ON T1.BUILDING_KEY = T3.BUILDING_KEY AND T1.FLOOR_KEY = T3.FLOOR_KEY\nLEFT JOIN FAC_ORGANIZATION AS T4\n  ON T1.ORGANIZATION_KEY = T4.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What are the academic year, and instructors names for courses offered in the academic year 2022, along with the total number of types of courses per instructor?",
        "predicted_sql": "SELECT\n  T1.ACADEMIC_YEAR,\n  T3.FULL_NAME,\n  COUNT(DISTINCT T2.COURSE_NUMBER) AS total_course_types\nFROM ACADEMIC_TERMS_ALL AS T1\nINNER JOIN SUBJECT_OFFERED AS T2\n  ON T1.TERM_CODE = T2.TERM_CODE\nINNER JOIN EMPLOYEE_DIRECTORY AS T3\n  ON T2.RESPONSIBLE_FACULTY_MIT_ID = T3.MIT_ID\nWHERE\n  T1.ACADEMIC_YEAR = '2022'\nGROUP BY\n  T1.ACADEMIC_YEAR,\n  T3.FULL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the building names, department names, organizations, their highest and lowest floor number, along with the total number of rooms per each building key?",
        "predicted_sql": "SELECT\n  T1.BUILDING_NAME,\n  T3.HR_DEPARTMENT_NAME,\n  T3.ORGANIZATION,\n  MIN(T4.LEVEL_ID) AS highest_floor_number,\n  MAX(T4.LEVEL_ID) AS lowest_floor_number,\n  COUNT(T2.FAC_ROOM_KEY) AS total_rooms_per_building_key\nFROM FAC_BUILDING AS T1\nINNER JOIN FAC_ROOMS AS T2\n  ON T1.FAC_BUILDING_KEY = T2.BUILDING_KEY\nINNER JOIN FAC_ORGANIZATION AS T3\n  ON T2.ORGANIZATION_KEY = T3.ORGANIZATION_KEY\nINNER JOIN FAC_FLOOR AS T4\n  ON T2.FLOOR_KEY = T4.FLOOR_KEY\nGROUP BY\n  T1.FAC_BUILDING_KEY,\n  T1.BUILDING_NAME,\n  T3.HR_DEPARTMENT_NAME,\n  T3.ORGANIZATION;"
    },
    {
        "db_id": "dw",
        "question": "Provide the complete information for students with the first name Kevin, including their full names, email addresses, department names, department phone numbers, school names, and the total student count per department and school. If a student is associated with more than one department, list a separate row for each department.",
        "predicted_sql": "SELECT\n  T1.FULL_NAME,\n  T1.EMAIL_ADDRESS,\n  T2.DEPARTMENT_NAME,\n  T3.DEPARTMENT_PHONE_NUMBER,\n  T2.SCHOOL_NAME,\n  COUNT(T1.EMAIL_ADDRESS) OVER (PARTITION BY T2.DEPARTMENT_NAME) AS student_count_per_department,\n  COUNT(T1.EMAIL_ADDRESS) OVER (PARTITION BY T2.SCHOOL_NAME) AS student_count_per_school\nFROM MIT_STUDENT_DIRECTORY AS T1\nINNER JOIN SIS_DEPARTMENT AS T2\n  ON T1.DEPARTMENT = T2.DEPARTMENT_CODE\nINNER JOIN SIS_ADMIN_DEPARTMENT AS T3\n  ON T2.DEPARTMENT_CODE = T3.SIS_ADMIN_DEPARTMENT_CODE\nWHERE\n  T1.FIRST_NAME = 'Kevin';"
    },
    {
        "db_id": "dw",
        "question": "What are the unique titles of subjects offered in the fall term along with their instructor names, instructor emails, and the total number of types of subjects per instructor?",
        "predicted_sql": "SELECT DISTINCT\n  T1.SUBJECT_TITLE,\n  T2.FULL_NAME,\n  T2.EMAIL_ADDRESS,\n  COUNT(DISTINCT T1.SUBJECT_ID) OVER (PARTITION BY T1.RESPONSIBLE_FACULTY_MIT_ID) AS total_subjects_per_instructor\nFROM COURSE_CATALOG_SUBJECT_OFFERED AS T1\nJOIN EMPLOYEE_DIRECTORY AS T2\n  ON T1.RESPONSIBLE_FACULTY_MIT_ID = T2.MIT_ID\nWHERE\n  T1.IS_OFFERED_FALL_TERM = 'Y';"
    },
    {
        "db_id": "dw",
        "question": "List the building names, names of HR departments occupying them, the total gross square footage, the total and average assignable square footage, and the built year per building key.",
        "predicted_sql": "SELECT\n  T1.BUILDING_NAME,\n  GROUP_CONCAT(DISTINCT T4.HR_DEPARTMENT_NAME ORDER BY T4.HR_DEPARTMENT_NAME SEPARATOR ', ') AS HR_Department_Names,\n  MAX(T1.BLDG_GROSS_SQUARE_FOOTAGE) AS Total_Gross_Square_Footage,\n  MAX(T1.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) AS Total_Assignable_Square_Footage,\n  MAX(T1.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) AS Average_Assignable_Square_Footage,\n  YEAR(STR_TO_DATE(T2.DATE_BUILT, '%m/%d/%Y')) AS Built_Year\nFROM BUILDINGS AS T1\nJOIN FAC_BUILDING AS T2\n  ON T1.BUILDING_KEY = T2.FAC_BUILDING_KEY\nLEFT JOIN FAC_ROOMS AS T3\n  ON T1.BUILDING_KEY = T3.BUILDING_KEY\nLEFT JOIN FAC_ORGANIZATION AS T4\n  ON T3.ORGANIZATION_KEY = T4.ORGANIZATION_KEY\nGROUP BY\n  T1.BUILDING_KEY,\n  T1.BUILDING_NAME,\n  T2.DATE_BUILT\nORDER BY\n  T1.BUILDING_KEY;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve the titles of subjects offered in the summer term along with their descriptions, responsible faculty names, email address, building name, room name, floor level, building street address, and the total number of types of courses per departmnet.",
        "predicted_sql": "SELECT\n  T1.SUBJECT_TITLE,\n  T1.SUBJECT_DESCRIPTION,\n  T1.RESPONSIBLE_FACULTY_NAME,\n  T3.EMAIL_ADDRESS,\n  T5.BUILDING_NAME,\n  T4.ROOM_FULL_NAME,\n  T6.LEVEL_ID AS floor_level,\n  T5.BUILDING_STREET_ADDRESS,\n  COUNT(DISTINCT T1.SUBJECT_ID) OVER (PARTITION BY T1.DEPARTMENT_CODE) AS total_course_types_per_department\nFROM COURSE_CATALOG_SUBJECT_OFFERED AS T1\nINNER JOIN ACADEMIC_TERMS AS T2\n  ON T1.TERM_CODE = T2.TERM_CODE\nLEFT JOIN EMPLOYEE_DIRECTORY AS T3\n  ON T1.RESPONSIBLE_FACULTY_MIT_ID = T3.MIT_ID\nLEFT JOIN FAC_ROOMS AS T4\n  ON T1.MEET_PLACE = T4.FAC_ROOM_KEY\nLEFT JOIN BUILDINGS AS T5\n  ON T4.BUILDING_KEY = T5.BUILDING_KEY\nLEFT JOIN FAC_FLOOR AS T6\n  ON T4.FLOOR_KEY = T6.FLOOR_KEY\nWHERE\n  T2.TERM_DESCRIPTION LIKE '%Summer Term%';"
    },
    {
        "db_id": "dw",
        "question": "For each term code, list the term description, attribute desciption, department name, school name, and the number of subjects in the area of humanities, arts and social sciences.",
        "predicted_sql": "SELECT\n  T1.TERM_CODE,\n  T1.TERM_DESCRIPTION,\n  T3.HASS_ATTRIBUTE_DESC,\n  T4.DEPARTMENT_NAME,\n  T4.SCHOOL_NAME,\n  COUNT(T3.SUBJECT_ID) AS num_subjects\nFROM ACADEMIC_TERMS_ALL AS T1\nINNER JOIN COURSE_CATALOG_SUBJECT_OFFERED AS T3\n  ON T1.TERM_CODE = T3.TERM_CODE\nINNER JOIN SIS_DEPARTMENT AS T4\n  ON T3.DEPARTMENT_CODE = T4.DEPARTMENT_CODE\nINNER JOIN CIS_HASS_ATTRIBUTE AS T2\n  ON T3.HASS_ATTRIBUTE = T2.HASS_ATTRIBUTE\nWHERE\n  T2.CIS_ATTRIBUTE_GROUP = 'H'\nGROUP BY\n  T1.TERM_CODE,\n  T1.TERM_DESCRIPTION,\n  T3.HASS_ATTRIBUTE_DESC,\n  T4.DEPARTMENT_NAME,\n  T4.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List building names, their height, street address, city, state, postal code, their gross and assignable square footage, the smallest and largest floor level and the total area of all rooms for each building key.",
        "predicted_sql": "WITH FloorStats AS (\n    SELECT\n        BUILDING_KEY,\n        MIN(CAST(LEVEL_ID AS UNSIGNED)) AS smallest_floor_level,\n        MAX(CAST(LEVEL_ID AS UNSIGNED)) AS largest_floor_level\n    FROM FAC_FLOOR\n    GROUP BY BUILDING_KEY\n),\nRoomAreaStats AS (\n    SELECT\n        BUILDING_KEY,\n        SUM(CAST(AREA AS DECIMAL(10, 2))) AS total_room_area\n    FROM FAC_ROOMS\n    GROUP BY BUILDING_KEY\n)\nSELECT\n    fb.BUILDING_NAME AS `building names`,\n    fb.BUILDING_HEIGHT AS `height`,\n    b.BUILDING_STREET_ADDRESS AS `street address`,\n    fba.CITY AS `city`,\n    fba.STATE AS `state`,\n    fba.POSTAL_CODE AS `postal code`,\n    CAST(fb.EXT_GROSS_AREA AS DECIMAL(15, 2)) AS `gross square footage`,\n    CAST(fb.ASSIGNABLE_AREA AS DECIMAL(15, 2)) AS `assignable square footage`,\n    fs.smallest_floor_level AS `smallest floor level`,\n    fs.largest_floor_level AS `largest floor level`,\n    ras.total_room_area AS `total area of all rooms`\nFROM\n    FAC_BUILDING AS fb\nLEFT JOIN\n    BUILDINGS AS b\n    ON fb.FAC_BUILDING_KEY = b.BUILDING_KEY\nLEFT JOIN\n    FAC_BUILDING_ADDRESS AS fba\n    ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY AND fba.ADDRESS_PURPOSE = 'STREET'\nLEFT JOIN\n    FloorStats AS fs\n    ON fb.FAC_BUILDING_KEY = fs.BUILDING_KEY\nLEFT JOIN\n    RoomAreaStats AS ras\n    ON fb.FAC_BUILDING_KEY = ras.BUILDING_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What is the category title, version, department name, school name, total number of courses for each course level, and the total number of degree-granting courses for each CIP category code?",
        "predicted_sql": "SELECT\n  T1.CATEGORY_TITLE,\n  T1.VERSION,\n  T3.DEPARTMENT_NAME,\n  T3.SCHOOL_NAME,\n  SUM(CASE WHEN T2.COURSE_LEVEL = 'G' THEN 1 ELSE 0 END) AS Graduate_Courses,\n  SUM(CASE WHEN T2.COURSE_LEVEL = 'U' THEN 1 ELSE 0 END) AS Undergraduate_Courses,\n  SUM(CASE WHEN T2.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS Degree_Granting_Courses\nFROM CIP AS T1\nINNER JOIN SIS_COURSE_DESCRIPTION AS T2\n  ON T1.PROGRAM_CODE = T2.CIP_PROGRAM_CODE\nINNER JOIN SIS_DEPARTMENT AS T3\n  ON T2.DEPARTMENT = T3.DEPARTMENT_CODE\nGROUP BY\n  T1.CATEGORY_CODE,\n  T1.CATEGORY_TITLE,\n  T1.VERSION,\n  T3.DEPARTMENT_NAME,\n  T3.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library materials, the minimum and maximum publication years, and the total number of materials status for each course name?",
        "predicted_sql": "SELECT\n  T1.COURSE_NAME,\n  COUNT(DISTINCT T3.CATALOG_SYSTEM_NUMBER) AS total_library_materials,\n  MIN(T3.CATALOG_YEAR) AS min_publication_year,\n  MAX(T3.CATALOG_YEAR) AS max_publication_year,\n  COUNT(T4.LIBRARY_MATERIAL_STATUS) AS total_materials_status\nFROM LIBRARY_COURSE_INSTRUCTOR AS T1\nJOIN LIBRARY_RESERVE_MATRL_DETAIL AS T2\n  ON T1.LIBRARY_COURSE_INSTRUCTOR_KEY = T2.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN LIBRARY_RESERVE_CATALOG AS T3\n  ON T2.LIBRARY_RESERVE_CATALOG_KEY = T3.LIBRARY_RESERVE_CATALOG_KEY\nJOIN LIBRARY_MATERIAL_STATUS AS T4\n  ON T2.LIBRARY_MATERIAL_STATUS_KEY = T4.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY\n  T1.COURSE_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library reserve materials, the minimum and maximum publication years, and the total number of enrolled students for each course instructor?",
        "predicted_sql": "WITH InstructorSubjectEnrollment AS (\n  SELECT\n    T1.INSTRUCTOR_NAME,\n    SUM(T4.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\n  FROM LIBRARY_COURSE_INSTRUCTOR AS T1\n  JOIN (\n    SELECT DISTINCT\n      LIBRARY_COURSE_INSTRUCTOR_KEY,\n      LIBRARY_SUBJECT_OFFERED_KEY\n    FROM LIBRARY_RESERVE_MATRL_DETAIL\n  ) AS T2_Distinct\n    ON T1.LIBRARY_COURSE_INSTRUCTOR_KEY = T2_Distinct.LIBRARY_COURSE_INSTRUCTOR_KEY\n  JOIN LIBRARY_SUBJECT_OFFERED AS T4\n    ON T2_Distinct.LIBRARY_SUBJECT_OFFERED_KEY = T4.LIBRARY_SUBJECT_OFFERED_KEY\n  GROUP BY\n    T1.INSTRUCTOR_NAME\n)\nSELECT\n  T1.INSTRUCTOR_NAME,\n  COUNT(DISTINCT T3.CATALOG_SYSTEM_NUMBER) AS total_materials,\n  MIN(CAST(T3.CATALOG_YEAR AS UNSIGNED)) AS min_publication_year,\n  MAX(CAST(T3.CATALOG_YEAR AS UNSIGNED)) AS max_publication_year,\n  ISE.total_enrolled_students\nFROM LIBRARY_COURSE_INSTRUCTOR AS T1\nJOIN LIBRARY_RESERVE_MATRL_DETAIL AS T2\n  ON T1.LIBRARY_COURSE_INSTRUCTOR_KEY = T2.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN LIBRARY_RESERVE_CATALOG AS T3\n  ON T2.LIBRARY_RESERVE_CATALOG_KEY = T3.LIBRARY_RESERVE_CATALOG_KEY\nJOIN InstructorSubjectEnrollment AS ISE\n  ON T1.INSTRUCTOR_NAME = ISE.INSTRUCTOR_NAME\nGROUP BY\n  T1.INSTRUCTOR_NAME,\n  ISE.total_enrolled_students;"
    },
    {
        "db_id": "dw",
        "question": "What is the material status, term description, total number of courses and materials, occurences in departments and school, and the total number of instructors for each library material status code and term code?",
        "predicted_sql": "SELECT\n  T1.LIBRARY_MATERIAL_STATUS,\n  T6.TERM_DESCRIPTION,\n  T1.LIBRARY_MATERIAL_STATUS_CODE,\n  T4.TERM_CODE,\n  COUNT(DISTINCT T4.COURSE_NUMBER) AS total_number_of_courses,\n  COUNT(DISTINCT T3.CATALOG_SYSTEM_NUMBER) AS total_number_of_materials,\n  COUNT(DISTINCT T4.OFFER_DEPT_CODE) AS occurrences_in_departments,\n  COUNT(DISTINCT T4.OFFER_SCHOOL_NAME) AS occurrences_in_school,\n  COUNT(DISTINCT T2.INSTRUCTOR_NAME) AS total_number_of_instructors\nFROM LIBRARY_RESERVE_MATRL_DETAIL AS T5\nJOIN LIBRARY_MATERIAL_STATUS AS T1\n  ON T5.LIBRARY_MATERIAL_STATUS_KEY = T1.LIBRARY_MATERIAL_STATUS_KEY\nJOIN LIBRARY_SUBJECT_OFFERED AS T4\n  ON T5.LIBRARY_SUBJECT_OFFERED_KEY = T4.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN LIBRARY_COURSE_INSTRUCTOR AS T2\n  ON T5.LIBRARY_COURSE_INSTRUCTOR_KEY = T2.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN LIBRARY_RESERVE_CATALOG AS T3\n  ON T5.LIBRARY_RESERVE_CATALOG_KEY = T3.LIBRARY_RESERVE_CATALOG_KEY\nJOIN ACADEMIC_TERMS_ALL AS T6\n  ON T4.TERM_CODE = T6.TERM_CODE\nGROUP BY\n  T1.LIBRARY_MATERIAL_STATUS_CODE,\n  T4.TERM_CODE,\n  T1.LIBRARY_MATERIAL_STATUS,\n  T6.TERM_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "For building 36, list all space units, their floor and building name, building street address, their space usage, and the number of organizations and space units on the same building and floor.",
        "predicted_sql": "SELECT\n  T3.SPACE_UNIT,\n  T5.FLOOR,\n  T1.BUILDING_NAME,\n  T1.BUILDING_STREET_ADDRESS,\n  T6.SPACE_USAGE,\n  COUNT(DISTINCT T4.FCLT_ORGANIZATION_KEY) OVER (PARTITION BY T1.BUILDING_KEY, T5.FLOOR_KEY) AS num_organizations_on_floor,\n  COUNT(DISTINCT T3.SPACE_UNIT_KEY) OVER (PARTITION BY T1.BUILDING_KEY, T5.FLOOR_KEY) AS num_space_units_on_floor\nFROM BUILDINGS AS T1\nJOIN SPACE_DETAIL AS T2\n  ON T1.BUILDING_KEY = T2.BUILDING_KEY\nJOIN SPACE_UNIT AS T3\n  ON T2.SPACE_UNIT_KEY = T3.SPACE_UNIT_KEY\nJOIN FCLT_ORGANIZATION AS T4\n  ON T3.FCLT_ORGANIZATION_KEY = T4.FCLT_ORGANIZATION_KEY\nJOIN SPACE_FLOOR AS T5\n  ON T2.FLOOR_KEY = T5.FLOOR_KEY\nJOIN SPACE_USAGE AS T6\n  ON T2.SPACE_USAGE_KEY = T6.SPACE_USAGE_KEY\nWHERE\n  T1.BUILDING_NUMBER = '36';"
    },
    {
        "db_id": "dw",
        "question": "For each distinct mailing list containing more than 1000 people and with a name starting with A (case insensitive), provide its name, whether it is a mailing list, whether it is a moira group, whether it is a NFS group, the owner of the mailing list, and the number of people in the list.",
        "predicted_sql": "SELECT\n  T1.MOIRA_LIST_NAME AS name,\n  T1.IS_MOIRA_MAILING_LIST AS 'whether it is a mailing list',\n  T1.IS_MOIRA_GROUP AS 'whether it is a moira group',\n  T1.IS_NFS_GROUP AS 'whether it is a NFS group',\n  T3.OWNER AS 'the owner of the mailing list',\n  COUNT(DISTINCT T2.MOIRA_LIST_MEMBER) AS 'the number of people in the list'\nFROM MOIRA_LIST AS T1\nINNER JOIN MOIRA_LIST_DETAIL AS T2\n  ON T1.MOIRA_LIST_KEY = T2.MOIRA_LIST_KEY\nINNER JOIN MOIRA_LIST_OWNER AS T3\n  ON T2.MOIRA_LIST_OWNER_KEY = T3.MOIRA_LIST_OWNER_KEY\nWHERE\n  LOWER(T1.MOIRA_LIST_NAME) LIKE 'a%'\nGROUP BY\n  T1.MOIRA_LIST_KEY,\n  T1.MOIRA_LIST_NAME,\n  T1.IS_MOIRA_MAILING_LIST,\n  T1.IS_MOIRA_GROUP,\n  T1.IS_NFS_GROUP,\n  T3.OWNER\nHAVING\n  COUNT(DISTINCT T2.MOIRA_LIST_MEMBER) > 1000;"
    },
    {
        "db_id": "dw",
        "question": "List the mailing lists with the largest number of members and the least number of members, including their names, owners, public status, hidden status, and number of members in the list. If a mailing list has multiple owners, create a separate entry for each owner. Similarly, if multiple lists share the minimum or maximum member count, include all those lists.",
        "predicted_sql": "WITH ListMemberCounts AS (\n  SELECT\n    MOIRA_LIST_KEY,\n    COUNT(MOIRA_LIST_MEMBER) AS member_count\n  FROM MOIRA_LIST_DETAIL\n  GROUP BY\n    MOIRA_LIST_KEY\n), ListOwners AS (\n  SELECT DISTINCT\n    mld.MOIRA_LIST_KEY,\n    mlo.OWNER\n  FROM MOIRA_LIST_DETAIL AS mld\n  JOIN MOIRA_LIST_OWNER AS mlo\n    ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY\n), MailingListDetailsWithOwnersAndCounts AS (\n  SELECT\n    ml.MOIRA_LIST_NAME,\n    lo.OWNER,\n    ml.IS_PUBLIC,\n    ml.IS_HIDDEN,\n    lmc.member_count\n  FROM MOIRA_LIST AS ml\n  JOIN ListMemberCounts AS lmc\n    ON ml.MOIRA_LIST_KEY = lmc.MOIRA_LIST_KEY\n  JOIN ListOwners AS lo\n    ON ml.MOIRA_LIST_KEY = lo.MOIRA_LIST_KEY\n  WHERE\n    ml.IS_MOIRA_MAILING_LIST = 'Y'\n), MinMaxMemberCounts AS (\n  SELECT\n    MIN(member_count) AS min_val,\n    MAX(member_count) AS max_val\n  FROM MailingListDetailsWithOwnersAndCounts\n)\nSELECT\n  mld.MOIRA_LIST_NAME,\n  mld.OWNER,\n  mld.IS_PUBLIC,\n  mld.IS_HIDDEN,\n  mld.member_count\nFROM MailingListDetailsWithOwnersAndCounts AS mld, MinMaxMemberCounts AS mmc\nWHERE\n  mld.member_count = mmc.min_val OR mld.member_count = mmc.max_val\nORDER BY\n  mld.MOIRA_LIST_NAME,\n  mld.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with C (case insensitive) and containing faculty who teach courses in the summer in financial aid years after 2001, provide the name of the list, the number of people in the list, and the number of faculty in the list.",
        "predicted_sql": "WITH SummerFaculty AS (\n  SELECT DISTINCT\n      CCSO.RESPONSIBLE_FACULTY_MIT_ID AS mit_id\n  FROM\n      COURSE_CATALOG_SUBJECT_OFFERED AS CCSO\n  JOIN\n      ACADEMIC_TERMS AS AT ON CCSO.TERM_CODE = AT.TERM_CODE\n  WHERE\n      CCSO.IS_OFFERED_SUMMER_TERM = 'Y'\n      AND AT.FINANCIAL_AID_YEAR > '2001'\n      AND CCSO.RESPONSIBLE_FACULTY_MIT_ID IS NOT NULL\n)\nSELECT\n  ML.MOIRA_LIST_NAME,\n  COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER) AS number_of_people_in_list,\n  COUNT(DISTINCT SF.mit_id) AS number_of_faculty_in_list\nFROM\n  MOIRA_LIST AS ML\nJOIN\n  MOIRA_LIST_DETAIL AS MLD ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\nLEFT JOIN\n  SummerFaculty AS SF ON MLD.MOIRA_LIST_MEMBER_MIT_ID = SF.mit_id\nWHERE\n  LOWER(ML.MOIRA_LIST_NAME) LIKE 'c%'\nGROUP BY\n  ML.MOIRA_LIST_NAME\nHAVING\n  COUNT(DISTINCT SF.mit_id) > 0;"
    },
    {
        "db_id": "dw",
        "question": "Regarding the mailing list about duo users, provide the number of students in this list, and the number of departments and schools associated with these students.",
        "predicted_sql": "SELECT\n  COUNT(DISTINCT T3.MIT_ID) AS number_of_students,\n  COUNT(DISTINCT T4.DEPARTMENT) AS number_of_departments,\n  COUNT(DISTINCT T5.SCHOOL_CODE) AS number_of_schools\nFROM MOIRA_LIST AS T1\nJOIN MOIRA_LIST_DETAIL AS T2\n  ON T1.MOIRA_LIST_KEY = T2.MOIRA_LIST_KEY\nJOIN SE_PERSON AS T3\n  ON T2.MOIRA_LIST_MEMBER_MIT_ID = T3.MIT_ID\nJOIN MIT_STUDENT_DIRECTORY AS T4\n  ON T3.FULL_NAME = T4.FULL_NAME\nJOIN SIS_DEPARTMENT AS T5\n  ON T4.DEPARTMENT = T5.DEPARTMENT_CODE\nWHERE\n  T1.MOIRA_LIST_NAME = 'duo users' AND T3.EMPLOYEE_TYPE = 'Student';"
    },
    {
        "db_id": "dw",
        "question": "For faculty who are responsible for courses in 2023 fall term, list the name of mailing lists with ten members that they subscribe to, the number of faculty in these lists, and the number of courses associated with those faculty.",
        "predicted_sql": "SELECT\n  ML.MOIRA_LIST_NAME,\n  COUNT(DISTINCT F23FA.faculty_mit_id) AS num_faculty_in_list,\n  COUNT(DISTINCT CCS.SUBJECT_TITLE) AS num_courses_associated\nFROM MOIRA_LIST AS ML\nJOIN (\n  SELECT\n    MLD_SUB.MOIRA_LIST_KEY\n  FROM MOIRA_LIST_DETAIL AS MLD_SUB\n  JOIN MOIRA_LIST AS ML_SUB\n    ON MLD_SUB.MOIRA_LIST_KEY = ML_SUB.MOIRA_LIST_KEY\n  WHERE\n    ML_SUB.IS_MOIRA_MAILING_LIST = 'Y'\n  GROUP BY\n    MLD_SUB.MOIRA_LIST_KEY\n  HAVING\n    COUNT(DISTINCT MLD_SUB.MOIRA_LIST_MEMBER) = 10\n) AS TenMemberLists\n  ON ML.MOIRA_LIST_KEY = TenMemberLists.MOIRA_LIST_KEY\nJOIN MOIRA_LIST_DETAIL AS MLD\n  ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\nJOIN (\n  SELECT DISTINCT\n    CCSO_SUB.RESPONSIBLE_FACULTY_MIT_ID AS faculty_mit_id,\n    ED_SUB.KRB_NAME AS faculty_krb_name\n  FROM COURSE_CATALOG_SUBJECT_OFFERED AS CCSO_SUB\n  JOIN EMPLOYEE_DIRECTORY AS ED_SUB\n    ON CCSO_SUB.RESPONSIBLE_FACULTY_MIT_ID = ED_SUB.MIT_ID\n  WHERE\n    CCSO_SUB.TERM_CODE = '2023FA'\n) AS F23FA\n  ON MLD.MOIRA_LIST_MEMBER = F23FA.faculty_krb_name\nJOIN COURSE_CATALOG_SUBJECT_OFFERED AS CCS\n  ON F23FA.faculty_mit_id = CCS.RESPONSIBLE_FACULTY_MIT_ID\nWHERE\n  CCS.TERM_CODE = '2023FA'\nGROUP BY\n  ML.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each course instructor in the 'keeper-zephyr' mailing list, provide the name of mailing lists they subscribe to, instructor name, earliest and latest publication years, and total number of enrolled students.",
        "predicted_sql": "```mysql\nWITH KeeperZephyrMembers AS (\n  SELECT\n    mld.MOIRA_LIST_MEMBER_FULL_NAME AS instructor_full_name\n  FROM MOIRA_LIST AS ml\n  JOIN MOIRA_LIST_DETAIL AS mld\n    ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n  WHERE\n    ml.MOIRA_LIST_NAME = 'keeper-zephyr'\n), AggregatedInstructorDetails AS (\n  SELECT\n    kzm.instructor_full_name,\n    MIN(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS earliest_publication_year,\n    MAX(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS latest_publication_year,\n    SUM(lso.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\n  FROM KeeperZephyrMembers AS kzm\n  JOIN LIBRARY_COURSE_INSTRUCTOR AS lci\n    ON kzm.instructor_full_name = lci.INSTRUCTOR_NAME\n  JOIN LIBRARY_RESERVE_MATRL_DETAIL AS lrmd\n    ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\n  JOIN LIBRARY_RESERVE_CATALOG AS lrc\n    ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\n  JOIN LIBRARY_SUBJECT_OFFERED AS lso\n    ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\n  GROUP BY\n    kzm.instructor_full_name\n)\nSELECT\n  GROUP_CONCAT(DISTINCT ml.MOIRA_LIST_NAME ORDER BY ml.MOIRA_LIST_NAME SEPARATOR ', ') AS mailing_list_names,\n  aid.instructor_full_name AS instructor_name,\n  aid.earliest_publication_year,\n  aid.latest_publication_year,\n  aid.total_enrolled_students\nFROM AggregatedInstructorDetails AS aid\nJOIN MOIRA_LIST_DETAIL AS mld\n  ON aid.instructor_full_name = mld.MOIRA_LIST_MEMBER_FULL_NAME\nJOIN MOIRA_LIST AS ml\n  ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nGROUP BY\n  aid.instructor_full_name,\n  aid.earliest_publication_year,\n  aid.latest_publication_year,\n  aid.total_enrolled_students;"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list with a name beginning with R (case insensitive), and that Professor Ayden Hopkins is subscribed to, list its name, description, owner, number of people in the list, and number of tenured faculty in the list.",
        "predicted_sql": "SELECT\n  ML.MOIRA_LIST_NAME,\n  ML.MOIRA_LIST_DESCRIPTION,\n  GROUP_CONCAT(DISTINCT MLO.OWNER ORDER BY MLO.OWNER SEPARATOR ', ') AS owner,\n  COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER) AS number_of_people,\n  COUNT(DISTINCT CASE WHEN SP.PAYROLL_RANK LIKE '%Professor%' OR SP.PAYROLL_RANK LIKE '%Associate Professor%' THEN SP.MIT_ID ELSE NULL END) AS number_of_tenured_faculty\nFROM MOIRA_LIST AS ML\nJOIN MOIRA_LIST_DETAIL AS MLD\n  ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\nLEFT JOIN MOIRA_LIST_OWNER AS MLO\n  ON MLD.MOIRA_LIST_OWNER_KEY = MLO.MOIRA_LIST_OWNER_KEY\nLEFT JOIN SE_PERSON AS SP\n  ON MLD.MOIRA_LIST_MEMBER_MIT_ID = SP.MIT_ID\nWHERE\n  LOWER(ML.MOIRA_LIST_NAME) LIKE 'r%' AND ML.IS_MOIRA_MAILING_LIST = 'Y' AND ML.MOIRA_LIST_KEY IN (\n    SELECT DISTINCT\n      MLD_AH.MOIRA_LIST_KEY\n    FROM MOIRA_LIST_DETAIL AS MLD_AH\n    JOIN SE_PERSON AS SP_AH\n      ON MLD_AH.MOIRA_LIST_MEMBER_MIT_ID = SP_AH.MIT_ID\n    WHERE\n      SP_AH.FULL_NAME = 'Hopkins, Ayden'\n  )\nGROUP BY\n  ML.MOIRA_LIST_KEY,\n  ML.MOIRA_LIST_NAME,\n  ML.MOIRA_LIST_DESCRIPTION\nORDER BY\n  ML.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For the email list with name 'date-destiny', list the name of the list, department name, the number of students from the Management department, and the percentage of students who are from the Management department, rounded to two decimal places.",
        "predicted_sql": "SELECT\n  ML.MOIRA_LIST_NAME,\n  'Management' AS department_name,\n  COUNT(DISTINCT CASE WHEN SAD.SIS_ADMIN_DEPARTMENT_NAME = 'Management' THEN MLD.MOIRA_LIST_MEMBER END) AS num_management_students,\n  ROUND(\n    COUNT(DISTINCT CASE WHEN SAD.SIS_ADMIN_DEPARTMENT_NAME = 'Management' THEN MLD.MOIRA_LIST_MEMBER END) * 100.0 / NULLIF(COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER), 0),\n    2\n  ) AS percentage_management_students\nFROM MOIRA_LIST AS ML\nJOIN MOIRA_LIST_DETAIL AS MLD\n  ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\nJOIN SE_PERSON AS SP\n  ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME\nJOIN MIT_STUDENT_DIRECTORY AS MSD\n  ON SP.FULL_NAME = MSD.FULL_NAME\nJOIN SIS_ADMIN_DEPARTMENT AS SAD\n  ON MSD.DEPARTMENT = SAD.SIS_ADMIN_DEPARTMENT_CODE\nWHERE\n  ML.MOIRA_LIST_NAME = 'date-destiny'\nGROUP BY\n  ML.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For the building with the most floors, list the building name and the names of the mailing lists staring with a (case insensitive) that the building employees with kerberos starting with c (case insensitive) subscribe to.",
        "predicted_sql": "SELECT DISTINCT\n  T2.BUILDING_NAME,\n  T5.MOIRA_LIST_NAME\nFROM EMPLOYEE_DIRECTORY AS T1\nJOIN FAC_ROOMS AS T3\n  ON T1.OFFICE_LOCATION = T3.FAC_ROOM_KEY\nJOIN FAC_BUILDING AS T2\n  ON T3.BUILDING_KEY = T2.FAC_BUILDING_KEY\nJOIN MOIRA_LIST_DETAIL AS T4\n  ON T1.KRB_NAME = T4.MOIRA_LIST_MEMBER\nJOIN MOIRA_LIST AS T5\n  ON T4.MOIRA_LIST_KEY = T5.MOIRA_LIST_KEY\nWHERE\n  T2.FAC_BUILDING_KEY = (\n    SELECT\n      BUILDING_KEY\n    FROM FAC_FLOOR\n    GROUP BY\n      BUILDING_KEY\n    ORDER BY\n      COUNT(DISTINCT LEVEL_ID) DESC\n    LIMIT 1\n  ) AND LOWER(T1.KRB_NAME) LIKE 'c%' AND LOWER(T5.MOIRA_LIST_NAME) LIKE 'a%';"
    },
    {
        "db_id": "dw",
        "question": "For the email lists subscribed by faculty members with last names begin with Y, list the names of the lists, the total number of subjects managed by faculty in those mailing lists, and the number of such faculty in the lists.",
        "predicted_sql": "WITH Y_Faculty_MIT_IDs AS (\n    SELECT MIT_ID\n    FROM EMPLOYEE_DIRECTORY\n    WHERE LAST_NAME LIKE 'Y%'\n),\nTarget_Moira_Lists AS (\n    SELECT DISTINCT\n        MLD.MOIRA_LIST_KEY,\n        ML.MOIRA_LIST_NAME\n    FROM MOIRA_LIST_DETAIL AS MLD\n    JOIN Y_Faculty_MIT_IDs AS YFI\n        ON MLD.MOIRA_LIST_MEMBER_MIT_ID = YFI.MIT_ID\n    JOIN MOIRA_LIST AS ML\n        ON MLD.MOIRA_LIST_KEY = ML.MOIRA_LIST_KEY\n    WHERE ML.IS_MOIRA_MAILING_LIST = 'Y'\n),\nAll_Faculty_In_Target_Lists AS (\n    SELECT\n        TML.MOIRA_LIST_KEY,\n        TML.MOIRA_LIST_NAME,\n        MLD.MOIRA_LIST_MEMBER_MIT_ID AS Faculty_MIT_ID\n    FROM Target_Moira_Lists AS TML\n    JOIN MOIRA_LIST_DETAIL AS MLD\n        ON TML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\n    WHERE MLD.MOIRA_LIST_MEMBER_MIT_ID IS NOT NULL\n)\nSELECT\n    AFTL.MOIRA_LIST_NAME,\n    COUNT(DISTINCT CCSO.SUBJECT_ID) AS total_subjects_managed_by_faculty_in_list,\n    COUNT(DISTINCT AFTL.Faculty_MIT_ID) AS number_of_faculty_in_list\nFROM All_Faculty_In_Target_Lists AS AFTL\nLEFT JOIN COURSE_CATALOG_SUBJECT_OFFERED AS CCSO\n    ON AFTL.Faculty_MIT_ID = CCSO.RESPONSIBLE_FACULTY_MIT_ID\nGROUP BY\n    AFTL.MOIRA_LIST_NAME\nORDER BY\n    AFTL.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with H who are subscribed to mailing list 'beacon-date-date', list the names of the students, the phone numbers of departments they belong to, and the size of the mailing list 'beacon-date-date' that they are subscribed to.",
        "predicted_sql": "SELECT\n  T1.FULL_NAME,\n  T5.DEPARTMENT_PHONE_NUMBER,\n  (\n    SELECT\n        COUNT(DISTINCT T_MLD_sub.MOIRA_LIST_MEMBER)\n    FROM\n        MOIRA_LIST AS T_ML_sub\n    INNER JOIN\n        MOIRA_LIST_DETAIL AS T_MLD_sub\n    ON\n        T_ML_sub.MOIRA_LIST_KEY = T_MLD_sub.MOIRA_LIST_KEY\n    WHERE\n        T_ML_sub.MOIRA_LIST_NAME = 'beacon-date-date'\n  ) AS mailing_list_size\nFROM\n  MIT_STUDENT_DIRECTORY AS T1\nINNER JOIN\n  SE_PERSON AS T2\nON\n  T1.FULL_NAME = T2.FULL_NAME\nINNER JOIN\n  MOIRA_LIST_DETAIL AS T3\nON\n  T2.KRB_NAME = T3.MOIRA_LIST_MEMBER\nINNER JOIN\n  MOIRA_LIST AS T4\nON\n  T3.MOIRA_LIST_KEY = T4.MOIRA_LIST_KEY\nINNER JOIN\n  SIS_DEPARTMENT AS T6\nON\n  T1.DEPARTMENT = T6.DEPARTMENT_CODE\nINNER JOIN\n  SIS_ADMIN_DEPARTMENT AS T5\nON\n  T6.DEPARTMENT_CODE = T5.SIS_ADMIN_DEPARTMENT_CODE\nWHERE\n  T1.LAST_NAME LIKE 'H%' AND T4.MOIRA_LIST_NAME = 'beacon-date-date';"
    },
    {
        "db_id": "dw",
        "question": "Give the count of mailing lists with names starting with B that include members from the Electrical Engineering and Computer Science department, along with the name of the list starting with B that have the highest number of members from that department and the corresponding member count.",
        "predicted_sql": "WITH EECS_Member_Counts AS (\n    SELECT\n        ML.MOIRA_LIST_NAME,\n        COUNT(DISTINCT SP.KRB_NAME) AS department_member_count\n    FROM\n        MOIRA_LIST AS ML\n    JOIN\n        MOIRA_LIST_DETAIL AS MLD ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\n    JOIN\n        SE_PERSON AS SP ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME\n    WHERE\n        ML.IS_MOIRA_MAILING_LIST = 'Y'\n        AND ML.MOIRA_LIST_NAME LIKE 'B%'\n        AND SP.ORGANIZATION = 'Electrical Engineering and Computer Science'\n    GROUP BY\n        ML.MOIRA_LIST_NAME\n)\nSELECT\n    (SELECT COUNT(*) FROM EECS_Member_Counts) AS total_b_eecs_lists,\n    (SELECT MOIRA_LIST_NAME FROM EECS_Member_Counts ORDER BY department_member_count DESC, MOIRA_LIST_NAME ASC LIMIT 1) AS highest_member_list_name,\n    (SELECT department_member_count FROM EECS_Member_Counts ORDER BY department_member_count DESC, MOIRA_LIST_NAME ASC LIMIT 1) AS highest_member_count;"
    },
    {
        "db_id": "dw",
        "question": "For the 'kangaroo-inspire-yearn' email list, for each department present in the list, list the department name, the number of students in that department, and its percentage relative to the students in the mailing list.",
        "predicted_sql": "WITH ListMembers AS (\n    SELECT DISTINCT T2.MOIRA_LIST_MEMBER\n    FROM MOIRA_LIST AS T1\n    JOIN MOIRA_LIST_DETAIL AS T2\n        ON T1.MOIRA_LIST_KEY = T2.MOIRA_LIST_KEY\n    WHERE T1.MOIRA_LIST_NAME = 'kangaroo-inspire-yearn'\n),\nStudentsInList AS (\n    SELECT DISTINCT\n        T4.DEPARTMENT AS student_department_code,\n        T4.FULL_NAME\n    FROM ListMembers AS lm\n    JOIN SE_PERSON AS T3\n        ON lm.MOIRA_LIST_MEMBER = T3.KRB_NAME\n    JOIN MIT_STUDENT_DIRECTORY AS T4\n        ON T3.FULL_NAME = T4.FULL_NAME\n),\nTotalStudentsInList AS (\n    SELECT COUNT(FULL_NAME) AS total_count\n    FROM StudentsInList\n)\nSELECT\n    T5.SIS_ADMIN_DEPARTMENT_NAME AS department_name,\n    COUNT(sil.FULL_NAME) AS number_of_students,\n    CAST(COUNT(sil.FULL_NAME) * 100.0 / (SELECT total_count FROM TotalStudentsInList) AS DECIMAL(5, 2)) AS percentage_of_students\nFROM StudentsInList AS sil\nJOIN SIS_ADMIN_DEPARTMENT AS T5\n    ON sil.student_department_code = T5.SIS_ADMIN_DEPARTMENT_CODE\nGROUP BY T5.SIS_ADMIN_DEPARTMENT_NAME\nORDER BY department_name;"
    },
    {
        "db_id": "dw",
        "question": "Among the mailing lists subscribed by people with physical offices in building 24, provide the name of the most subscribed mailing list and the total number of subscribers.",
        "predicted_sql": "SELECT\n  T1.MOIRA_LIST_NAME,\n  COUNT(DISTINCT T3.MIT_ID) AS TotalSubscribers\nFROM MOIRA_LIST AS T1\nINNER JOIN MOIRA_LIST_DETAIL AS T2\n  ON T1.MOIRA_LIST_KEY = T2.MOIRA_LIST_KEY\nINNER JOIN EMPLOYEE_DIRECTORY AS T3\n  ON T2.MOIRA_LIST_MEMBER = T3.KRB_NAME\nWHERE\n  T3.OFFICE_LOCATION LIKE '24%'\nGROUP BY\n  T1.MOIRA_LIST_NAME\nORDER BY\n  TotalSubscribers DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For email lists subscribed by either support staff or faculty, list its name, the number of subscribers that are support staff, the number of subscribers that are faculty, as well as its active status.",
        "predicted_sql": "SELECT\n  T1.MOIRA_LIST_NAME,\n  COUNT(DISTINCT CASE WHEN T3.EMPLOYEE_TYPE = 'Support Staff' THEN T3.MIT_ID ELSE NULL END) AS num_support_staff_subscribers,\n  COUNT(DISTINCT CASE WHEN T3.EMPLOYEE_TYPE = 'Faculty' THEN T3.MIT_ID ELSE NULL END) AS num_faculty_subscribers,\n  T1.IS_ACTIVE\nFROM MOIRA_LIST AS T1\nINNER JOIN MOIRA_LIST_DETAIL AS T2\n  ON T1.MOIRA_LIST_KEY = T2.MOIRA_LIST_KEY\nINNER JOIN SE_PERSON AS T3\n  ON T2.MOIRA_LIST_MEMBER_MIT_ID = T3.MIT_ID\nWHERE\n  T1.IS_MOIRA_MAILING_LIST = 'Y' AND T3.EMPLOYEE_TYPE IN ('Support Staff', 'Faculty')\nGROUP BY\n  T1.MOIRA_LIST_KEY,\n  T1.MOIRA_LIST_NAME,\n  T1.IS_ACTIVE;"
    },
    {
        "db_id": "dw",
        "question": "For the 'ocean-apple' mailing list, identify the department with the highest student count. Provide the department name, phone number, and the total number of students subscribed to the mailing list from that department. If multiple departments have the same highest count, list each one separately.",
        "predicted_sql": "WITH DepartmentStudentCounts AS (\n  SELECT\n    T5.SIS_ADMIN_DEPARTMENT_NAME,\n    T5.DEPARTMENT_PHONE_NUMBER,\n    COUNT(DISTINCT T4.FULL_NAME) AS student_count\n  FROM MOIRA_LIST AS T1\n  JOIN MOIRA_LIST_DETAIL AS T2\n    ON T1.MOIRA_LIST_KEY = T2.MOIRA_LIST_KEY\n  JOIN SE_PERSON AS T3\n    ON T2.MOIRA_LIST_MEMBER = T3.KRB_NAME\n  JOIN MIT_STUDENT_DIRECTORY AS T4\n    ON T3.FULL_NAME = T4.FULL_NAME\n  JOIN SIS_ADMIN_DEPARTMENT AS T5\n    ON T4.DEPARTMENT = T5.SIS_ADMIN_DEPARTMENT_CODE\n  WHERE\n    T1.MOIRA_LIST_NAME = 'ocean-apple'\n  GROUP BY\n    T5.SIS_ADMIN_DEPARTMENT_NAME,\n    T5.DEPARTMENT_PHONE_NUMBER\n)\nSELECT\n  DSC.SIS_ADMIN_DEPARTMENT_NAME,\n  DSC.DEPARTMENT_PHONE_NUMBER,\n  DSC.student_count\nFROM DepartmentStudentCounts AS DSC\nWHERE\n  DSC.student_count = (\n    SELECT\n      MAX(student_count)\n    FROM DepartmentStudentCounts\n  );"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list, list its owner, owner type, the member visibility ('Public Members' if public, and 'Hidden Members' otherwise), and the number of members of this type of visibility. For each owner and owner type, include a grand total for all members in the format of (owner, owner type, null, total members).",
        "predicted_sql": "WITH MemberVisibility AS (\n    SELECT\n        mlo.OWNER,\n        mlo.OWNER_TYPE,\n        CASE\n            WHEN ml.IS_PUBLIC = 'Y' THEN 'Public Members'\n            WHEN ml.IS_PUBLIC = 'N' THEN 'Hidden Members'\n        END AS visibility_type,\n        mld.MOIRA_LIST_MEMBER AS member_id\n    FROM\n        MOIRA_LIST_DETAIL AS mld\n    JOIN\n        MOIRA_LIST AS ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\n    JOIN\n        MOIRA_LIST_OWNER AS mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY\n)\nSELECT\n    mv.OWNER,\n    mv.OWNER_TYPE,\n    CASE\n        WHEN GROUPING(mv.visibility_type) = 1 THEN NULL\n        ELSE mv.visibility_type\n    END AS `member_visibility`,\n    COUNT(mv.member_id) AS `number_of_members`\nFROM\n    MemberVisibility AS mv\nGROUP BY\n    mv.OWNER,\n    mv.OWNER_TYPE,\n    mv.visibility_type WITH ROLLUP\nHAVING\n    GROUPING(mv.OWNER) = 0\n    AND GROUPING(mv.OWNER_TYPE) = 0\nORDER BY\n    mv.OWNER,\n    mv.OWNER_TYPE,\n    `member_visibility` IS NULL DESC, `member_visibility`;"
    },
    {
        "db_id": "dw",
        "question": "Group biology courses by cluster type and course level. For each group, list the name of the department, the course title, cluster type, total enrollments, average enrollment within its cluster, course level, number of unique course materials, average new and used prices for TIP materials, total material record count for TIP materials, number of unique library titles, and number of unique library ISBNs.",
        "predicted_sql": "SELECT\n  GROUP_CONCAT(DISTINCT T1.OFFER_DEPT_NAME SEPARATOR '; ') AS department_name,\n  GROUP_CONCAT(DISTINCT T1.SUBJECT_TITLE SEPARATOR '; ') AS course_title,\n  T1.CLUSTER_TYPE,\n  SUM(T1.NUM_ENROLLED_STUDENTS) AS total_enrollments,\n  T5.cluster_avg_enrollment,\n  T2.COURSE_LEVEL,\n  COUNT(DISTINCT T4.TITLE) AS num_unique_course_materials,\n  AVG(T4.NEW_SHELF_PRICE) AS avg_new_price,\n  AVG(T4.USED_SHELF_PRICE) AS avg_used_price,\n  SUM(T3.RECORD_COUNT) AS total_material_record_count,\n  COUNT(DISTINCT T6.CATALOG_TITLE) AS num_unique_library_titles,\n  COUNT(DISTINCT T6.CATALOG_ISBN) AS num_unique_library_isbns\nFROM SUBJECT_OFFERED_SUMMARY AS T1\nLEFT JOIN SIS_COURSE_DESCRIPTION AS T2\n  ON T1.COURSE_NUMBER = T2.COURSE\nLEFT JOIN TIP_DETAIL AS T3\n  ON T1.SUBJECT_ID = T3.SUBJECT_ID AND T1.TERM_CODE = T3.TERM_CODE\nLEFT JOIN TIP_MATERIAL AS T4\n  ON T3.TIP_MATERIAL_KEY = T4.TIP_MATERIAL_KEY\nLEFT JOIN LIBRARY_RESERVE_CATALOG AS T6\n  ON T3.ISBN = T6.CATALOG_ISBN\nLEFT JOIN (\n  SELECT\n    CLUSTER_TYPE,\n    AVG(NUM_ENROLLED_STUDENTS) AS cluster_avg_enrollment\n  FROM SUBJECT_OFFERED_SUMMARY\n  WHERE\n    OFFER_DEPT_NAME LIKE '%Biology%'\n  GROUP BY\n    CLUSTER_TYPE\n) AS T5\n  ON T1.CLUSTER_TYPE = T5.CLUSTER_TYPE\nWHERE\n  T1.OFFER_DEPT_NAME LIKE '%Biology%'\nGROUP BY\n  T1.CLUSTER_TYPE,\n  T2.COURSE_LEVEL,\n  T5.cluster_avg_enrollment\nORDER BY\n  T1.CLUSTER_TYPE,\n  T2.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered this year in either the Fall or Spring term, list its department name, school name, subject ID, subject title, course level, total units, the term it is offered ('Spring' for Spring term and 'Fall' for Fall term), term description, the number of distinct instructors teaching in the Fall, and the number of distinct instructors teaching in the Spring.",
        "predicted_sql": "(\nSELECT\n  T1.DEPARTMENT_NAME,\n  T2.SCHOOL_NAME,\n  T1.SUBJECT_ID,\n  T1.SUBJECT_TITLE,\n  GROUP_CONCAT(DISTINCT T3.COURSE_LEVEL SEPARATOR ', ') AS COURSE_LEVEL,\n  T1.TOTAL_UNITS,\n  'Fall' AS term_offered,\n  T4.TERM_DESCRIPTION AS term_description,\n  CASE\n    WHEN T1.FALL_INSTRUCTORS IS NULL OR TRIM(T1.FALL_INSTRUCTORS) = ''\n    THEN 0\n    ELSE LENGTH(T1.FALL_INSTRUCTORS) - LENGTH(REPLACE(T1.FALL_INSTRUCTORS, ',', '')) + 1\n  END AS num_fall_instructors,\n  0 AS num_spring_instructors\nFROM COURSE_CATALOG_SUBJECT_OFFERED AS T1\nLEFT JOIN SIS_DEPARTMENT AS T2\n  ON T1.DEPARTMENT_CODE = T2.DEPARTMENT_CODE\nLEFT JOIN SIS_COURSE_DESCRIPTION AS T3\n  ON T1.SUBJECT_CODE = T3.COURSE\nLEFT JOIN ACADEMIC_TERMS AS T4\n  ON T1.TERM_CODE = T4.TERM_CODE\nWHERE\n  T1.IS_OFFERED_THIS_YEAR = 'Y' AND T1.IS_OFFERED_FALL_TERM = 'Y' AND T1.TERM_CODE LIKE '%FA'\nGROUP BY\n  T1.DEPARTMENT_NAME,\n  T2.SCHOOL_NAME,\n  T1.SUBJECT_ID,\n  T1.SUBJECT_TITLE,\n  T1.TOTAL_UNITS,\n  term_offered,\n  T4.TERM_DESCRIPTION,\n  num_fall_instructors\n)\nUNION ALL\n(\nSELECT\n  T1.DEPARTMENT_NAME,\n  T2.SCHOOL_NAME,\n  T1.SUBJECT_ID,\n  T1.SUBJECT_TITLE,\n  GROUP_CONCAT(DISTINCT T3.COURSE_LEVEL SEPARATOR ', ') AS COURSE_LEVEL,\n  T1.TOTAL_UNITS,\n  'Spring' AS term_offered,\n  T4.TERM_DESCRIPTION AS term_description,\n  0 AS num_fall_instructors,\n  CASE\n    WHEN T1.SPRING_INSTRUCTORS IS NULL OR TRIM(T1.SPRING_INSTRUCTORS) = ''\n    THEN 0\n    ELSE LENGTH(T1.SPRING_INSTRUCTORS) - LENGTH(REPLACE(T1.SPRING_INSTRUCTORS, ',', '')) + 1\n  END AS num_spring_instructors\nFROM COURSE_CATALOG_SUBJECT_OFFERED AS T1\nLEFT JOIN SIS_DEPARTMENT AS T2\n  ON T1.DEPARTMENT_CODE = T2.DEPARTMENT_CODE\nLEFT JOIN SIS_COURSE_DESCRIPTION AS T3\n  ON T1.SUBJECT_CODE = T3.COURSE\nLEFT JOIN ACADEMIC_TERMS AS T4\n  ON T1.TERM_CODE = T4.TERM_CODE\nWHERE\n  T1.IS_OFFERED_THIS_YEAR = 'Y' AND T1.IS_OFFERED_SPRING_TERM = 'Y' AND T1.TERM_CODE LIKE '%SP'\nGROUP BY\n  T1.DEPARTMENT_NAME,\n  T2.SCHOOL_NAME,\n  T1.SUBJECT_ID,\n  T1.SUBJECT_TITLE,\n  T1.TOTAL_UNITS,\n  term_offered,\n  T4.TERM_DESCRIPTION,\n  num_spring_instructors\n);"
    },
    {
        "db_id": "dw",
        "question": "For Political Science courses with HASS attributes, for each attribute, list the name and description of the attribute, the number of unique subjects, average units, the total enrollment, the number of departments that grant degrees, and the subject code description.",
        "predicted_sql": "SELECT\n  T1.HASS_ATTRIBUTE,\n  T1.HASS_ATTRIBUTE_DESC,\n  COUNT(DISTINCT T1.SUBJECT_ID) AS num_unique_subjects,\n  AVG(CAST(T1.TOTAL_UNITS AS DECIMAL)) AS average_units,\n  SUM(T2.NUM_ENROLLED_STUDENTS) AS total_enrollment,\n  COUNT(DISTINCT CASE WHEN T4.IS_DEGREE_GRANTING = 'Y' THEN T4.DEPARTMENT_CODE ELSE NULL END) AS num_degree_granting_departments,\n  T3.SUBJECT_CODE_DESC\nFROM CIS_COURSE_CATALOG AS T1\nINNER JOIN SUBJECT_OFFERED_SUMMARY AS T2\n  ON T1.SUBJECT_ID = T2.SUBJECT_ID\nINNER JOIN SIS_SUBJECT_CODE AS T3\n  ON T1.SUBJECT_CODE = T3.SUBJECT_CODE\nINNER JOIN SIS_DEPARTMENT AS T4\n  ON T3.DEPARTMENT_CODE = T4.DEPARTMENT_CODE\nWHERE\n  T4.DEPARTMENT_NAME = 'Political Science' AND T1.HASS_ATTRIBUTE IS NOT NULL\nGROUP BY\n  T1.HASS_ATTRIBUTE,\n  T1.HASS_ATTRIBUTE_DESC,\n  T3.SUBJECT_CODE_DESC;"
    },
    {
        "db_id": "dw",
        "question": "Group subjects by cluster type, department offering the subject, and the school name. For each group, list the cluster type, name of the department, school name, whether the department grants degrees, total number of subjects, total enrollment, and average enrollment. Exclude clusters or schools with no student data.",
        "predicted_sql": "SELECT\n  T1.CLUSTER_TYPE,\n  T1.OFFER_DEPT_NAME,\n  T2.SCHOOL_NAME,\n  T2.IS_DEGREE_GRANTING,\n  COUNT(DISTINCT T1.SUBJECT_ID) AS total_subjects,\n  SUM(T1.NUM_ENROLLED_STUDENTS) AS total_enrollment,\n  AVG(T1.NUM_ENROLLED_STUDENTS) AS average_enrollment\nFROM SUBJECT_OFFERED_SUMMARY AS T1\nINNER JOIN SIS_DEPARTMENT AS T2\n  ON T1.OFFER_DEPT_CODE = T2.DEPARTMENT_CODE\nGROUP BY\n  T1.CLUSTER_TYPE,\n  T1.OFFER_DEPT_NAME,\n  T2.SCHOOL_NAME,\n  T2.IS_DEGREE_GRANTING\nHAVING\n  SUM(T1.NUM_ENROLLED_STUDENTS) > 0;"
    },
    {
        "db_id": "dw",
        "question": "Group classes that take place in buildings at MIT by the building name and course level. For each group, provide the name of the building, the course level ('Graduate' or 'Undergraduate'), the total number of unique courses of such level, and total instructors for these courses. Include subtotals for each building and course level and a grand total across all buildings and course levels.",
        "predicted_sql": "SELECT\n  COALESCE(FB.BUILDING_NAME, 'Grand Total') AS Building_Name,\n  CASE\n    WHEN SCD.COURSE_LEVEL = 'G' THEN 'Graduate'\n    WHEN SCD.COURSE_LEVEL = 'U' THEN 'Undergraduate'\n    WHEN SCD.COURSE_LEVEL IS NULL AND FB.BUILDING_NAME IS NOT NULL THEN 'Subtotal'\n    WHEN SCD.COURSE_LEVEL IS NULL AND FB.BUILDING_NAME IS NULL THEN 'Grand Total'\n    ELSE NULL\n  END AS Course_Level,\n  COUNT(DISTINCT SO.SUBJECT_ID) AS Total_Unique_Courses,\n  COUNT(DISTINCT SO.RESPONSIBLE_FACULTY_NAME) AS Total_Instructors\nFROM FAC_BUILDING AS FB\nJOIN SUBJECT_OFFERED AS SO\n  ON FB.FAC_BUILDING_KEY = SO.MEET_PLACE\nJOIN SIS_COURSE_DESCRIPTION AS SCD\n  ON SO.COURSE_NUMBER = SCD.COURSE\nWHERE\n  FB.SITE = 'MIT' AND SCD.COURSE_LEVEL IN ('G', 'U')\nGROUP BY\n  FB.BUILDING_NAME,\n  SCD.COURSE_LEVEL WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each course, provide the room number of course location, building name, building number, building city, building state, area, organization name, room usage, term code, course level, the total number of subjects, unique meeting times, and total units. Do not include meet place or meet times with NULL values.",
        "predicted_sql": "SELECT\n  T2.ROOM,\n  T3.BUILDING_NAME,\n  T3.BUILDING_NUMBER,\n  T4.CITY,\n  T4.STATE,\n  T2.AREA,\n  T2.ORGANIZATION_NAME,\n  T5.MAJOR_USE,\n  T1.TERM_CODE,\n  T6.COURSE_LEVEL,\n  COUNT(T1.SUBJECT_ID) AS total_subjects,\n  COUNT(DISTINCT T1.MEET_TIME) AS unique_meeting_times,\n  SUM(T1.TOTAL_UNITS) AS total_units\nFROM COURSE_CATALOG_SUBJECT_OFFERED AS T1\nINNER JOIN FAC_ROOMS AS T2\n  ON T1.MEET_PLACE = T2.FAC_ROOM_KEY\nINNER JOIN FAC_BUILDING AS T3\n  ON T2.BUILDING_KEY = T3.FAC_BUILDING_KEY\nINNER JOIN FAC_BUILDING_ADDRESS AS T4\n  ON T3.FAC_BUILDING_KEY = T4.BUILDING_KEY\nINNER JOIN FAC_MAJOR_USE AS T5\n  ON T2.MAJOR_USE_KEY = T5.MAJOR_USE_KEY\nLEFT JOIN SIS_COURSE_DESCRIPTION AS T6\n  ON T1.SUBJECT_ID = T6.COURSE\nWHERE\n  T1.MEET_PLACE IS NOT NULL AND T1.MEET_TIME IS NOT NULL\nGROUP BY\n  T2.ROOM,\n  T3.BUILDING_NAME,\n  T3.BUILDING_NUMBER,\n  T4.CITY,\n  T4.STATE,\n  T2.AREA,\n  T2.ORGANIZATION_NAME,\n  T5.MAJOR_USE,\n  T1.TERM_CODE,\n  T6.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "Consider only books cataloged on or after 2000. For each library material status and department, list the material status, department name, number of associated catalog items, and the total number of enrolled students in courses using those materials. Include subtotals for each material status and a grand total across all status (the corresponding status field is 'Grand Total').",
        "predicted_sql": "SELECT\n  CASE\n    WHEN GROUPING(T1.LIBRARY_MATERIAL_STATUS) = 1\n    THEN 'Grand Total'\n    ELSE T1.LIBRARY_MATERIAL_STATUS\n  END AS material_status,\n  T5.DEPARTMENT_NAME AS department_name,\n  COUNT(DISTINCT T2.LIBRARY_RESERVE_CATALOG_KEY) AS num_associated_catalog_items,\n  SUM(T4.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\nFROM LIBRARY_MATERIAL_STATUS AS T1\nJOIN LIBRARY_RESERVE_MATRL_DETAIL AS T3\n  ON T1.LIBRARY_MATERIAL_STATUS_KEY = T3.LIBRARY_MATERIAL_STATUS_KEY\nJOIN LIBRARY_RESERVE_CATALOG AS T2\n  ON T3.LIBRARY_RESERVE_CATALOG_KEY = T2.LIBRARY_RESERVE_CATALOG_KEY\nJOIN LIBRARY_SUBJECT_OFFERED AS T4\n  ON T3.LIBRARY_SUBJECT_OFFERED_KEY = T4.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN SIS_SUBJECT_CODE AS T5\n  ON T4.COURSE_NUMBER = T5.COURSE_NUMBER\nWHERE\n  T2.CATALOG_YEAR >= '2000'\nGROUP BY\n  T1.LIBRARY_MATERIAL_STATUS,\n  T5.DEPARTMENT_NAME WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each department in the library system, list the name of the department, total number of courses using library materials, the number of catalog items associated with those courses, and the average enrollment per course. Include a grand total across all departments (the corresponding department field should be 'Grand Total').",
        "predicted_sql": "```mysql\nWITH CourseEnrollmentAverages AS (\n    SELECT\n        LCI.DEPARTMENT,\n        LCI.COURSE_NAME,\n        AVG(LSO.NUM_ENROLLED_STUDENTS) AS AvgCourseEnrollment\n    FROM\n        LIBRARY_COURSE_INSTRUCTOR AS LCI\n    JOIN\n        LIBRARY_RESERVE_MATRL_DETAIL AS LRMD ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\n    JOIN\n        LIBRARY_SUBJECT_OFFERED AS LSO ON LRMD.LIBRARY_SUBJECT_OFFERED_KEY = LSO.LIBRARY_SUBJECT_OFFERED_KEY\n    GROUP BY\n        LCI.DEPARTMENT,\n        LCI.COURSE_NAME\n)\nSELECT\n    COALESCE(LCI.DEPARTMENT, 'Grand Total') AS department_name,\n    COUNT(DISTINCT LCI.COURSE_NAME) AS total_courses_using_library_materials,\n    COUNT(DISTINCT LRC.LIBRARY_RESERVE_CATALOG_KEY) AS number_of_catalog_items,\n    AVG(CEA.AvgCourseEnrollment) AS average_enrollment_per_course\nFROM\n    LIBRARY_COURSE_INSTRUCTOR AS LCI\nJOIN\n    LIBRARY_RESERVE_MATRL_DETAIL AS LRMD ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN\n    LIBRARY_RESERVE_CATALOG AS LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\nLEFT JOIN\n    CourseEnrollmentAverages AS CEA ON LCI.DEPARTMENT = CEA.DEPARTMENT AND LCI.COURSE_NAME = CEA.COURSE_NAME\nGROUP BY\n    LCI.DEPARTMENT WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each department and school offering courses with materials, list the department name, school name, number of unique course materials, number of courses, average new and used shelf prices of materials, total material records, and number of distinct material statuses. Include a grand total across all schools and departments (the corresponding school and department fields should be null).",
        "predicted_sql": "SELECT\n  TSO.OFFER_DEPT_NAME AS department_name,\n  SD.SCHOOL_NAME AS school_name,\n  COUNT(DISTINCT TM.TITLE) AS num_unique_course_materials,\n  COUNT(DISTINCT TSO.SUBJECT_TITLE) AS num_courses,\n  AVG(TM.NEW_SHELF_PRICE) AS avg_new_shelf_price,\n  AVG(TM.USED_SHELF_PRICE) AS avg_used_shelf_price,\n  SUM(TD.RECORD_COUNT) AS total_material_records,\n  COUNT(DISTINCT TMS.TIP_MATERIAL_STATUS) AS num_distinct_material_statuses\nFROM TIP_SUBJECT_OFFERED AS TSO\nJOIN TIP_DETAIL AS TD\n  ON TSO.TIP_SUBJECT_OFFERED_KEY = TD.TIP_SUBJECT_OFFERED_KEY\nJOIN TIP_MATERIAL AS TM\n  ON TD.TIP_MATERIAL_KEY = TM.TIP_MATERIAL_KEY\nJOIN TIP_MATERIAL_STATUS AS TMS\n  ON TD.TIP_MATERIAL_STATUS_KEY = TMS.TIP_MATERIAL_STATUS_KEY\nJOIN SIS_DEPARTMENT AS SD\n  ON TSO.OFFER_DEPT_CODE = SD.DEPARTMENT_CODE\nWHERE\n  TSO.IS_NO_COURSE_MATERIAL = 'N'\nGROUP BY\n  TSO.OFFER_DEPT_NAME,\n  SD.SCHOOL_NAME WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each TIP material status, list the total number of unique materials associated with the status, the total number of records associated with the status, and the total student enrollment associated with the status. Any material status with null values should be displayed as 'No material status'. Additionally, include a grand total across all material status (the material status for this row should be displayed as 'Grand Total').",
        "predicted_sql": "SELECT\n  IF(GROUPING(tms.TIP_MATERIAL_STATUS), 'Grand Total', IFNULL(tms.TIP_MATERIAL_STATUS, 'No material status')) AS `Material Status`,\n  COUNT(DISTINCT tm.TITLE) AS `Total Unique Materials`,\n  SUM(td.RECORD_COUNT) AS `Total Records`,\n  SUM(tso.NUM_ENROLLED_STUDENTS) AS `Total Student Enrollment`\nFROM TIP_DETAIL AS td\nLEFT JOIN TIP_MATERIAL_STATUS AS tms\n  ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nLEFT JOIN TIP_MATERIAL AS tm\n  ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN TIP_SUBJECT_OFFERED AS tso\n  ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nGROUP BY\n  tms.TIP_MATERIAL_STATUS WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each room, list its associated building name, floor number, room number, ownership type, organization name, number of rooms, area, and percentage of area relative to the building. Include subtotals across floors, subtotals across all floors for each building, and a grand total across all buildings. For the subtotal for each building and the grand total, the percentage of area should be relative to area of all buildings. All numeric values should be rounded to integers and formatted using commas as thousands separators except the relative percentages which should be rounded to two decimal places.",
        "predicted_sql": "WITH RoomBaseData AS (\n    SELECT\n        fb.FCLT_BUILDING_KEY,\n        fb.BUILDING_NAME_LONG,\n        fb.OWNERSHIP_TYPE,\n        ff.FLOOR,\n        fr.FCLT_ROOM_KEY,\n        fr.BUILDING_ROOM,\n        fo.ORGANIZATION_NAME,\n        fr.AREA\n    FROM FCLT_ROOMS AS fr\n    JOIN FCLT_BUILDING AS fb\n        ON fr.FCLT_BUILDING_KEY = fb.FCLT_BUILDING_KEY\n    JOIN FCLT_FLOOR AS ff\n        ON fr.FCLT_FLOOR_KEY = ff.FCLT_FLOOR_KEY\n    LEFT JOIN FCLT_ORGANIZATION AS fo\n        ON fr.FCLT_ORGANIZATION_KEY = fo.FCLT_ORGANIZATION_KEY\n),\nCalculatedTotals AS (\n    SELECT\n        rbd.*,\n        SUM(rbd.AREA) OVER (PARTITION BY rbd.FCLT_BUILDING_KEY) AS total_area_for_building,\n        SUM(rbd.AREA) OVER () AS total_area_all_buildings\n    FROM RoomBaseData AS rbd\n)\n-- Level 1: Room Details\nSELECT\n    ct.BUILDING_NAME_LONG,\n    ct.FLOOR,\n    ct.BUILDING_ROOM,\n    ct.OWNERSHIP_TYPE,\n    ct.ORGANIZATION_NAME,\n    FORMAT(1, 0) AS `Number of Rooms`,\n    FORMAT(ROUND(ct.AREA), 0) AS Area,\n    ROUND((ct.AREA * 100.0 / ct.total_area_for_building), 2) AS `Percentage of Area`,\n    1 AS sort_level,\n    ct.FCLT_BUILDING_KEY AS building_sort_key,\n    ct.FLOOR AS floor_sort_key,\n    ct.BUILDING_ROOM AS room_sort_key\nFROM CalculatedTotals AS ct\n\nUNION ALL\n\n-- Level 2: Floor Subtotals\nSELECT\n    ct.BUILDING_NAME_LONG,\n    ct.FLOOR,\n    'Floor Total' AS BUILDING_ROOM,\n    ct.OWNERSHIP_TYPE,\n    NULL AS ORGANIZATION_NAME,\n    FORMAT(COUNT(ct.FCLT_ROOM_KEY), 0) AS `Number of Rooms`,\n    FORMAT(ROUND(SUM(ct.AREA)), 0) AS Area,\n    ROUND((SUM(ct.AREA) * 100.0 / MAX(ct.total_area_for_building)), 2) AS `Percentage of Area`,\n    2 AS sort_level,\n    ct.FCLT_BUILDING_KEY AS building_sort_key,\n    ct.FLOOR AS floor_sort_key,\n    '~' AS room_sort_key -- Sort after all specific rooms within a floor\nFROM CalculatedTotals AS ct\nGROUP BY\n    ct.FCLT_BUILDING_KEY,\n    ct.BUILDING_NAME_LONG,\n    ct.OWNERSHIP_TYPE,\n    ct.FLOOR\n\nUNION ALL\n\n-- Level 3: Building Subtotals\nSELECT\n    ct.BUILDING_NAME_LONG,\n    'Building Total' AS FLOOR,\n    NULL AS BUILDING_ROOM,\n    ct.OWNERSHIP_TYPE,\n    NULL AS ORGANIZATION_NAME,\n    FORMAT(COUNT(ct.FCLT_ROOM_KEY), 0) AS `Number of Rooms`,\n    FORMAT(ROUND(SUM(ct.AREA)), 0) AS Area,\n    ROUND((SUM(ct.AREA) * 100.0 / MAX(ct.total_area_all_buildings)), 2) AS `Percentage of Area`,\n    3 AS sort_level,\n    ct.FCLT_BUILDING_KEY AS building_sort_key,\n    '~' AS floor_sort_key, -- Sort after all specific floors and floor totals within a building\n    '~' AS room_sort_key\nFROM CalculatedTotals AS ct\nGROUP BY\n    ct.FCLT_BUILDING_KEY,\n    ct.BUILDING_NAME_LONG,\n    ct.OWNERSHIP_TYPE\n\nUNION ALL\n\n-- Level 4: Grand Total\nSELECT\n    'Grand Total' AS BUILDING_NAME_LONG,\n    NULL AS FLOOR,\n    NULL AS BUILDING_ROOM,\n    NULL AS OWNERSHIP_TYPE,\n    NULL AS ORGANIZATION_NAME,\n    FORMAT(COUNT(ct.FCLT_ROOM_KEY), 0) AS `Number of Rooms`,\n    FORMAT(ROUND(SUM(ct.AREA)), 0) AS Area,\n    ROUND(100.00, 2) AS `Percentage of Area`,\n    4 AS sort_level,\n    'ZZZZZ' AS building_sort_key, -- Sort after all buildings\n    'ZZZZZ' AS floor_sort_key,\n    'ZZZZZ' AS room_sort_key\nFROM CalculatedTotals AS ct\n\nORDER BY\n    building_sort_key,\n    sort_level,\n    floor_sort_key,\n    room_sort_key;"
    },
    {
        "db_id": "dw",
        "question": "For each financial aid year and academic year, list the number of fiscal periods, quarters, the start term date, the end term date, and number of distinct department-level term parameters.",
        "predicted_sql": "```mysql\nSELECT\n  T1.FINANCIAL_AID_YEAR,\n  T1.ACADEMIC_YEAR,\n  T1.TERM_START_DATE,\n  T1.TERM_END_DATE,\n  COUNT(DISTINCT T4.FISCAL_PERIOD) AS number_of_fiscal_periods,\n  COUNT(DISTINCT T5.FY_QUARTER_CODE) AS number_of_quarters,\n  COUNT(DISTINCT T2.TERM_PARAMETER) AS number_of_distinct_department_level_term_parameters\nFROM ACADEMIC_TERMS AS T1\nLEFT JOIN ACADEMIC_TERM_PARAMETER AS T2\n  ON T1.TERM_CODE = T2.TERM_CODE\nLEFT JOIN TIME_DAY AS T3\n  ON T1.TERM_START_DATE = T3.CALENDAR_DATE\nLEFT JOIN TIME_MONTH AS T4\n  ON T3.FISCAL_PERIOD = T4.FISCAL_PERIOD\nLEFT JOIN TIME_QUARTER AS T5\n  ON T4.FISCAL_YEAR = T5.FISCAL_YEAR\nGROUP BY\n  T1.FINANCIAL_AID_YEAR,\n  T1.ACADEMIC_YEAR,\n  T1.TERM_START_DATE,\n  T1.TERM_END_DATE\nORDER BY\n  T1.FINANCIAL_AID_YEAR,\n  T1.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "Group buildings by campus sectors. For each group, list the campus sector, name of the building, city and state where the building is located, total number of floors, total assignable area, total number of rooms, total number of organizations, ownership type, and a rank column indicating the order (1-indexed) of this row within each sector based on the descending order of assignable area. Include subtotals for each sector and a grand total across all sectors. The subtotal and grand total only need to computed over the total number of floors and assignable area.",
        "predicted_sql": "WITH building_addresses AS (\n    SELECT\n        FCLT_BUILDING_KEY,\n        CITY,\n        STATE\n    FROM (\n        SELECT\n            FCLT_BUILDING_KEY,\n            CITY,\n            STATE,\n            ROW_NUMBER() OVER (PARTITION BY FCLT_BUILDING_KEY ORDER BY CASE WHEN ADDRESS_PURPOSE = 'STREET' THEN 1 ELSE 2 END, ADDRESS_PURPOSE) AS rn\n        FROM FCLT_BUILDING_ADDRESS\n    ) AS sub\n    WHERE rn = 1\n),\nbuilding_metrics AS (\n    SELECT\n        FB.FCLT_BUILDING_KEY,\n        FB.CAMPUS_SECTOR,\n        FB.BUILDING_NAME_LONG,\n        BA.CITY,\n        BA.STATE,\n        FB.OWNERSHIP_TYPE,\n        FB.ASSIGNABLE_AREA AS building_assignable_area,\n        COUNT(DISTINCT FF.FLOOR) AS total_floors,\n        COUNT(DISTINCT FR.FCLT_ROOM_KEY) AS total_rooms,\n        COUNT(DISTINCT FR.FCLT_ORGANIZATION_KEY) AS total_organizations\n    FROM\n        FCLT_BUILDING AS FB\n    LEFT JOIN\n        building_addresses AS BA ON FB.FCLT_BUILDING_KEY = BA.FCLT_BUILDING_KEY\n    LEFT JOIN\n        FCLT_FLOOR AS FF ON FB.FCLT_BUILDING_KEY = FF.FCLT_BUILDING_KEY\n    LEFT JOIN\n        FCLT_ROOMS AS FR ON FB.FCLT_BUILDING_KEY = FR.FCLT_BUILDING_KEY\n    GROUP BY\n        FB.FCLT_BUILDING_KEY,\n        FB.CAMPUS_SECTOR,\n        FB.BUILDING_NAME_LONG,\n        BA.CITY,\n        BA.STATE,\n        FB.OWNERSHIP_TYPE,\n        FB.ASSIGNABLE_AREA\n),\nranked_building_metrics AS (\n    SELECT\n        CAMPUS_SECTOR,\n        BUILDING_NAME_LONG,\n        CITY,\n        STATE,\n        total_floors,\n        building_assignable_area,\n        total_rooms,\n        total_organizations,\n        OWNERSHIP_TYPE,\n        RANK() OVER (PARTITION BY CAMPUS_SECTOR ORDER BY building_assignable_area DESC) AS building_rank\n    FROM\n        building_metrics\n)\nSELECT\n    rbm.CAMPUS_SECTOR AS `campus sector`,\n    rbm.BUILDING_NAME_LONG AS `name of the building`,\n    rbm.CITY AS `city`,\n    rbm.STATE AS `state`,\n    rbm.total_floors AS `total number of floors`,\n    rbm.building_assignable_area AS `total assignable area`,\n    rbm.total_rooms AS `total number of rooms`,\n    rbm.total_organizations AS `total number of organizations`,\n    rbm.OWNERSHIP_TYPE AS `ownership type`,\n    rbm.building_rank AS `rank`\nFROM\n    ranked_building_metrics rbm\n\nUNION ALL\n\nSELECT\n    bm.CAMPUS_SECTOR AS `campus sector`,\n    CONCAT('Subtotal for ', bm.CAMPUS_SECTOR) AS `name of the building`,\n    NULL AS `city`,\n    NULL AS `state`,\n    SUM(bm.total_floors) AS `total number of floors`,\n    SUM(bm.building_assignable_area) AS `total assignable area`,\n    NULL AS `total number of rooms`,\n    NULL AS `total number of organizations`,\n    NULL AS `ownership type`,\n    NULL AS `rank`\nFROM\n    building_metrics bm\nGROUP BY\n    bm.CAMPUS_SECTOR\n\nUNION ALL\n\nSELECT\n    'Grand Total' AS `campus sector`,\n    'Grand Total' AS `name of the building`,\n    NULL AS `city`,\n    NULL AS `state`,\n    SUM(bm.total_floors) AS `total number of floors`,\n    SUM(bm.building_assignable_area) AS `total assignable area`,\n    NULL AS `total number of rooms`,\n    NULL AS `total number of organizations`,\n    NULL AS `ownership type`,\n    NULL AS `rank`\nFROM\n    building_metrics bm\n\nORDER BY\n    `campus sector` ASC,\n    CASE\n        WHEN `name of the building` LIKE 'Subtotal for %' THEN 1\n        WHEN `name of the building` = 'Grand Total' THEN 2\n        ELSE 0\n    END ASC,\n    `total assignable area` DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the name of the department, the title of the TIP material associated with the department, author, ISBN, library term code, and whether it is available in the library reserves ('Available in Library' if yes and 'Not Available in Library' otherwise), the total number of instructors per library book for the department, the total number of materials available in the library for the department, and the total number of available materials across all departments.",
        "predicted_sql": "WITH LibraryISBNInfo AS (\n    SELECT\n        LRC.CATALOG_ISBN AS ISBN,\n        GROUP_CONCAT(DISTINCT LRMD.TERM_CODE ORDER BY LRMD.TERM_CODE SEPARATOR ', ') AS library_term_code,\n        COUNT(DISTINCT LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY) AS num_instructors_for_isbn\n    FROM\n        LIBRARY_RESERVE_CATALOG AS LRC\n    LEFT JOIN\n        LIBRARY_RESERVE_MATRL_DETAIL AS LRMD\n        ON LRC.LIBRARY_RESERVE_CATALOG_KEY = LRMD.LIBRARY_RESERVE_CATALOG_KEY\n    GROUP BY\n        LRC.CATALOG_ISBN\n)\nSELECT\n    TSO.OFFER_DEPT_NAME,\n    TM.TITLE,\n    TM.AUTHOR,\n    TM.ISBN,\n    LII.library_term_code,\n    CASE\n        WHEN LII.ISBN IS NOT NULL THEN 'Available in Library'\n        ELSE 'Not Available in Library'\n    END AS availability_status,\n    IFNULL(LII.num_instructors_for_isbn, 0) AS total_instructors_per_library_book_for_department,\n    COUNT(DISTINCT CASE WHEN LII.ISBN IS NOT NULL THEN TM.ISBN END) OVER (PARTITION BY TSO.OFFER_DEPT_NAME) AS total_materials_available_in_department,\n    COUNT(DISTINCT CASE WHEN LII.ISBN IS NOT NULL THEN TM.ISBN END) OVER () AS total_materials_available_across_all_departments\nFROM\n    TIP_SUBJECT_OFFERED AS TSO\nJOIN\n    TIP_DETAIL AS TD ON TSO.TIP_SUBJECT_OFFERED_KEY = TD.TIP_SUBJECT_OFFERED_KEY\nJOIN\n    TIP_MATERIAL AS TM ON TD.TIP_MATERIAL_KEY = TM.TIP_MATERIAL_KEY\nLEFT JOIN\n    LibraryISBNInfo AS LII ON TM.ISBN = LII.ISBN;"
    },
    {
        "db_id": "dw",
        "question": "For each department and material status, list the name of the department, the material status, the number of TIP materials associated with this department and status, the number of library materials associated with this department and status, the total number of TIP and library materials associated with this department and status. Include a subtotal for each department and a grand total across all departments.",
        "predicted_sql": "SELECT\n  COALESCE(department_name, 'Grand Total') AS `Department Name`,\n  COALESCE(material_status, 'Department Total') AS `Material Status`,\n  SUM(tip_materials_count) AS `Number of TIP Materials`,\n  SUM(library_materials_count) AS `Number of Library Materials`,\n  SUM(tip_materials_count) + SUM(library_materials_count) AS `Total Materials`\nFROM\n  (\n    SELECT\n      TSO.OFFER_DEPT_NAME AS department_name,\n      TMS.TIP_MATERIAL_STATUS AS material_status,\n      COUNT(TD.TIP_MATERIAL_KEY) AS tip_materials_count,\n      0 AS library_materials_count\n    FROM TIP_DETAIL AS TD\n    JOIN TIP_SUBJECT_OFFERED AS TSO\n      ON TD.TIP_SUBJECT_OFFERED_KEY = TSO.TIP_SUBJECT_OFFERED_KEY\n    JOIN TIP_MATERIAL_STATUS AS TMS\n      ON TD.TIP_MATERIAL_STATUS_KEY = TMS.TIP_MATERIAL_STATUS_KEY\n    GROUP BY\n      TSO.OFFER_DEPT_NAME,\n      TMS.TIP_MATERIAL_STATUS\n    UNION ALL\n    SELECT\n      LSO.OFFER_DEPT_NAME AS department_name,\n      LMS.LIBRARY_MATERIAL_STATUS AS material_status,\n      0 AS tip_materials_count,\n      COUNT(LRMD.LIBRARY_RESERVE_CATALOG_KEY) AS library_materials_count\n    FROM LIBRARY_RESERVE_MATRL_DETAIL AS LRMD\n    JOIN LIBRARY_SUBJECT_OFFERED AS LSO\n      ON LRMD.LIBRARY_SUBJECT_OFFERED_KEY = LSO.LIBRARY_SUBJECT_OFFERED_KEY\n    JOIN LIBRARY_MATERIAL_STATUS AS LMS\n      ON LRMD.LIBRARY_MATERIAL_STATUS_KEY = LMS.LIBRARY_MATERIAL_STATUS_KEY\n    GROUP BY\n      LSO.OFFER_DEPT_NAME,\n      LMS.LIBRARY_MATERIAL_STATUS\n  ) AS CombinedMaterials\nGROUP BY\n  department_name,\n  material_status WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each building that is not a subdivision, list the building number, full name, street address, building type, occupancy date, ownership type, and site location. You should also include three rows at the end showing the number of owned, leased, all buildings at MIT that are not subdivisions, in the format of (null, #building Buildings, null, null, null, null, null).",
        "predicted_sql": "SELECT\n  T1.BUILDING_NUMBER,\n  T1.BUILDING_NAME_LONG,\n  T3.BUILDING_STREET_ADDRESS,\n  T1.BUILDING_TYPE,\n  T1.DATE_OCCUPIED,\n  T1.OWNERSHIP_TYPE,\n  T1.SITE\nFROM FAC_BUILDING AS T1\nJOIN FAC_BUILDING_ADDRESS AS T2\n  ON T1.FAC_BUILDING_KEY = T2.BUILDING_KEY\nJOIN BUILDINGS AS T3\n  ON T2.BUILDING_KEY = T3.BUILDING_KEY\nWHERE\n  T1.PARENT_BUILDING_NUMBER IS NULL\nUNION ALL\nSELECT\n  NULL,\n  CONCAT(COUNT(CASE WHEN T1.OWNERSHIP_TYPE = 'OWNED' THEN 1 END), ' Owned Buildings'),\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL\nFROM FAC_BUILDING AS T1\nWHERE\n  T1.PARENT_BUILDING_NUMBER IS NULL AND T1.SITE = 'MIT'\nUNION ALL\nSELECT\n  NULL,\n  CONCAT(COUNT(CASE WHEN T1.OWNERSHIP_TYPE = 'LEASED' THEN 1 END), ' Leased Buildings'),\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL\nFROM FAC_BUILDING AS T1\nWHERE\n  T1.PARENT_BUILDING_NUMBER IS NULL AND T1.SITE = 'MIT'\nUNION ALL\nSELECT\n  NULL,\n  CONCAT(COUNT(*), ' All Buildings'),\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL\nFROM FAC_BUILDING AS T1\nWHERE\n  T1.PARENT_BUILDING_NUMBER IS NULL AND T1.SITE = 'MIT';"
    },
    {
        "db_id": "dw",
        "question": "For each owned building that is not a subdivision, list the construction start year, the building number, and the year of initial occupancy. Display the construction start year only if it differs from the previous row. If the year of initial occupancy or construction start year is unknown, display 'UNKNOWN'. You should also include a row at the end showing the total number of owned buildings that are not subdivisions, in the format of (null, #building Buildings, null).",
        "predicted_sql": "WITH FilteredBuildings AS (\n    SELECT\n        COALESCE(YEAR(STR_TO_DATE(T1.DATE_BUILT, '%m/%d/%Y')), 'UNKNOWN') AS ConstructedYearStr,\n        COALESCE(YEAR(STR_TO_DATE(T1.DATE_OCCUPIED, '%m/%d/%Y')), 'UNKNOWN') AS OccupancyYearStr,\n        T1.BUILDING_NUMBER,\n        YEAR(STR_TO_DATE(T1.DATE_BUILT, '%m/%d/%Y')) AS SortKey_BuiltYear,\n        T1.BUILDING_NUMBER AS SortKey_BuildingNumber\n    FROM\n        FAC_BUILDING AS T1\n    WHERE\n        T1.OWNERSHIP_TYPE = 'OWNED'\n        AND (T1.PARENT_BUILDING_NUMBER IS NULL OR T1.PARENT_BUILDING_NUMBER = '')\n),\nLaggedYears AS (\n    SELECT\n        ConstructedYearStr,\n        OccupancyYearStr,\n        BUILDING_NUMBER,\n        SortKey_BuiltYear,\n        SortKey_BuildingNumber,\n        LAG(ConstructedYearStr, 1, NULL) OVER (ORDER BY SortKey_BuiltYear, SortKey_BuildingNumber) AS PreviousConstructedYearStr\n    FROM\n        FilteredBuildings\n)\nSELECT\n    CASE\n        WHEN ConstructedYearStr = PreviousConstructedYearStr THEN NULL\n        ELSE ConstructedYearStr\n    END AS `Construction Start Year`,\n    BUILDING_NUMBER AS `Building Number`,\n    OccupancyYearStr AS `Year of Initial Occupancy`\nFROM\n    LaggedYears\n\nUNION ALL\n\nSELECT\n    NULL AS `Construction Start Year`,\n    CONCAT(COUNT(T1.FAC_BUILDING_KEY), ' Buildings') AS `Building Number`,\n    NULL AS `Year of Initial Occupancy`\nFROM\n    FAC_BUILDING AS T1\nWHERE\n    T1.OWNERSHIP_TYPE = 'OWNED'\n    AND (T1.PARENT_BUILDING_NUMBER IS NULL OR T1.PARENT_BUILDING_NUMBER = '')\n\nORDER BY\n    CASE WHEN `Building Number` LIKE '% Buildings' THEN 1 ELSE 0 END,\n    `Construction Start Year`,\n    `Building Number`;"
    },
    {
        "db_id": "dw",
        "question": "Group all buildings at MIT into either owned or leased. For each group, state the ownership type, usage type, number of buildings, gross square footage, number of rooms, and the number of associated organizations. Display the ownership type only if it differs from the previous row. Include subtotals for each group and a grand total across all groups. The subtotal and grand total rows should not include ownership type and usage type. Footage should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "```mysql\nWITH RolledUpData AS (\n    SELECT\n        fbh.OWNERSHIP_TYPE,\n        fbh.BUILDING_USE,\n        COUNT(DISTINCT fbh.FCLT_BUILDING_KEY) AS NumBuildings,\n        SUM(fbh.EXT_GROSS_AREA) AS GrossArea,\n        COUNT(DISTINCT fr.FCLT_ROOM_KEY) AS NumRooms,\n        COUNT(DISTINCT fo.FCLT_ORGANIZATION_KEY) AS NumOrgs,\n        GROUPING(fbh.OWNERSHIP_TYPE) AS grp_ownership,\n        GROUPING(fbh.BUILDING_USE) AS grp_building_use\n    FROM\n        FCLT_BUILDING_HIST AS fbh\n    LEFT JOIN\n        FCLT_ROOMS AS fr ON fbh.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY\n    LEFT JOIN\n        FCLT_ORGANIZATION AS fo ON fr.FCLT_ORGANIZATION_KEY = fo.FCLT_ORGANIZATION_KEY\n    WHERE\n        fbh.SITE = 'MIT'\n    GROUP BY\n        fbh.OWNERSHIP_TYPE,\n        fbh.BUILDING_USE WITH ROLLUP\n)\nSELECT\n    CASE\n        -- Grand Total row (where grp_ownership is 1)\n        WHEN rd.grp_ownership = 1 THEN NULL\n        -- Ownership Subtotal row (where grp_building_use is 1 and grp_ownership is 0)\n        -- Per \"subtotal and grand total rows should not include ownership type\"\n        WHEN rd.grp_building_use = 1 THEN NULL\n        -- For detail rows, display ownership type only if it differs from the previous row\n        WHEN LAG(rd.OWNERSHIP_TYPE, 1, '') OVER (ORDER BY\n                                                   CASE WHEN rd.grp_ownership = 1 THEN 2 ELSE 1 END,\n                                                   rd.OWNERSHIP_TYPE,\n                                                   CASE WHEN rd.grp_building_use = 1 THEN 2 ELSE 1 END,\n                                                   rd.BUILDING_USE) = rd.OWNERSHIP_TYPE AND\n             -- Ensure the previous row was also a detail row of the same ownership type\n             LAG(rd.grp_ownership, 1, 1) OVER (ORDER BY\n                                                   CASE WHEN rd.grp_ownership = 1 THEN 2 ELSE 1 END,\n                                                   rd.OWNERSHIP_TYPE,\n                                                   CASE WHEN rd.grp_building_use = 1 THEN 2 ELSE 1 END,\n                                                   rd.BUILDING_USE) = 0 AND\n             LAG(rd.grp_building_use, 1, 1) OVER (ORDER BY\n                                                   CASE WHEN rd.grp_ownership = 1 THEN 2 ELSE 1 END,\n                                                   rd.OWNERSHIP_TYPE,\n                                                   CASE WHEN rd.grp_building_use = 1 THEN 2 ELSE 1 END,\n                                                   rd.BUILDING_USE) = 0\n        THEN NULL\n        ELSE rd.OWNERSHIP_TYPE\n    END AS `Ownership Type`,\n    CASE\n        -- Grand Total row\n        WHEN rd.grp_ownership = 1 AND rd.grp_building_use = 1 THEN 'Grand Total'\n        -- Ownership Subtotal row\n        WHEN rd.grp_building_use = 1 THEN CONCAT('Subtotal for ', rd.OWNERSHIP_TYPE)\n        -- Detail row\n        ELSE rd.BUILDING_USE\n    END AS `Usage Type`,\n    rd.NumBuildings AS `Number of Buildings`,\n    FORMAT(ROUND(rd.GrossArea), 0) AS `Gross Square Footage`,\n    rd.NumRooms AS `Number of Rooms`,\n    rd.NumOrgs AS `Number of Associated Organizations`\nFROM\n    RolledUpData AS rd\nORDER BY\n    CASE WHEN rd.grp_ownership = 1 THEN 2 ELSE 1 END, -- Grand Total last\n    rd.OWNERSHIP_TYPE,\n    CASE WHEN rd.grp_building_use = 1 THEN 2 ELSE 1 END, -- Subtotals for ownership type after its detail rows\n    rd.BUILDING_USE;"
    },
    {
        "db_id": "dw",
        "question": "For each building use, list the type, the number of distinct buildings (excluding subdivisions) of this use, the total gross square footage of these buildings, and the number of unique organizations associated with the rooms in these buildings. If the building is used as a residence, display the usage type as \"RESIDENTIAL.\" You should also include a row at the end showing the total number of buildings, the gross square footage, and the number of organizations across all types of building use. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "```mysql\nSELECT\n  COALESCE(CASE WHEN T1.BUILDING_USE = 'RESIDENT' THEN 'RESIDENTIAL' ELSE T1.BUILDING_USE END, 'Total') AS `Building Use`,\n  FORMAT(ROUND(COUNT(DISTINCT T1.FCLT_BUILDING_KEY)), 0) AS `Number of Buildings`,\n  FORMAT(ROUND(SUM(T1.EXT_GROSS_AREA)), 0) AS `Total Gross Square Footage`,\n  FORMAT(ROUND(COUNT(DISTINCT T2.FCLT_ORGANIZATION_KEY)), 0) AS `Number of Organizations`\nFROM FCLT_BUILDING AS T1\nLEFT JOIN FCLT_ROOMS AS T2\n  ON T1.FCLT_BUILDING_KEY = T2.FCLT_BUILDING_KEY\nWHERE\n  T1.PARENT_BUILDING_NUMBER IS NULL\nGROUP BY\n  T1.BUILDING_USE WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each organization except Cambridge-MIT Institute, list its ID, number, level, formatted name according to level (if level is 2, there should be 1 space before the name, if level is 3, there should be 2 space before the name, up to level 6), whether it is assignable ('ASSIGNABLE' if assignable, 'NON-ASSIGNABLE' otherwise), total area, number of rooms, and average room area. Area and number of rooms should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT\n  T1.ORGANIZATION_ID AS ID,\n  T1.ORGANIZATION_NUMBER AS number,\n  T1.ORGANIZATION_LEVEL AS level,\n  CONCAT(REPEAT(' ', CAST(T1.ORGANIZATION_LEVEL AS UNSIGNED) - 1), T1.ORGANIZATION_NAME) AS formatted_name,\n  CASE\n    WHEN T1.ASSIGNABLE = '1'\n    THEN 'ASSIGNABLE'\n    ELSE 'NON-ASSIGNABLE'\n  END AS assignable,\n  FORMAT(COALESCE(SUM(T2.AREA), 0), 0) AS total_area,\n  FORMAT(COALESCE(COUNT(DISTINCT T2.ROOM), 0), 0) AS number_of_rooms,\n  COALESCE(AVG(T2.AREA), 0) AS average_room_area\nFROM FCLT_ORGANIZATION AS T1\nLEFT JOIN FCLT_ROOMS AS T2\n  ON T1.FCLT_ORGANIZATION_KEY = T2.FCLT_ORGANIZATION_KEY\nWHERE\n  T1.ORGANIZATION_NAME <> 'Cambridge-MIT Institute'\nGROUP BY\n  T1.ORGANIZATION_KEY,\n  T1.ORGANIZATION_ID,\n  T1.ORGANIZATION_NUMBER,\n  T1.ORGANIZATION_LEVEL,\n  T1.ORGANIZATION_NAME,\n  T1.ASSIGNABLE;"
    },
    {
        "db_id": "dw",
        "question": "Group all rooms into whether or not they are assignable and the major use descriptions. For each group, state \"ASSIGNABLE\" if the room is assignable and \"NON-ASSIGNABLE\" otherwise, the major use description, the total number of rooms, total area, and average area. Include subtotals for each group and a grand total across all groups. The assignable status and major use descriptions should only be displayed when they differ from the previous row. Do not include rooms whose major use or major use description starts with 'ZUSE.' The results should be sorted by assignable status and major use description. The subtotal and grand total rows should not include assignable status or major use description.",
        "predicted_sql": "WITH RolledUpData AS (\n    SELECT\n        fm.ASSIGNABLE,\n        fm.DESCRIPTION AS MAJOR_USE_DESCRIPTION_RAW,\n        COUNT(fr.FCLT_ROOM_KEY) AS total_rooms,\n        SUM(fr.AREA) AS total_area,\n        AVG(fr.AREA) AS average_area,\n        GROUPING(fm.ASSIGNABLE) AS grouping_assignable,\n        GROUPING(fm.DESCRIPTION) AS grouping_description\n    FROM FCLT_ROOMS AS fr\n    JOIN FCLT_MAJOR_USE AS fm\n        ON fr.FCLT_MAJOR_USE_KEY = fm.FCLT_MAJOR_USE_KEY\n    WHERE\n        fm.MAJOR_USE NOT LIKE 'ZUSE%'\n        AND fm.DESCRIPTION NOT LIKE 'ZUSE%'\n    GROUP BY\n        fm.ASSIGNABLE,\n        fm.DESCRIPTION WITH ROLLUP\n),\nPreparedData AS (\n    SELECT\n        rd.ASSIGNABLE,\n        rd.MAJOR_USE_DESCRIPTION_RAW,\n        CASE WHEN rd.ASSIGNABLE = '1' THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END AS current_assignable_status_text,\n        rd.MAJOR_USE_DESCRIPTION_RAW AS current_major_use_desc_text,\n        rd.total_rooms,\n        rd.total_area,\n        rd.average_area,\n        rd.grouping_assignable,\n        rd.grouping_description,\n        -- Calculate previous assignable status for suppression logic\n        LAG(CASE WHEN rd.grouping_assignable = 0 AND rd.grouping_description = 0 THEN (CASE WHEN rd.ASSIGNABLE = '1' THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END) END)\n            OVER (ORDER BY rd.ASSIGNABLE IS NULL, rd.ASSIGNABLE ASC, rd.MAJOR_USE_DESCRIPTION_RAW IS NULL, rd.MAJOR_USE_DESCRIPTION_RAW ASC) AS prev_assignable_status_overall,\n        -- Calculate previous major use description, partitioned by assignable status for suppression logic within groups\n        LAG(CASE WHEN rd.grouping_assignable = 0 AND rd.grouping_description = 0 THEN rd.MAJOR_USE_DESCRIPTION_RAW END)\n            OVER (PARTITION BY rd.ASSIGNABLE ORDER BY rd.MAJOR_USE_DESCRIPTION_RAW IS NULL, rd.MAJOR_USE_DESCRIPTION_RAW ASC) AS prev_major_use_desc_partitioned\n    FROM RolledUpData AS rd\n)\nSELECT\n    CASE\n        -- Suppress assignable status for subtotal and grand total rows\n        WHEN pd.grouping_assignable = 1 OR pd.grouping_description = 1 THEN NULL\n        -- Display assignable status only if it's the first in its group or different from the previous row\n        WHEN pd.current_assignable_status_text <> pd.prev_assignable_status_overall OR pd.prev_assignable_status_overall IS NULL THEN pd.current_assignable_status_text\n        ELSE NULL -- Suppress if same as previous detail row\n    END AS `Assignable Status`,\n    CASE\n        -- Suppress major use description for subtotal and grand total rows\n        WHEN pd.grouping_description = 1 THEN NULL\n        -- Display major use description only if it's the first in its assignable group or different from the previous row within that group\n        WHEN pd.current_major_use_desc_text <> pd.prev_major_use_desc_partitioned OR pd.prev_major_use_desc_partitioned IS NULL THEN pd.current_major_use_desc_text\n        ELSE NULL -- Suppress if same as previous detail row in the same assignable group\n    END AS `Major Use Description`,\n    pd.total_rooms AS `Total Rooms`,\n    pd.total_area AS `Total Area`,\n    pd.average_area AS `Average Area`\nFROM PreparedData AS pd\nORDER BY\n    pd.ASSIGNABLE IS NULL, pd.ASSIGNABLE ASC,\n    pd.MAJOR_USE_DESCRIPTION_RAW IS NULL, pd.MAJOR_USE_DESCRIPTION_RAW ASC;"
    },
    {
        "db_id": "dw",
        "question": "List each floor key and department name within the Stata building, as well as the number of rooms, total area, and average area per department on each floor. Include subtotals for each floor and a grand total across all floors. Sort the results by floor key and department name in ascending order. Exclude departments without any rooms in the building. Only the first row of each floor group should include the floor key, and the subtotal and grand total rows should not include floor key or department name. Number of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT\n    CASE WHEN T.rn = 1 THEN T.FLOOR_KEY ELSE NULL END AS `floor key`,\n    T.ORGANIZATION_NAME AS `department name`,\n    FORMAT(ROUND(T.num_rooms), 0) AS `number of rooms`,\n    FORMAT(ROUND(T.total_area), 0) AS `total area`,\n    FORMAT(ROUND(T.avg_area), 0) AS `average area`\nFROM (\n    SELECT\n        FR.FLOOR_KEY,\n        FO.ORGANIZATION_NAME,\n        COUNT(FR.FAC_ROOM_KEY) AS num_rooms,\n        SUM(FR.AREA) AS total_area,\n        AVG(FR.AREA) AS avg_area,\n        ROW_NUMBER() OVER (PARTITION BY FR.FLOOR_KEY ORDER BY FO.ORGANIZATION_NAME ASC) as rn,\n        1 as _sort_level,\n        FR.FLOOR_KEY as _sort_floor,\n        FO.ORGANIZATION_NAME as _sort_dept\n    FROM\n        BUILDINGS AS B\n    INNER JOIN\n        FAC_ROOMS AS FR ON B.BUILDING_KEY = FR.BUILDING_KEY\n    INNER JOIN\n        FCLT_ORGANIZATION AS FO ON FR.ORGANIZATION_KEY = FO.FCLT_ORGANIZATION_KEY\n    WHERE\n        B.BUILDING_NAME = 'Stata building'\n    GROUP BY\n        FR.FLOOR_KEY,\n        FO.ORGANIZATION_NAME\n    HAVING\n        COUNT(FR.FAC_ROOM_KEY) > 0\n) AS T\n\nUNION ALL\n\n-- Floor Subtotals\nSELECT\n    NULL AS `floor key`,\n    NULL AS `department name`,\n    FORMAT(ROUND(COUNT(FR.FAC_ROOM_KEY)), 0) AS `number of rooms`,\n    FORMAT(ROUND(SUM(FR.AREA)), 0) AS `total area`,\n    FORMAT(ROUND(SUM(FR.AREA) / COUNT(FR.FAC_ROOM_KEY)), 0) AS `average area`,\n    2 as _sort_level,\n    FR.FLOOR_KEY as _sort_floor,\n    NULL as _sort_dept\nFROM\n    BUILDINGS AS B\nINNER JOIN\n    FAC_ROOMS AS FR ON B.BUILDING_KEY = FR.BUILDING_KEY\nINNER JOIN\n    FCLT_ORGANIZATION AS FO ON FR.ORGANIZATION_KEY = FO.FCLT_ORGANIZATION_KEY\nWHERE\n    B.BUILDING_NAME = 'Stata building'\nGROUP BY\n    FR.FLOOR_KEY\nHAVING\n    COUNT(FR.FAC_ROOM_KEY) > 0\n\nUNION ALL\n\n-- Grand Total\nSELECT\n    NULL AS `floor key`,\n    NULL AS `department name`,\n    FORMAT(ROUND(COUNT(FR.FAC_ROOM_KEY)), 0) AS `number of rooms`,\n    FORMAT(ROUND(SUM(FR.AREA)), 0) AS `total area`,\n    FORMAT(ROUND(SUM(FR.AREA) / COUNT(FR.FAC_ROOM_KEY)), 0) AS `average area`,\n    3 as _sort_level,\n    NULL as _sort_floor,\n    NULL as _sort_dept\nFROM\n    BUILDINGS AS B\nINNER JOIN\n    FAC_ROOMS AS FR ON B.BUILDING_KEY = FR.BUILDING_KEY\nINNER JOIN\n    FCLT_ORGANIZATION AS FO ON FR.ORGANIZATION_KEY = FO.FCLT_ORGANIZATION_KEY\nWHERE\n    B.BUILDING_NAME = 'Stata building'\nHAVING\n    COUNT(FR.FAC_ROOM_KEY) > 0\n\nORDER BY\n    _sort_floor ASC,\n    _sort_level ASC,\n    _sort_dept ASC;"
    },
    {
        "db_id": "dw",
        "question": "List each building key and floor key within the department of facilities, the number of rooms, total area, average area per floor, building name, access level, zip code, and city. Include subtotals for each building and a grand total across all buildings. The subtotals and grand total should not include zip code or city. Numbers of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT\n  COALESCE(FR.BUILDING_KEY, 'Grand Total') AS `Building Key`,\n  CASE\n    WHEN GROUPING(FR.FLOOR_KEY) = 1 AND GROUPING(FR.BUILDING_KEY) = 0\n    THEN 'Building Subtotal'\n    WHEN GROUPING(FR.FLOOR_KEY) = 0\n    THEN FR.FLOOR_KEY\n    ELSE NULL\n  END AS `Floor Key`,\n  FORMAT(ROUND(COUNT(FR.FAC_ROOM_KEY)), 0) AS `Number of Rooms`,\n  FORMAT(ROUND(SUM(CAST(FR.AREA AS DECIMAL(10, 2)))), 0) AS `Total Area`,\n  FORMAT(ROUND(SUM(CAST(FR.AREA AS DECIMAL(10, 2))) / COUNT(DISTINCT FR.FLOOR_KEY)), 0) AS `Average Area Per Floor`,\n  CASE\n    WHEN GROUPING(FR.BUILDING_KEY) = 1\n    THEN NULL\n    ELSE FB.BUILDING_NAME_LONG\n  END AS `Building Name`,\n  CASE\n    WHEN GROUPING(FR.BUILDING_KEY) = 1\n    THEN NULL\n    ELSE FB.ACCESS_LEVEL_NAME\n  END AS `Access Level`,\n  CASE\n    WHEN GROUPING(FR.FLOOR_KEY) = 0\n    THEN FBA.POSTAL_CODE\n    ELSE NULL\n  END AS `Zip Code`,\n  CASE\n    WHEN GROUPING(FR.FLOOR_KEY) = 0\n    THEN FBA.CITY\n    ELSE NULL\n  END AS `City`\nFROM FAC_ROOMS AS FR\nJOIN FAC_BUILDING AS FB\n  ON FR.BUILDING_KEY = FB.FAC_BUILDING_KEY\nJOIN FAC_ORGANIZATION AS FO\n  ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY\nLEFT JOIN FAC_BUILDING_ADDRESS AS FBA\n  ON FB.FAC_BUILDING_KEY = FBA.BUILDING_KEY\nWHERE\n  FR.ORGANIZATION_NAME = 'DOF'\nGROUP BY\n  FR.BUILDING_KEY,\n  FR.FLOOR_KEY,\n  FB.BUILDING_NAME_LONG,\n  FB.ACCESS_LEVEL_NAME,\n  FBA.POSTAL_CODE,\n  FBA.CITY WITH ROLLUP\nORDER BY\n  CASE\n    WHEN FR.BUILDING_KEY IS NULL\n    THEN 1\n    ELSE 0\n  END,\n  FR.BUILDING_KEY,\n  CASE\n    WHEN FR.FLOOR_KEY IS NULL\n    THEN 1\n    ELSE 0\n  END,\n  FR.FLOOR_KEY;"
    },
    {
        "db_id": "dw",
        "question": "List the department, school, course number, subject title, total number of enrolled students, term code, and count of distinct catalog ISBNs. Add a summary row at the bottom showing the total number of students and distinct catalog ISBNs for the current term in the format of ('TOTAL:', null, null, null, total number of students, null, number of distinct catalog ISBNs).",
        "predicted_sql": "SELECT\n  T1.OFFER_DEPT_NAME,\n  T1.OFFER_SCHOOL_NAME,\n  T1.COURSE_NUMBER,\n  T1.SUBJECT_TITLE,\n  T1.NUM_ENROLLED_STUDENTS,\n  T1.TERM_CODE,\n  COUNT(DISTINCT T3.CATALOG_ISBN) AS distinct_catalog_isbns\nFROM LIBRARY_SUBJECT_OFFERED AS T1\nJOIN LIBRARY_RESERVE_MATRL_DETAIL AS T2\n  ON T1.LIBRARY_SUBJECT_OFFERED_KEY = T2.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN LIBRARY_RESERVE_CATALOG AS T3\n  ON T2.LIBRARY_RESERVE_CATALOG_KEY = T3.LIBRARY_RESERVE_CATALOG_KEY\nJOIN ACADEMIC_TERM_PARAMETER AS T4\n  ON T1.TERM_CODE = T4.TERM_CODE\nWHERE\n  T4.IS_CURRENT_TERM = 'Y'\nGROUP BY\n  T1.OFFER_DEPT_NAME,\n  T1.OFFER_SCHOOL_NAME,\n  T1.COURSE_NUMBER,\n  T1.SUBJECT_TITLE,\n  T1.NUM_ENROLLED_STUDENTS,\n  T1.TERM_CODE\nUNION ALL\nSELECT\n  'TOTAL:' AS OFFER_DEPT_NAME,\n  NULL AS OFFER_SCHOOL_NAME,\n  NULL AS COURSE_NUMBER,\n  NULL AS SUBJECT_TITLE,\n  (\n    SELECT\n      SUM(sq.NUM_ENROLLED_STUDENTS)\n    FROM (\n      SELECT DISTINCT\n        LSO.LIBRARY_SUBJECT_OFFERED_KEY,\n        LSO.NUM_ENROLLED_STUDENTS\n      FROM LIBRARY_SUBJECT_OFFERED AS LSO\n      JOIN ACADEMIC_TERM_PARAMETER AS ATP\n        ON LSO.TERM_CODE = ATP.TERM_CODE\n      WHERE\n        ATP.IS_CURRENT_TERM = 'Y'\n    ) AS sq\n  ) AS total_enrolled_students,\n  NULL AS TERM_CODE,\n  COUNT(DISTINCT T3_summary.CATALOG_ISBN) AS distinct_catalog_isbns\nFROM LIBRARY_RESERVE_MATRL_DETAIL AS T2_summary\nJOIN LIBRARY_RESERVE_CATALOG AS T3_summary\n  ON T2_summary.LIBRARY_RESERVE_CATALOG_KEY = T3_summary.LIBRARY_RESERVE_CATALOG_KEY\nJOIN LIBRARY_SUBJECT_OFFERED AS T1_summary\n  ON T2_summary.LIBRARY_SUBJECT_OFFERED_KEY = T1_summary.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN ACADEMIC_TERM_PARAMETER AS T4_summary\n  ON T1_summary.TERM_CODE = T4_summary.TERM_CODE\nWHERE\n  T4_summary.IS_CURRENT_TERM = 'Y';"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list that involves subscribers that work in departments with names starting with 'Computer Science', state the ownership type, the list name, the number of owners, and the number of subscribers. Display the ownership type only if it differs from the previous entry. Include subtotals (the corresponding type field shoud be 'SUBTOTAL') for each ownership type and a grand total (the corresponding type field shoud be 'TOTAL') across all ownership types.",
        "predicted_sql": "SELECT\n  CASE\n    WHEN GROUPING(T3.OWNER_TYPE) = 1 AND GROUPING(T2.MOIRA_LIST_NAME) = 1\n    THEN 'TOTAL'\n    WHEN GROUPING(T3.OWNER_TYPE) = 1\n    THEN 'SUBTOTAL'\n    ELSE T3.OWNER_TYPE\n  END AS `Ownership Type`,\n  CASE\n    WHEN GROUPING(T2.MOIRA_LIST_NAME) = 1\n    THEN 'SUBTOTAL'\n    ELSE T2.MOIRA_LIST_NAME\n  END AS `List Name`,\n  COUNT(DISTINCT T3.OWNER) AS `Number of Owners`,\n  COUNT(DISTINCT T1.MOIRA_LIST_MEMBER_MIT_ID) AS `Number of Subscribers`\nFROM MOIRA_LIST_DETAIL AS T1\nINNER JOIN MOIRA_LIST AS T2\n  ON T1.MOIRA_LIST_KEY = T2.MOIRA_LIST_KEY\nINNER JOIN MOIRA_LIST_OWNER AS T3\n  ON T1.MOIRA_LIST_OWNER_KEY = T3.MOIRA_LIST_OWNER_KEY\nINNER JOIN EMPLOYEE_DIRECTORY AS T4\n  ON T1.MOIRA_LIST_MEMBER_MIT_ID = T4.MIT_ID\nWHERE\n  T4.DEPARTMENT_NAME LIKE 'Computer Science%' AND T2.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY\n  T3.OWNER_TYPE,\n  T2.MOIRA_LIST_NAME WITH ROLLUP\nORDER BY\n  CASE\n    WHEN GROUPING(T3.OWNER_TYPE) = 1\n    THEN 2\n    ELSE 1\n  END,\n  T3.OWNER_TYPE,\n  CASE\n    WHEN GROUPING(T2.MOIRA_LIST_NAME) = 1\n    THEN 2\n    ELSE 1\n  END,\n  T2.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list its name, number of unique sessions, total number of attendees, active period (in the format of 'beginning term code-end term code'), the most common sponsor name, and the most common session start time. Include a grand total row showing the total number of sessions and attendees across all categories in the format of ('TOTAL', number of sessions, number of attendees, null, null, null).",
        "predicted_sql": "WITH CategorySponsorCounts AS (\n    SELECT\n        T1.IAP_SUBJECT_CATEGORY_KEY,\n        T4.SPONSOR_NAME,\n        COUNT(T4.SPONSOR_NAME) AS sponsor_count,\n        ROW_NUMBER() OVER(PARTITION BY T1.IAP_SUBJECT_CATEGORY_KEY ORDER BY COUNT(T4.SPONSOR_NAME) DESC, T4.SPONSOR_NAME) as rn\n    FROM\n        IAP_SUBJECT_CATEGORY AS T1\n    JOIN\n        IAP_SUBJECT_DETAIL AS T2 ON T1.IAP_SUBJECT_CATEGORY_KEY = T2.IAP_SUBJECT_CATEGORY_KEY\n    JOIN\n        IAP_SUBJECT_SPONSOR AS T4 ON T2.IAP_SUBJECT_SPONSOR_KEY = T4.IAP_SUBJECT_SPONSOR_KEY\n    GROUP BY\n        T1.IAP_SUBJECT_CATEGORY_KEY, T4.SPONSOR_NAME\n),\nMostCommonSponsor AS (\n    SELECT\n        IAP_SUBJECT_CATEGORY_KEY,\n        SPONSOR_NAME\n    FROM\n        CategorySponsorCounts\n    WHERE\n        rn = 1\n),\nCategorySessionStartCounts AS (\n    SELECT\n        T1.IAP_SUBJECT_CATEGORY_KEY,\n        T3.SESSION_START_TIME,\n        COUNT(T3.SESSION_START_TIME) AS start_time_count,\n        ROW_NUMBER() OVER(PARTITION BY T1.IAP_SUBJECT_CATEGORY_KEY ORDER BY COUNT(T3.SESSION_START_TIME) DESC, T3.SESSION_START_TIME) as rn\n    FROM\n        IAP_SUBJECT_CATEGORY AS T1\n    JOIN\n        IAP_SUBJECT_DETAIL AS T2 ON T1.IAP_SUBJECT_CATEGORY_KEY = T2.IAP_SUBJECT_CATEGORY_KEY\n    JOIN\n        IAP_SUBJECT_SESSION AS T3 ON T2.IAP_SUBJECT_SESSION_KEY = T3.IAP_SUBJECT_SESSION_KEY\n    GROUP BY\n        T1.IAP_SUBJECT_CATEGORY_KEY, T3.SESSION_START_TIME\n),\nMostCommonSessionStart AS (\n    SELECT\n        IAP_SUBJECT_CATEGORY_KEY,\n        SESSION_START_TIME\n    FROM\n        CategorySessionStartCounts\n    WHERE\n        rn = 1\n)\nSELECT\n    T1.IAP_CATEGORY_NAME,\n    COUNT(DISTINCT T3.IAP_SUBJECT_SESSION_KEY) AS NumberOfUniqueSessions,\n    SUM(T2.MAX_ENROLLMENT) AS TotalAttendees,\n    CONCAT(MIN(T2.TERM_CODE), '-', MAX(T2.TERM_CODE)) AS ActivePeriod,\n    MCS.SPONSOR_NAME AS MostCommonSponsorName,\n    MCSS.SESSION_START_TIME AS MostCommonSessionStartTime\nFROM\n    IAP_SUBJECT_CATEGORY AS T1\nLEFT JOIN\n    IAP_SUBJECT_DETAIL AS T2 ON T1.IAP_SUBJECT_CATEGORY_KEY = T2.IAP_SUBJECT_CATEGORY_KEY\nLEFT JOIN\n    IAP_SUBJECT_SESSION AS T3 ON T2.IAP_SUBJECT_SESSION_KEY = T3.IAP_SUBJECT_SESSION_KEY\nLEFT JOIN\n    IAP_SUBJECT_SPONSOR AS T4 ON T2.IAP_SUBJECT_SPONSOR_KEY = T4.IAP_SUBJECT_SPONSOR_KEY\nLEFT JOIN\n    MostCommonSponsor AS MCS ON T1.IAP_SUBJECT_CATEGORY_KEY = MCS.IAP_SUBJECT_CATEGORY_KEY\nLEFT JOIN\n    MostCommonSessionStart AS MCSS ON T1.IAP_SUBJECT_CATEGORY_KEY = MCSS.IAP_SUBJECT_CATEGORY_KEY\nGROUP BY\n    T1.IAP_SUBJECT_CATEGORY_KEY, T1.IAP_CATEGORY_NAME\nUNION ALL\nSELECT\n    'TOTAL',\n    COUNT(DISTINCT T3_total.IAP_SUBJECT_SESSION_KEY),\n    SUM(T2_total.MAX_ENROLLMENT),\n    NULL,\n    NULL,\n    NULL\nFROM\n    IAP_SUBJECT_DETAIL AS T2_total\nJOIN\n    IAP_SUBJECT_SESSION AS T3_total ON T2_total.IAP_SUBJECT_SESSION_KEY = T3_total.IAP_SUBJECT_SESSION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "For each building type, list the name of the building type, the number of buildings that are not subdivisions, number of employees, number of unique building street address, number of unique city, number of unique state, number of unique postal code, and average gross square footage per employee. For building type of 'resident', display it as 'RESIDENTIAL'. Include a grand total across all building types (the corresponding type field is 'TOTAL').",
        "predicted_sql": "SELECT\n  CASE\n    WHEN GROUPING(T1.BUILDING_TYPE) = 1\n    THEN 'TOTAL'\n    WHEN T1.BUILDING_TYPE = 'RESIDENT'\n    THEN 'RESIDENTIAL'\n    ELSE T1.BUILDING_TYPE\n  END AS `Building Type Name`,\n  COUNT(DISTINCT CASE WHEN T1.PARENT_BUILDING_NUMBER IS NULL THEN T1.FCLT_BUILDING_KEY ELSE NULL END) AS `Number of Buildings That Are Not Subdivisions`,\n  COUNT(DISTINCT T5.MIT_ID) AS `Number of Employees`,\n  COUNT(DISTINCT T2.BUILDING_STREET_ADDRESS) AS `Number of Unique Building Street Address`,\n  COUNT(DISTINCT T3.CITY) AS `Number of Unique City`,\n  COUNT(DISTINCT T3.STATE) AS `Number of Unique State`,\n  COUNT(DISTINCT T3.POSTAL_CODE) AS `Number of Unique Postal Code`,\n  SUM(T1.EXT_GROSS_AREA) / NULLIF(COUNT(DISTINCT T5.MIT_ID), 0) AS `Average Gross Square Footage Per Employee`\nFROM FCLT_BUILDING_HIST AS T1\nLEFT JOIN BUILDINGS AS T2\n  ON T1.FCLT_BUILDING_KEY = T2.BUILDING_KEY\nLEFT JOIN FAC_BUILDING_ADDRESS AS T3\n  ON T1.FCLT_BUILDING_KEY = T3.BUILDING_KEY\nLEFT JOIN FAC_ROOMS AS T4\n  ON T2.BUILDING_KEY = T4.BUILDING_KEY\nLEFT JOIN EMPLOYEE_DIRECTORY AS T5\n  ON T4.FAC_ROOM_KEY = T5.OFFICE_LOCATION\nGROUP BY\n  T1.BUILDING_TYPE WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "Group spaces in the Stata building by the access level and usage type. For each group, state the access level, usage type, name of the space, the number of spaces, total area across all rooms in the space, and average area across all rooms in the space. Display the access level only if it differs from the previous entry. Include subtotals for each access level, usage type, and space name, subtotals for each access level, and a grand total across all access levels. Exclude usage type that includes \"STORAGE\". All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT\n  CASE\n    WHEN GROUPING(T4.ACCESS_LEVEL) = 1\n    THEN 'Grand Total'\n    WHEN GROUPING(T2.SPACE_USAGE) = 1\n    THEN CONCAT('Subtotal for Access Level: ', T4.ACCESS_LEVEL)\n    WHEN GROUPING(T3.DLC_NAME) = 1\n    THEN CONCAT('Subtotal for Usage Type: ', T2.SPACE_USAGE)\n    ELSE T4.ACCESS_LEVEL\n  END AS `Access Level`,\n  CASE\n    WHEN GROUPING(T4.ACCESS_LEVEL) = 1\n    THEN NULL\n    WHEN GROUPING(T2.SPACE_USAGE) = 1\n    THEN NULL\n    WHEN GROUPING(T3.DLC_NAME) = 1\n    THEN T2.SPACE_USAGE\n    ELSE T2.SPACE_USAGE\n  END AS `Usage Type`,\n  CASE\n    WHEN GROUPING(T4.ACCESS_LEVEL) = 1\n    THEN NULL\n    WHEN GROUPING(T2.SPACE_USAGE) = 1\n    THEN NULL\n    WHEN GROUPING(T3.DLC_NAME) = 1\n    THEN NULL\n    ELSE T3.DLC_NAME\n  END AS `Name of Space`,\n  FORMAT(ROUND(COUNT(T1.BUILDING_ROOM)), 0) AS `Number of Spaces`,\n  FORMAT(ROUND(SUM(T1.ROOM_SQUARE_FOOTAGE)), 0) AS `Total Area`,\n  FORMAT(ROUND(AVG(T1.ROOM_SQUARE_FOOTAGE)), 0) AS `Average Area`\nFROM SPACE_DETAIL AS T1\nJOIN SPACE_USAGE AS T2\n  ON T1.SPACE_USAGE_KEY = T2.SPACE_USAGE_KEY\nJOIN SPACE_UNIT AS T5\n  ON T1.SPACE_UNIT_KEY = T5.SPACE_UNIT_KEY\nJOIN FCLT_ORGANIZATION AS T3\n  ON T5.FCLT_ORGANIZATION_KEY = T3.FCLT_ORGANIZATION_KEY\nJOIN ZPM_ROOMS_LOAD AS T4\n  ON T1.BUILDING_ROOM = T4.BUILDING_ROOM AND T1.BUILDING_COMPONENT = T4.BUILDING_COMPONENT\nWHERE\n  T1.BUILDING_KEY = '1' AND T2.SPACE_USAGE NOT LIKE '%STORAGE%'\nGROUP BY\n  T4.ACCESS_LEVEL,\n  T2.SPACE_USAGE,\n  T3.DLC_NAME WITH ROLLUP\nORDER BY\n  T4.ACCESS_LEVEL IS NULL,\n  T4.ACCESS_LEVEL,\n  T2.SPACE_USAGE IS NULL,\n  T2.SPACE_USAGE,\n  T3.DLC_NAME IS NULL,\n  T3.DLC_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List each organization's break group, ID, name, and formatted name according to its level, along with whether its members are emeritus or non-emeritus. Also, include the organization number, level, employer count, and hierarchy type for each organization. Exclude organizations '139' and '250'. Sort the results by hierarchy type and ensure totals for employer counts are displayed.",
        "predicted_sql": "SELECT\n  COALESCE(MDH.HIERARCHY_TYPE, 'Total for All Hierarchy Types') AS `hierarchy type`,\n  COALESCE(FO.ORGANIZATION_SORT, 'Total') AS `break group`,\n  COALESCE(FO.ORGANIZATION_ID, 'Total') AS ID,\n  COALESCE(FO.ORGANIZATION_NAME, 'Total') AS name,\n  CASE\n    WHEN GROUPING(FO.ORGANIZATION_ID) = 1\n    THEN 'Total'\n    ELSE CONCAT(REPEAT(' ', (CAST(FO.ORGANIZATION_LEVEL AS UNSIGNED) - 1) * 2), FO.ORGANIZATION_NAME)\n  END AS `formatted name`,\n  CASE\n    WHEN HFR.EMERITUS_STATUS = 'Emeritus'\n    THEN 'Emeritus'\n    WHEN HFR.EMERITUS_STATUS IS NOT NULL\n    THEN 'Non-Emeritus'\n    WHEN GROUPING(HFR.EMERITUS_STATUS) = 1\n    THEN 'Total'\n    ELSE 'No Faculty Info'\n  END AS `emeritus status`,\n  COALESCE(FO.ORGANIZATION_NUMBER, 'Total') AS `organization number`,\n  COALESCE(FO.ORGANIZATION_LEVEL, 'Total') AS level,\n  COUNT(DISTINCT HFR.MIT_ID) AS `employer count`\nFROM FCLT_ORGANIZATION AS FO\nLEFT JOIN HR_ORG_UNIT AS HOU\n  ON FO.DLC_KEY = HOU.DLC_KEY\nLEFT JOIN HR_FACULTY_ROSTER AS HFR\n  ON HOU.HR_ORG_UNIT_TITLE = HFR.HR_ORG_UNIT_TITLE\nLEFT JOIN MASTER_DEPT_HIERARCHY AS MDH\n  ON FO.DLC_KEY = MDH.DLC_KEY\nWHERE\n  FO.ORGANIZATION_ID NOT IN ('139', '250')\nGROUP BY\n  MDH.HIERARCHY_TYPE,\n  FO.ORGANIZATION_SORT,\n  FO.ORGANIZATION_ID,\n  FO.ORGANIZATION_NAME,\n  FO.ORGANIZATION_LEVEL,\n  HFR.EMERITUS_STATUS,\n  FO.ORGANIZATION_NUMBER WITH ROLLUP\nORDER BY\n  CASE WHEN GROUPING(MDH.HIERARCHY_TYPE) = 1 THEN 1 ELSE 0 END,\n  MDH.HIERARCHY_TYPE ASC,\n  CASE WHEN GROUPING(FO.ORGANIZATION_SORT) = 1 THEN 1 ELSE 0 END,\n  FO.ORGANIZATION_SORT ASC,\n  CASE WHEN GROUPING(FO.ORGANIZATION_ID) = 1 THEN 1 ELSE 0 END,\n  FO.ORGANIZATION_ID ASC,\n  CASE WHEN GROUPING(FO.ORGANIZATION_NAME) = 1 THEN 1 ELSE 0 END,\n  FO.ORGANIZATION_NAME ASC,\n  CASE WHEN GROUPING(FO.ORGANIZATION_LEVEL) = 1 THEN 1 ELSE 0 END,\n  FO.ORGANIZATION_LEVEL ASC,\n  CASE WHEN GROUPING(HFR.EMERITUS_STATUS) = 1 THEN 1 ELSE 0 END,\n  HFR.EMERITUS_STATUS ASC,\n  CASE WHEN GROUPING(FO.ORGANIZATION_NUMBER) = 1 THEN 1 ELSE 0 END,\n  FO.ORGANIZATION_NUMBER ASC;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its title, name of the building of the course location, duration (in terms of days), and a running average of the duration (in terms of days) using a window of two preceding and two following courses (partitioned by academic year and sorted by course start date).",
        "predicted_sql": "SELECT\n  T1.SUBJECT_TITLE,\n  T4.BUILDING_NAME,\n  DATEDIFF(T2.TERM_END_DATE, T2.TERM_START_DATE) AS duration_days,\n  AVG(DATEDIFF(T2.TERM_END_DATE, T2.TERM_START_DATE)) OVER (\n    PARTITION BY\n      T2.ACADEMIC_YEAR\n    ORDER BY\n      T2.TERM_START_DATE ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING\n  ) AS running_avg_duration_days\nFROM COURSE_CATALOG_SUBJECT_OFFERED AS T1\nINNER JOIN ACADEMIC_TERMS AS T2\n  ON T1.EFFECTIVE_TERM_CODE = T2.TERM_CODE\nLEFT JOIN FCLT_ROOMS AS T3\n  ON T1.MEET_PLACE = T3.BUILDING_ROOM\nLEFT JOIN FCLT_BUILDING AS T4\n  ON T3.FCLT_BUILDING_KEY = T4.FCLT_BUILDING_KEY;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, the start date, the name of the course before it, and the name of the course after it, access level of the building, and the assignable area of the room used for the course, sorted by the ascending order start date and course name.",
        "predicted_sql": "SELECT\n  T1.SUBJECT_TITLE,\n  T4.BUILDING_NAME_LONG,\n  T2.TERM_START_DATE,\n  LAG(T1.SUBJECT_TITLE, 1) OVER (\n    ORDER BY\n      T2.TERM_START_DATE,\n      T1.SUBJECT_TITLE\n  ) AS PREVIOUS_COURSE_NAME,\n  LEAD(T1.SUBJECT_TITLE, 1) OVER (\n    ORDER BY\n      T2.TERM_START_DATE,\n      T1.SUBJECT_TITLE\n  ) AS NEXT_COURSE_NAME,\n  T4.ACCESS_LEVEL_NAME,\n  T3.AREA\nFROM COURSE_CATALOG_SUBJECT_OFFERED AS T1\nINNER JOIN ACADEMIC_TERMS AS T2\n  ON T1.TERM_CODE = T2.TERM_CODE\nINNER JOIN FCLT_ROOMS AS T3\n  ON T1.MEET_PLACE = T3.BUILDING_ROOM\nINNER JOIN FCLT_BUILDING AS T4\n  ON T3.FCLT_BUILDING_KEY = T4.FCLT_BUILDING_KEY\nORDER BY\n  T2.TERM_START_DATE,\n  T1.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, and the cumulative number of courses, including the course itself, held in the same year or preceding years (partitioned by academic year and sorted in the ascending order of course start date).",
        "predicted_sql": "```mysql\nSELECT\n  T1.SUBJECT_TITLE AS course_name,\n  T4.BUILDING_NAME AS building_name,\n  COUNT(T1.SUBJECT_ID) OVER (PARTITION BY T1.ACADEMIC_YEAR ORDER BY T2.TERM_START_DATE) AS cumulative_courses\nFROM COURSE_CATALOG_SUBJECT_OFFERED AS T1\nJOIN ACADEMIC_TERMS AS T2\n  ON T1.EFFECTIVE_TERM_CODE = T2.TERM_CODE\nJOIN FCLT_ROOMS AS T3\n  ON T1.MEET_PLACE = T3.FCLT_ROOM_KEY\nJOIN FCLT_BUILDING AS T4\n  ON T3.FCLT_BUILDING_KEY = T4.FCLT_BUILDING_KEY\nORDER BY\n  T1.ACADEMIC_YEAR,\n  T2.TERM_START_DATE;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the cluster type. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), cluster type, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and cluster type.",
        "predicted_sql": "SELECT\n    CASE\n        WHEN GROUPING(CASE WHEN T.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END) = 1 AND GROUPING(S.CLUSTER_TYPE) = 1 THEN 'TOTAL'\n        WHEN GROUPING(S.CLUSTER_TYPE) = 1 THEN 'SUBTOTAL'\n        ELSE (CASE WHEN T.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END)\n    END AS `Current Status`,\n    CASE\n        WHEN GROUPING(S.CLUSTER_TYPE) = 1 THEN NULL\n        ELSE S.CLUSTER_TYPE\n    END AS `Cluster Type`,\n    MAX(DATEDIFF(T.TERM_END_DATE, T.TERM_START_DATE)) AS `Maximum Duration (Days)`,\n    MAX(S.TOTAL_UNITS) AS `Maximum Units`,\n    AVG(DATEDIFF(T.TERM_END_DATE, T.TERM_START_DATE)) AS `Average Duration (Days)`,\n    AVG(S.TOTAL_UNITS) AS `Average Units`\nFROM\n    ACADEMIC_TERMS_ALL AS T\nJOIN\n    SUBJECT_SUMMARY AS S\nON\n    T.TERM_CODE = S.TERM_CODE\nWHERE\n    S.DEPARTMENT_NAME IN ('Biology', 'Chemistry')\nGROUP BY GROUPING SETS (\n    (CASE WHEN T.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END, S.CLUSTER_TYPE),\n    (CASE WHEN T.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END),\n    ()\n)\nORDER BY\n    CASE\n        WHEN GROUPING(CASE WHEN T.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END) = 0 AND GROUPING(S.CLUSTER_TYPE) = 0 THEN 1 -- Detail rows\n        WHEN GROUPING(CASE WHEN T.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END) = 0 AND GROUPING(S.CLUSTER_TYPE) = 1 THEN 2 -- Subtotal rows\n        WHEN GROUPING(CASE WHEN T.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END) = 1 AND GROUPING(S.CLUSTER_TYPE) = 1 THEN 3 -- Grand total row\n    END,\n    CASE WHEN T.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END ASC,\n    S.CLUSTER_TYPE ASC;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the department name. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), department name, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and department.",
        "predicted_sql": "SELECT\n    CASE\n        WHEN GROUPING(ATA.IS_CURRENT_TERM) = 1 AND GROUPING(SO.OFFER_DEPT_NAME) = 1 THEN 'TOTAL'\n        WHEN GROUPING(SO.OFFER_DEPT_NAME) = 1 THEN 'SUBTOTAL'\n        WHEN ATA.IS_CURRENT_TERM = 'Y' THEN 'CURRENT'\n        ELSE 'NON-CURRENT'\n    END AS `current status`,\n    CASE\n        WHEN GROUPING(SO.OFFER_DEPT_NAME) = 1 THEN NULL\n        ELSE SO.OFFER_DEPT_NAME\n    END AS `department name`,\n    MAX(DATEDIFF(ATA.TERM_END_DATE, ATA.TERM_START_DATE)) AS max_duration_days,\n    MAX(SS.TOTAL_UNITS) AS max_units,\n    AVG(DATEDIFF(ATA.TERM_END_DATE, ATA.TERM_START_DATE)) AS avg_duration_days,\n    AVG(SS.TOTAL_UNITS) AS avg_units\nFROM\n    ACADEMIC_TERMS_ALL AS ATA\nJOIN\n    SUBJECT_SUMMARY AS SS\n    ON ATA.TERM_CODE = SS.TERM_CODE\nJOIN\n    SUBJECT_OFFERED AS SO\n    ON SS.SUBJECT_ID = SO.SUBJECT_ID\nWHERE\n    SO.OFFER_DEPT_NAME LIKE '%Biology%' OR SO.OFFER_DEPT_NAME LIKE '%Chemistry%'\nGROUP BY\n    ATA.IS_CURRENT_TERM,\n    SO.OFFER_DEPT_NAME WITH ROLLUP\nORDER BY\n    CASE\n        WHEN GROUPING(ATA.IS_CURRENT_TERM) = 1 AND GROUPING(SO.OFFER_DEPT_NAME) = 1 THEN 3\n        WHEN GROUPING(SO.OFFER_DEPT_NAME) = 1 THEN 2\n        ELSE 1\n    END,\n    CASE ATA.IS_CURRENT_TERM WHEN 'Y' THEN 1 ELSE 2 END,\n    `department name`;"
    },
    {
        "db_id": "dw",
        "question": "Group master courses by department. For each group, state the name of the department, the master course code, the number of subjects, the total new shelf price of associated TIP materials, and the number of unique TIP materials. Display the department and master course only if it differs from the previous entry. Include subtotals for each department and a grand total across all departments. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT\n  CASE\n    WHEN GROUPING(TSO.OFFER_DEPT_NAME) = 1\n    THEN 'Grand Total'\n    ELSE TSO.OFFER_DEPT_NAME\n  END AS `Department Name`,\n  CASE\n    WHEN GROUPING(TSO.MASTER_COURSE_NUMBER) = 1 AND GROUPING(TSO.OFFER_DEPT_NAME) = 0\n    THEN CONCAT('Subtotal for ', TSO.OFFER_DEPT_NAME)\n    WHEN GROUPING(TSO.MASTER_COURSE_NUMBER) = 1 AND GROUPING(TSO.OFFER_DEPT_NAME) = 1\n    THEN 'Overall Total'\n    ELSE TSO.MASTER_COURSE_NUMBER\n  END AS `Master Course Code`,\n  FORMAT(COUNT(DISTINCT TSO.SUBJECT_ID), 0) AS `Number of Subjects`,\n  FORMAT(ROUND(SUM(TM.NEW_SHELF_PRICE)), 0) AS `Total New Shelf Price`,\n  FORMAT(COUNT(DISTINCT TD.TIP_MATERIAL_KEY), 0) AS `Number of Unique TIP Materials`\nFROM TIP_SUBJECT_OFFERED AS TSO\nJOIN TIP_DETAIL AS TD\n  ON TSO.TIP_SUBJECT_OFFERED_KEY = TD.TIP_SUBJECT_OFFERED_KEY\nJOIN TIP_MATERIAL AS TM\n  ON TD.TIP_MATERIAL_KEY = TM.TIP_MATERIAL_KEY\nGROUP BY\n  TSO.OFFER_DEPT_NAME,\n  TSO.MASTER_COURSE_NUMBER WITH ROLLUP\nORDER BY\n  GROUPING(TSO.OFFER_DEPT_NAME) ASC,\n  TSO.OFFER_DEPT_NAME ASC,\n  GROUPING(TSO.MASTER_COURSE_NUMBER) ASC,\n  TSO.MASTER_COURSE_NUMBER ASC;"
    },
    {
        "db_id": "dw",
        "question": "For each term and department, list the term, department, the number of courses, average number of equivalent subjects, the school name, and department phone number. Include subtotals for each term (the corresponding term field is 'SUBTOTAL') and a grand total across all terms (the corresponding term field is 'TOTAL'). Do not repeat the term if it is the same as the previous row. Sort the table by term and department.",
        "predicted_sql": "SELECT\n  CASE\n    WHEN GROUPING(T1.TERM_CODE) = 1 THEN 'TOTAL'\n    ELSE T1.TERM_CODE\n  END AS term,\n  CASE\n    WHEN GROUPING(T1.DEPARTMENT_NAME) = 1 AND GROUPING(T1.TERM_CODE) = 0 THEN 'SUBTOTAL'\n    WHEN GROUPING(T1.DEPARTMENT_NAME) = 1 AND GROUPING(T1.TERM_CODE) = 1 THEN 'TOTAL'\n    ELSE T1.DEPARTMENT_NAME\n  END AS department,\n  COUNT(DISTINCT T1.SUBJECT_ID) AS number_of_courses,\n  AVG(CASE WHEN T1.EQUIVALENT_SUBJECTS IS NULL OR T1.EQUIVALENT_SUBJECTS = '' THEN 0 ELSE LENGTH(T1.EQUIVALENT_SUBJECTS) - LENGTH(REPLACE(T1.EQUIVALENT_SUBJECTS, ',', '')) + 1 END) AS average_equivalent_subjects,\n  CASE\n    WHEN GROUPING(T1.DEPARTMENT_NAME) = 1 THEN NULL\n    ELSE MAX(T3.SCHOOL_NAME)\n  END AS school_name,\n  CASE\n    WHEN GROUPING(T1.DEPARTMENT_NAME) = 1 THEN NULL\n    ELSE MAX(T2.DEPARTMENT_PHONE_NUMBER)\n  END AS department_phone_number\nFROM COURSE_CATALOG_SUBJECT_OFFERED AS T1\nLEFT JOIN SIS_DEPARTMENT AS T3\n  ON T1.DEPARTMENT_CODE = T3.DEPARTMENT_CODE\nLEFT JOIN SIS_ADMIN_DEPARTMENT AS T2\n  ON T3.DEPARTMENT_CODE = T2.SIS_ADMIN_DEPARTMENT_CODE\nGROUP BY\n  T1.TERM_CODE,\n  T1.DEPARTMENT_NAME WITH ROLLUP\nORDER BY\n  CASE WHEN GROUPING(T1.TERM_CODE) = 1 THEN 1 ELSE 0 END,\n  T1.TERM_CODE,\n  CASE WHEN GROUPING(T1.DEPARTMENT_NAME) = 1 THEN 1 ELSE 0 END,\n  T1.DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Group sessions by their current term status. For each group, state the status ('CURRENT' if is current term and 'NOT CURRENT' otherwise), name of the session, number of IAP sessions, total IAP session time in days, and average IAP session time in days. Show a subtotal for each current status and a grand total row across all status. Order the results by current status and cluster type. Display the the current status only if it differs from the previous entry.",
        "predicted_sql": "SELECT\n  CASE\n    WHEN GROUPING(CASE WHEN AT.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END) = 1 AND GROUPING(ISC.IAP_CATEGORY_NAME) = 1\n    THEN 'Grand Total'\n    WHEN GROUPING(ISC.IAP_CATEGORY_NAME) = 1\n    THEN CONCAT('Subtotal for ', (CASE WHEN AT.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END))\n    ELSE (CASE WHEN AT.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END)\n  END AS current_status,\n  CASE\n    WHEN GROUPING(ISC.IAP_CATEGORY_NAME) = 1\n    THEN NULL\n    ELSE ISC.IAP_CATEGORY_NAME\n  END AS session_name,\n  COUNT(ISS.IAP_SUBJECT_SESSION_KEY) AS num_iap_sessions,\n  SUM(TIMESTAMPDIFF(SECOND, STR_TO_DATE(CONCAT(ISS.SESSION_DATE, ' ', ISS.SESSION_START_TIME), '%d-%M-%y %h%i%p'), STR_TO_DATE(CONCAT(ISS.SESSION_DATE, ' ', ISS.SESSION_END_TIME), '%d-%M-%y %h%i%p')) / 86400.0) AS total_iap_session_time_days,\n  AVG(TIMESTAMPDIFF(SECOND, STR_TO_DATE(CONCAT(ISS.SESSION_DATE, ' ', ISS.SESSION_START_TIME), '%d-%M-%y %h%i%p'), STR_TO_DATE(CONCAT(ISS.SESSION_DATE, ' ', ISS.SESSION_END_TIME), '%d-%M-%y %h%i%p')) / 86400.0) AS average_iap_session_time_days\nFROM IAP_SUBJECT_DETAIL AS ISD\nJOIN ACADEMIC_TERMS AS AT\n  ON ISD.TERM_CODE = AT.TERM_CODE\nJOIN IAP_SUBJECT_CATEGORY AS ISC\n  ON ISD.IAP_SUBJECT_CATEGORY_KEY = ISC.IAP_SUBJECT_CATEGORY_KEY\nJOIN IAP_SUBJECT_SESSION AS ISS\n  ON ISD.IAP_SUBJECT_SESSION_KEY = ISS.IAP_SUBJECT_SESSION_KEY\nGROUP BY ROLLUP(\n  (CASE WHEN AT.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END),\n  ISC.IAP_CATEGORY_NAME\n)\nORDER BY\n  GROUPING(CASE WHEN AT.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END) DESC,\n  (CASE WHEN AT.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END) ASC,\n  GROUPING(ISC.IAP_CATEGORY_NAME) ASC,\n  ISC.IAP_CATEGORY_NAME ASC;"
    },
    {
        "db_id": "dw",
        "question": "List each academic year, the term code, and the number of newly introduced subjects in this term. Display the academic year only if it differs from the previous entry. Include a grand total (the corresponding year field should be 'TOTAL') stating the total number of subjects across all academic years.",
        "predicted_sql": "```mysql\nWITH NewSubjectsPerTerm AS (\n    SELECT\n        ACADEMIC_YEAR,\n        TERM_CODE,\n        COUNT(DISTINCT SUBJECT_ID) AS new_subjects_count\n    FROM\n        COURSE_CATALOG_SUBJECT_OFFERED\n    WHERE\n        STATUS_CHANGE LIKE '%New subject%'\n    GROUP BY\n        ACADEMIC_YEAR,\n        TERM_CODE\n),\nCombinedData AS (\n    SELECT\n        ACADEMIC_YEAR,\n        TERM_CODE,\n        new_subjects_count\n    FROM\n        NewSubjectsPerTerm\n    UNION ALL\n    SELECT\n        NULL AS ACADEMIC_YEAR,\n        NULL AS TERM_CODE,\n        SUM(new_subjects_count) AS new_subjects_count\n    FROM\n        NewSubjectsPerTerm\n)\nSELECT\n    CASE\n        WHEN ACADEMIC_YEAR IS NULL THEN 'TOTAL'\n        WHEN ACADEMIC_YEAR = LAG(ACADEMIC_YEAR, 1, '') OVER (ORDER BY ACADEMIC_YEAR, TERM_CODE)\n            THEN ''\n        ELSE ACADEMIC_YEAR\n    END AS `Academic Year`,\n    TERM_CODE AS `Term Code`,\n    new_subjects_count AS `Number of newly introduced subjects`\nFROM\n    CombinedData\nORDER BY\n    ACADEMIC_YEAR IS NULL DESC,\n    ACADEMIC_YEAR ASC,\n    TERM_CODE ASC;"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with e (case insensitive), containing 10 to 20 members inclusive, and where over 75% are computer science students, provide the list name, owner, and member count.",
        "predicted_sql": "SELECT\n  ML.MOIRA_LIST_NAME,\n  MIN(MLO.OWNER) AS owner,\n  COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER) AS member_count\nFROM MOIRA_LIST AS ML\nJOIN MOIRA_LIST_DETAIL AS MLD\n  ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\nLEFT JOIN MOIRA_LIST_OWNER AS MLO\n  ON MLD.MOIRA_LIST_OWNER_KEY = MLO.MOIRA_LIST_OWNER_KEY\nLEFT JOIN SE_PERSON AS SP\n  ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME\nLEFT JOIN MIT_STUDENT_DIRECTORY AS MSD\n  ON SP.FULL_NAME = MSD.FULL_NAME\nWHERE\n  LOWER(ML.MOIRA_LIST_NAME) LIKE 'e%' AND ML.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY\n  ML.MOIRA_LIST_KEY,\n  ML.MOIRA_LIST_NAME\nHAVING\n  COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER) BETWEEN 10 AND 20 AND\n  SUM(CASE WHEN MSD.STUDENT_YEAR IS NOT NULL AND MSD.DEPARTMENT_NAME LIKE '%Computer Sci%' THEN 1 ELSE 0 END) * 1.0 / COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER) > 0.75;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with K, list their names, the phone numbers of departments they belong to, total number of mailing lists each student is in, and the average size of the mailing lists each student is in.",
        "predicted_sql": "```mysql\nSELECT\n  T1.FULL_NAME,\n  T4.DEPARTMENT_PHONE_NUMBER,\n  COUNT(DISTINCT T3.MOIRA_LIST_KEY),\n  AVG(LS.list_size)\nFROM MIT_STUDENT_DIRECTORY AS T1\nJOIN SIS_DEPARTMENT AS T2\n  ON T1.DEPARTMENT = T2.DEPARTMENT_CODE\nJOIN SIS_ADMIN_DEPARTMENT AS T4\n  ON T2.DEPARTMENT_CODE = T4.SIS_ADMIN_DEPARTMENT_CODE\nLEFT JOIN MOIRA_LIST_DETAIL AS T3\n  ON T1.FULL_NAME = T3.MOIRA_LIST_MEMBER_FULL_NAME\nLEFT JOIN (\n  SELECT\n    MOIRA_LIST_KEY,\n    COUNT(MOIRA_LIST_MEMBER) AS list_size\n  FROM MOIRA_LIST_DETAIL\n  GROUP BY\n    MOIRA_LIST_KEY\n) AS LS\n  ON T3.MOIRA_LIST_KEY = LS.MOIRA_LIST_KEY\nWHERE\n  T1.LAST_NAME LIKE 'K%'\nGROUP BY\n  T1.FULL_NAME,\n  T4.DEPARTMENT_PHONE_NUMBER;"
    },
    {
        "db_id": "dw",
        "question": "From the 100 email lists with the most number of subscribers, list their names, their total number of subscribers, their public status, the name of the department with the most presence in the list, and the number of students from this department in the list.",
        "predicted_sql": "WITH ListSubscribers AS (\n  SELECT\n    T1.MOIRA_LIST_KEY,\n    T1.MOIRA_LIST_NAME,\n    T1.IS_PUBLIC,\n    COUNT(DISTINCT T2.MOIRA_LIST_MEMBER) AS total_subscribers\n  FROM MOIRA_LIST AS T1\n  JOIN MOIRA_LIST_DETAIL AS T2\n    ON T1.MOIRA_LIST_KEY = T2.MOIRA_LIST_KEY\n  GROUP BY\n    T1.MOIRA_LIST_KEY,\n    T1.MOIRA_LIST_NAME,\n    T1.IS_PUBLIC\n  ORDER BY\n    total_subscribers DESC\n  LIMIT 100\n), StudentDepartmentCounts AS (\n  SELECT\n    LS.MOIRA_LIST_KEY,\n    T3.DEPARTMENT,\n    COUNT(DISTINCT T2.MOIRA_LIST_MEMBER_FULL_NAME) AS student_count,\n    ROW_NUMBER() OVER (PARTITION BY LS.MOIRA_LIST_KEY ORDER BY COUNT(DISTINCT T2.MOIRA_LIST_MEMBER_FULL_NAME) DESC, T3.DEPARTMENT) AS rn\n  FROM ListSubscribers AS LS\n  JOIN MOIRA_LIST_DETAIL AS T2\n    ON LS.MOIRA_LIST_KEY = T2.MOIRA_LIST_KEY\n  JOIN MIT_STUDENT_DIRECTORY AS T3\n    ON T2.MOIRA_LIST_MEMBER_FULL_NAME = T3.FULL_NAME\n  GROUP BY\n    LS.MOIRA_LIST_KEY,\n    T3.DEPARTMENT\n)\nSELECT\n  LS.MOIRA_LIST_NAME,\n  LS.total_subscribers,\n  LS.IS_PUBLIC,\n  T4.DEPARTMENT_NAME,\n  SDC.student_count\nFROM ListSubscribers AS LS\nLEFT JOIN StudentDepartmentCounts AS SDC\n  ON LS.MOIRA_LIST_KEY = SDC.MOIRA_LIST_KEY\n  AND SDC.rn = 1\nLEFT JOIN SIS_DEPARTMENT AS T4\n  ON SDC.DEPARTMENT = T4.DEPARTMENT_CODE\nORDER BY\n  LS.total_subscribers DESC;"
    },
    {
        "db_id": "dw",
        "question": "Calculate the total assignable and non-assignable area for each building by summing up the respective areas of all its floors. For each building, list the building name, building number, total assignable area, total non-assignable area, and total room count, sorted in descending order of the total assignable area.",
        "predicted_sql": "SELECT\n  T1.BUILDING_NAME,\n  T1.BUILDING_NUMBER,\n  COALESCE(SUM(T2.ASSIGNABLE_AREA), 0) AS Total_Assignable_Area,\n  COALESCE(SUM(T2.NON_ASSIGNABLE_AREA), 0) AS Total_Non_Assignable_Area,\n  COALESCE(COUNT(T3.FAC_ROOM_KEY), 0) AS Total_Room_Count\nFROM FAC_BUILDING AS T1\nLEFT JOIN FAC_FLOOR AS T2\n  ON T1.FAC_BUILDING_KEY = T2.BUILDING_KEY\nLEFT JOIN FAC_ROOMS AS T3\n  ON T1.FAC_BUILDING_KEY = T3.BUILDING_KEY\nGROUP BY\n  T1.FAC_BUILDING_KEY,\n  T1.BUILDING_NAME,\n  T1.BUILDING_NUMBER\nORDER BY\n  Total_Assignable_Area DESC;"
    },
    {
        "db_id": "dw",
        "question": "List all rooms in building 45, including their full name, area, major use, the organization that occupies them, the count of rooms per major use, and the total area occupied by rooms for each organization.",
        "predicted_sql": "SELECT\n  T1.ROOM_FULL_NAME,\n  T1.AREA,\n  T2.MAJOR_USE,\n  T3.ORGANIZATION_NAME,\n  COUNT(T1.FAC_ROOM_KEY) OVER (PARTITION BY T2.MAJOR_USE) AS rooms_per_major_use,\n  SUM(T1.AREA) OVER (PARTITION BY T3.ORGANIZATION_NAME) AS total_area_per_organization\nFROM FAC_ROOMS AS T1\nJOIN FAC_MAJOR_USE AS T2\n  ON T1.MAJOR_USE_KEY = T2.MAJOR_USE_KEY\nJOIN FAC_ORGANIZATION AS T3\n  ON T1.ORGANIZATION_KEY = T3.ORGANIZATION_KEY\nWHERE\n  T1.BUILDING_KEY = '45';"
    },
    {
        "db_id": "dw",
        "question": "List the name, number, construction date, and type of all buildings, along with the count of addresses associated with each building, the average gross area of the buildings, and the total number of rooms in each building. Sort the results by building name.",
        "predicted_sql": "SELECT\n  T1.BUILDING_NAME AS name,\n  T1.BUILDING_NUMBER AS number,\n  T1.DATE_BUILT AS `construction date`,\n  T1.BUILDING_TYPE AS type,\n  COUNT(DISTINCT T2.BUILDING_ADDRESS_KEY) AS `count of addresses`,\n  AVG(CAST(T1.EXT_GROSS_AREA AS DECIMAL(10, 2))) AS `average gross area`,\n  COUNT(DISTINCT T3.FAC_ROOM_KEY) AS `total number of rooms`\nFROM FAC_BUILDING AS T1\nLEFT JOIN FAC_BUILDING_ADDRESS AS T2\n  ON T1.FAC_BUILDING_KEY = T2.BUILDING_KEY\nLEFT JOIN FAC_ROOMS AS T3\n  ON T1.FAC_BUILDING_KEY = T3.BUILDING_KEY\nGROUP BY\n  T1.FAC_BUILDING_KEY,\n  T1.BUILDING_NAME,\n  T1.BUILDING_NUMBER,\n  T1.DATE_BUILT,\n  T1.BUILDING_TYPE\nORDER BY\n  T1.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list its name, number of unique courses offered, the number of unique reserved materials, and the number of unique instructors associated with those courses, sorted by the number of unique courses offered in descending order.",
        "predicted_sql": "SELECT\n  T1.OFFER_DEPT_NAME,\n  COUNT(DISTINCT T1.MASTER_COURSE_NUMBER) AS num_unique_courses,\n  COUNT(DISTINCT T3.CATALOG_TITLE) AS num_unique_reserved_materials,\n  COUNT(DISTINCT T4.INSTRUCTOR_NAME) AS num_unique_instructors\nFROM LIBRARY_SUBJECT_OFFERED AS T1\nLEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL AS T2\n  ON T1.LIBRARY_SUBJECT_OFFERED_KEY = T2.LIBRARY_SUBJECT_OFFERED_KEY\nLEFT JOIN LIBRARY_RESERVE_CATALOG AS T3\n  ON T2.LIBRARY_RESERVE_CATALOG_KEY = T3.LIBRARY_RESERVE_CATALOG_KEY\nLEFT JOIN LIBRARY_COURSE_INSTRUCTOR AS T4\n  ON T2.LIBRARY_COURSE_INSTRUCTOR_KEY = T4.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY\n  T1.OFFER_DEPT_NAME\nORDER BY\n  num_unique_courses DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each course title, list the title, the total number of reserved materials, and the count of distinct material status associated with those materials, sorted by the total number of reserved materials in descending order.",
        "predicted_sql": "SELECT\n  T1.SUBJECT_TITLE,\n  COUNT(T2.LIBRARY_RESERVE_CATALOG_KEY) AS total_reserved_materials,\n  COUNT(DISTINCT T3.LIBRARY_MATERIAL_STATUS) AS distinct_material_status_count\nFROM LIBRARY_SUBJECT_OFFERED AS T1\nJOIN LIBRARY_RESERVE_MATRL_DETAIL AS T2\n  ON T1.LIBRARY_SUBJECT_OFFERED_KEY = T2.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN LIBRARY_MATERIAL_STATUS AS T3\n  ON T2.LIBRARY_MATERIAL_STATUS_KEY = T3.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY\n  T1.SUBJECT_TITLE\nORDER BY\n  total_reserved_materials DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each instructor, list their name, the number of unique courses they teach, the total number of material assignments, average publication year, and number of distinct status, sorted by the number of unique courses in descending order.",
        "predicted_sql": "SELECT\n  T1.INSTRUCTOR_NAME,\n  COUNT(DISTINCT T1.COURSE_NAME),\n  COUNT(T2.LIBRARY_RESERVE_CATALOG_KEY),\n  AVG(CAST(T3.CATALOG_YEAR AS SIGNED)),\n  COUNT(DISTINCT T4.LIBRARY_MATERIAL_STATUS)\nFROM LIBRARY_COURSE_INSTRUCTOR AS T1\nINNER JOIN LIBRARY_RESERVE_MATRL_DETAIL AS T2\n  ON T1.LIBRARY_COURSE_INSTRUCTOR_KEY = T2.LIBRARY_COURSE_INSTRUCTOR_KEY\nINNER JOIN LIBRARY_RESERVE_CATALOG AS T3\n  ON T2.LIBRARY_RESERVE_CATALOG_KEY = T3.LIBRARY_RESERVE_CATALOG_KEY\nINNER JOIN LIBRARY_MATERIAL_STATUS AS T4\n  ON T2.LIBRARY_MATERIAL_STATUS_KEY = T4.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY\n  T1.INSTRUCTOR_NAME\nORDER BY\n  COUNT(DISTINCT T1.COURSE_NAME) DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each publication year, list the year, the total number of reserved materials, the average length of their titles, distinct number of status, and number of courses, sorted by publication year in descending order.",
        "predicted_sql": "SELECT\n  T1.CATALOG_YEAR,\n  COUNT(DISTINCT T1.LIBRARY_RESERVE_CATALOG_KEY),\n  AVG(LENGTH(T1.CATALOG_TITLE)),\n  COUNT(DISTINCT T3.LIBRARY_MATERIAL_STATUS),\n  COUNT(DISTINCT T4.COURSE_NAME)\nFROM LIBRARY_RESERVE_CATALOG AS T1\nINNER JOIN LIBRARY_RESERVE_MATRL_DETAIL AS T2\n  ON T1.LIBRARY_RESERVE_CATALOG_KEY = T2.LIBRARY_RESERVE_CATALOG_KEY\nINNER JOIN LIBRARY_MATERIAL_STATUS AS T3\n  ON T2.LIBRARY_MATERIAL_STATUS_KEY = T3.LIBRARY_MATERIAL_STATUS_KEY\nINNER JOIN LIBRARY_COURSE_INSTRUCTOR AS T4\n  ON T2.LIBRARY_COURSE_INSTRUCTOR_KEY = T4.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY\n  T1.CATALOG_YEAR\nORDER BY\n  T1.CATALOG_YEAR DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list the category name, the sponsor name, the number of activities offered, and the average fee per activity, sorted by the number of activities in descending order.",
        "predicted_sql": "SELECT\n  T1.IAP_CATEGORY_NAME,\n  T3.SPONSOR_NAME,\n  COUNT(T2.ACTIVITY_TITLE),\n  AVG(T2.FEE)\nFROM IAP_SUBJECT_CATEGORY AS T1\nINNER JOIN IAP_SUBJECT_DETAIL AS T2\n  ON T1.IAP_SUBJECT_CATEGORY_KEY = T2.IAP_SUBJECT_CATEGORY_KEY\nINNER JOIN IAP_SUBJECT_SPONSOR AS T3\n  ON T2.IAP_SUBJECT_SPONSOR_KEY = T3.IAP_SUBJECT_SPONSOR_KEY\nGROUP BY\n  T1.IAP_CATEGORY_NAME,\n  T3.SPONSOR_NAME\nORDER BY\n  COUNT(T2.ACTIVITY_TITLE) DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor, list the sponsor name, the number of IAP sessions hosted, and the number of unique subjects organized.",
        "predicted_sql": "SELECT\n  T1.SPONSOR_NAME,\n  COUNT(T3.IAP_SUBJECT_SESSION_KEY) AS num_iap_sessions_hosted,\n  COUNT(DISTINCT T2.IAP_SUBJECT_SESSION_KEY) AS num_unique_subjects_organized\nFROM IAP_SUBJECT_SPONSOR AS T1\nLEFT JOIN IAP_SUBJECT_DETAIL AS T2\n  ON T1.IAP_SUBJECT_SPONSOR_KEY = T2.IAP_SUBJECT_SPONSOR_KEY\nLEFT JOIN IAP_SUBJECT_SESSION AS T3\n  ON T2.IAP_SUBJECT_SESSION_KEY = T3.IAP_SUBJECT_SESSION_KEY\nGROUP BY\n  T1.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each person role and IAP category, list the role, the category name, the number of people in this role, and the average fee, sorted by the role count in descending order.",
        "predicted_sql": "SELECT\n  T1.PERSON_ROLE,\n  T3.IAP_CATEGORY_NAME,\n  COUNT(DISTINCT T1.IAP_SUBJECT_PERSON_KEY) AS Number_of_People,\n  AVG(T2.FEE) AS Average_Fee\nFROM IAP_SUBJECT_PERSON AS T1\nJOIN IAP_SUBJECT_DETAIL AS T2\n  ON T1.IAP_SUBJECT_PERSON_KEY = T2.IAP_SUBJECT_PERSON_KEY\nJOIN IAP_SUBJECT_CATEGORY AS T3\n  ON T2.IAP_SUBJECT_CATEGORY_KEY = T3.IAP_SUBJECT_CATEGORY_KEY\nGROUP BY\n  T1.PERSON_ROLE,\n  T3.IAP_CATEGORY_NAME\nORDER BY\n  Number_of_People DESC;"
    },
    {
        "db_id": "dw",
        "question": "List the names of the buildings with the most floors. If there are ties, list each one separately.",
        "predicted_sql": "SELECT\n  T1.BUILDING_NAME\nFROM FAC_BUILDING AS T1\nINNER JOIN FAC_FLOOR AS T2\n  ON T1.FAC_BUILDING_KEY = T2.BUILDING_KEY\nGROUP BY\n  T1.FAC_BUILDING_KEY,\n  T1.BUILDING_NAME\nHAVING\n  COUNT(DISTINCT T2.LEVEL_ID) = (\n    SELECT\n      MAX(floor_count)\n    FROM (\n      SELECT\n        COUNT(DISTINCT T3.LEVEL_ID) AS floor_count\n      FROM FAC_BUILDING AS T4\n      INNER JOIN FAC_FLOOR AS T3\n        ON T4.FAC_BUILDING_KEY = T3.BUILDING_KEY\n      GROUP BY\n        T4.FAC_BUILDING_KEY\n    ) AS subquery\n  );"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered in the summer term, list the subject titles, number of instructors, and the length of the longest instructor name.",
        "predicted_sql": "SELECT\n  T1.SUBJECT_TITLE,\n  COUNT(DISTINCT T2.FULL_NAME),\n  MAX(LENGTH(T2.FULL_NAME))\nFROM COURSE_CATALOG_SUBJECT_OFFERED AS T1\nJOIN EMPLOYEE_DIRECTORY AS T2\n  ON T1.RESPONSIBLE_FACULTY_MIT_ID = T2.MIT_ID\nWHERE\n  T1.IS_OFFERED_SUMMER_TERM = 'Y'\nGROUP BY\n  T1.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For the mailing list with owner key LIST69.377-keeper-xenon, list the owner, total number of mailing lists, and total number of members across all these mailing lists.",
        "predicted_sql": "SELECT\n  T1.OWNER,\n  COUNT(DISTINCT T2.MOIRA_LIST_KEY) AS total_number_of_mailing_lists,\n  COUNT(DISTINCT T2.MOIRA_LIST_MEMBER) AS total_number_of_members\nFROM MOIRA_LIST_OWNER AS T1\nJOIN MOIRA_LIST_DETAIL AS T2\n  ON T1.MOIRA_LIST_OWNER_KEY = T2.MOIRA_LIST_OWNER_KEY\nWHERE\n  T1.MOIRA_LIST_OWNER_KEY = 'LIST69.377-keeper-xenon'\nGROUP BY\n  T1.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For each school, list the school name, total number of courses that appear in SIS subject code catalog, and the total number of degree-granting courses that appear in SIS subject code catalog.",
        "predicted_sql": "SELECT\n  T1.SCHOOL_NAME,\n  COUNT(DISTINCT T2.COURSE) AS total_courses,\n  COUNT(DISTINCT CASE WHEN T2.IS_DEGREE_GRANTING = 'Y' THEN T2.COURSE ELSE NULL END) AS total_degree_granting_courses\nFROM SIS_DEPARTMENT AS T1\nINNER JOIN SIS_COURSE_DESCRIPTION AS T2\n  ON T1.DEPARTMENT_CODE = T2.DEPARTMENT\nINNER JOIN SIS_SUBJECT_CODE AS T3\n  ON T2.COURSE = T3.COURSE_NUMBER\nGROUP BY\n  T1.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the department name, department phone number, number of students, and the length of the longest student full name in that department.",
        "predicted_sql": "SELECT\n  T1.DEPARTMENT_NAME,\n  T2.DEPARTMENT_PHONE_NUMBER,\n  COUNT(T3.EMAIL_ADDRESS),\n  MAX(LENGTH(T3.FULL_NAME))\nFROM SIS_DEPARTMENT AS T1\nINNER JOIN SIS_ADMIN_DEPARTMENT AS T2\n  ON T1.DEPARTMENT_CODE = T2.SIS_ADMIN_DEPARTMENT_CODE\nLEFT JOIN MIT_STUDENT_DIRECTORY AS T3\n  ON T1.DEPARTMENT_CODE = T3.DEPARTMENT\nGROUP BY\n  T1.DEPARTMENT_NAME,\n  T2.DEPARTMENT_PHONE_NUMBER;"
    }
]