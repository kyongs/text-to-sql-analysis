[
    {
        "db_id": "dw",
        "question": "What is the current building key, building street address, city, state, and postal code of the history department?",
        "predicted_sql": "SELECT DISTINCT\n    b.BUILDING_KEY AS \"building key\",\n    b.BUILDING_STREET_ADDRESS AS \"building street address\",\n    a.CITY AS \"city\",\n    a.STATE AS \"state\",\n    a.POSTAL_CODE AS \"postal code\"\nFROM BUILDINGS b\nJOIN FCLT_BUILDING_ADDRESS a ON b.BUILDING_KEY = a.FCLT_BUILDING_KEY AND a.ADDRESS_PURPOSE = 'STREET'\nJOIN FCLT_ROOMS r ON b.BUILDING_KEY = r.FCLT_BUILDING_KEY\nJOIN FCLT_ORG_DLC_KEY o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY\nJOIN MASTER_DEPT_HIERARCHY h ON o.DLC_KEY = h.DLC_KEY\nWHERE LOWER(h.DLC_NAME) = 'history department';"
    },
    {
        "db_id": "dw",
        "question": "Show the unique activity titles, locations, term start date, and supervisor name for all independent activities, sorted by the ascending order of start date.",
        "predicted_sql": "SELECT DISTINCT d.ACTIVITY_TITLE, s.SESSION_LOCATION, a.TERM_START_DATE, p.PERSON_NAME AS SUPERVISOR_NAME\nFROM IAP_SUBJECT_DETAIL d\nINNER JOIN ACADEMIC_TERMS_ALL a ON d.TERM_CODE = a.TERM_CODE\nINNER JOIN IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nINNER JOIN IAP_SUBJECT_PERSON p ON d.IAP_SUBJECT_PERSON_KEY = p.IAP_SUBJECT_PERSON_KEY\nORDER BY a.TERM_START_DATE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the unique course instructor names, course titles, and the amount of material for each course instructor key and the key of subject offered.",
        "predicted_sql": "SELECT ci.INSTRUCTOR_NAME, so.SUBJECT_TITLE, COUNT(rc.CATALOG_ISBN) AS amount_of_material\nFROM LIBRARY_COURSE_INSTRUCTOR ci\nJOIN LIBRARY_RESERVE_MATRL_DETAIL rm ON ci.LIBRARY_COURSE_INSTRUCTOR_KEY = rm.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN LIBRARY_SUBJECT_OFFERED so ON rm.LIBRARY_SUBJECT_OFFERED_KEY = so.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN LIBRARY_RESERVE_CATALOG rc ON rm.LIBRARY_RESERVE_CATALOG_KEY = rc.LIBRARY_RESERVE_CATALOG_KEY\nGROUP BY ci.LIBRARY_COURSE_INSTRUCTOR_KEY, so.LIBRARY_SUBJECT_OFFERED_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What is the room, floor, building key, building street address, city, state, and postal code of Professor Summer Haynes's office?",
        "predicted_sql": "SELECT\n    FR.ROOM,\n    FR.FLOOR,\n    FR.BUILDING_KEY,\n    B.BUILDING_STREET_ADDRESS,\n    FBA.CITY,\n    FBA.STATE,\n    FBA.POSTAL_CODE\nFROM\n    EMPLOYEE_DIRECTORY ED\n    INNER JOIN FAC_ROOMS FR ON ED.OFFICE_LOCATION = FR.FAC_ROOM_KEY\n    INNER JOIN FAC_BUILDING_ADDRESS FBA ON FR.BUILDING_KEY = FBA.BUILDING_KEY AND FBA.ADDRESS_PURPOSE = 'STREET'\n    INNER JOIN BUILDINGS B ON FBA.BUILDING_KEY = B.BUILDING_KEY\nWHERE\n    (ED.FIRST_NAME = 'Summer' AND ED.LAST_NAME = 'Haynes')\n    OR (ED.PREFERRED_FIRST_NAME = 'Summer' AND ED.PREFERRED_LAST_NAME = 'Haynes')\n    OR ED.FULL_NAME LIKE 'Haynes, Summer%';"
    },
    {
        "db_id": "dw",
        "question": "List the unique full room names, their corresponding building names, street addresses, cities, states, postal codes, and building heights for rooms associated with subjects that Computer Science students can enroll in.",
        "predicted_sql": "SELECT DISTINCT\n    R.ROOM_FULL_NAME AS `full room name`,\n    B.BUILDING_NAME AS `building name`,\n    B.BUILDING_STREET_ADDRESS AS `street address`,\n    A.CITY AS `city`,\n    A.STATE AS `state`,\n    A.POSTAL_CODE AS `postal code`,\n    FB.BUILDING_HEIGHT AS `building height`\nFROM\n    COURSE_CATALOG_SUBJECT_OFFERED C\n    JOIN FCLT_ROOMS R ON C.MEET_PLACE = R.FCLT_ROOM_KEY\n    JOIN BUILDINGS B ON R.FCLT_BUILDING_KEY = B.BUILDING_KEY\n    JOIN FCLT_BUILDING FB ON R.FCLT_BUILDING_KEY = FB.FCLT_BUILDING_KEY\n    JOIN FCLT_BUILDING_ADDRESS A ON R.FCLT_BUILDING_KEY = A.FCLT_BUILDING_KEY AND A.ADDRESS_PURPOSE = 'STREET'\nWHERE\n    C.DEPARTMENT_NAME LIKE '%Computer Science%';"
    },
    {
        "db_id": "dw",
        "question": "List the unique term code, subject title, room, floor, building key, building street address, city, state, and postal code, formats, and number of enrolled students for all courses with more than 300 attendees.",
        "predicted_sql": "SELECT DISTINCT\n    s.TERM_CODE,\n    s.SUBJECT_TITLE,\n    r.ROOM,\n    r.FLOOR,\n    b.BUILDING_KEY,\n    b.BUILDING_STREET_ADDRESS,\n    a.CITY,\n    a.STATE,\n    a.POSTAL_CODE,\n    s.FORM_TYPE AS formats,\n    s.NUM_ENROLLED_STUDENTS\nFROM SUBJECT_OFFERED s\nJOIN FCLT_ROOMS r ON s.MEET_PLACE = r.FCLT_ROOM_KEY\nJOIN BUILDINGS b ON r.FCLT_BUILDING_KEY = b.BUILDING_KEY\nJOIN FCLT_BUILDING_ADDRESS a ON r.FCLT_BUILDING_KEY = a.FCLT_BUILDING_KEY AND a.ADDRESS_PURPOSE = 'STREET'\nWHERE s.NUM_ENROLLED_STUDENTS > 300;"
    },
    {
        "db_id": "dw",
        "question": "What are the subject titles, their material titles, ISBN numbers, new shelf prices, and total costs of new materials for each subject title, sorted by individual item prices in ascending order?",
        "predicted_sql": "SELECT\n    tso.SUBJECT_TITLE,\n    tm.TITLE AS MATERIAL_TITLE,\n    tm.ISBN,\n    tm.NEW_SHELF_PRICE,\n    SUM(tm.NEW_SHELF_PRICE) OVER (PARTITION BY tso.SUBJECT_TITLE) AS TOTAL_COST\nFROM\n    TIP_DETAIL td\n    JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\n    JOIN TIP_SUBJECT_OFFERED tso ON td.SUBJECT_ID = tso.SUBJECT_ID\nORDER BY\n    tm.NEW_SHELF_PRICE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the long names of buildings constructed before 1950 that have more than 100 employees, the built year of the building, and number of employees.",
        "predicted_sql": "WITH employee_counts AS (\n    SELECT r.FCLT_BUILDING_KEY, COUNT(DISTINCT e.MIT_ID) AS num_employees\n    FROM EMPLOYEE_DIRECTORY e\n    JOIN FCLT_ROOMS r ON e.OFFICE_LOCATION = r.BUILDING_ROOM\n    GROUP BY r.FCLT_BUILDING_KEY\n    HAVING COUNT(DISTINCT e.MIT_ID) > 100\n),\nlatest_building AS (\n    SELECT h.FCLT_BUILDING_KEY, h.BUILDING_NAME_LONG, h.DATE_BUILT\n    FROM FCLT_BUILDING_HIST h\n    INNER JOIN (\n        SELECT FCLT_BUILDING_KEY, MAX(FISCAL_PERIOD) AS max_period\n        FROM FCLT_BUILDING_HIST\n        GROUP BY FCLT_BUILDING_KEY\n    ) t ON h.FCLT_BUILDING_KEY = t.FCLT_BUILDING_KEY AND h.FISCAL_PERIOD = t.max_period\n)\nSELECT b.BUILDING_NAME_LONG,\n       CAST(SUBSTR(b.DATE_BUILT, -4) AS INTEGER) AS built_year,\n       e.num_employees\nFROM employee_counts e\nJOIN latest_building b ON b.FCLT_BUILDING_KEY = e.FCLT_BUILDING_KEY\nWHERE CAST(SUBSTR(b.DATE_BUILT, -4) AS INTEGER) < 1950\nORDER BY b.BUILDING_NAME_LONG;"
    },
    {
        "db_id": "dw",
        "question": "For each building key, what is the building name and the number of courses offered by the Center for International Studies?",
        "predicted_sql": "SELECT b.FCLT_BUILDING_KEY AS building_key, b.BUILDING_NAME AS building_name, COUNT(DISTINCT c.SUBJECT_ID) AS number_of_courses\nFROM CIS_COURSE_CATALOG c\nJOIN COURSE_CATALOG_SUBJECT_OFFERED o ON c.SUBJECT_ID = o.SUBJECT_ID\nJOIN FCLT_ROOMS r ON o.MEET_PLACE = r.FCLT_ROOM_KEY\nJOIN FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nWHERE c.DEPARTMENT_NAME = 'Center for International Studies'\nGROUP BY b.FCLT_BUILDING_KEY, b.BUILDING_NAME\nORDER BY b.FCLT_BUILDING_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building that accomodates the most students, and how many students does it accomodate?",
        "predicted_sql": "SELECT b.BUILDING_NAME, COUNT(*) AS student_count\nFROM MIT_STUDENT_DIRECTORY s\nJOIN FCLT_ROOMS r ON s.OFFICE_LOCATION = r.BUILDING_ROOM\nJOIN FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nGROUP BY b.FCLT_BUILDING_KEY, b.BUILDING_NAME\nORDER BY student_count DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "List the name and floor of the building with the largest floor number.",
        "predicted_sql": "SELECT b.BUILDING_NAME, f.FLOOR\nFROM FAC_BUILDING b\nJOIN FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nWHERE CAST(f.FLOOR AS SIGNED) = (SELECT MAX(CAST(FLOOR AS SIGNED)) FROM FAC_FLOOR);"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category and academic year, list the category name, academic year, total fee collected, total number of IAP subjects, and the minimum and maximum enrollment.",
        "predicted_sql": "SELECT \n    c.IAP_CATEGORY_NAME AS category_name,\n    t.ACADEMIC_YEAR AS academic_year,\n    SUM(d.FEE) AS total_fee_collected,\n    COUNT(*) AS total_subjects,\n    MIN(d.MAX_ENROLLMENT) AS min_enrollment,\n    MAX(d.MAX_ENROLLMENT) AS max_enrollment\nFROM IAP_SUBJECT_DETAIL d\nJOIN IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\nJOIN (SELECT DISTINCT ACADEMIC_TERM_CODE, ACADEMIC_YEAR FROM TIME_DAY) t ON d.TERM_CODE = t.ACADEMIC_TERM_CODE\nGROUP BY c.IAP_CATEGORY_NAME, t.ACADEMIC_YEAR\nORDER BY c.IAP_CATEGORY_NAME, t.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor of the independent activity periods, list the sponsor name, number of sessions held, the total number of enrollment, the minimum and maximum fee, the number of sessions with info, and the number of sessions without info.",
        "predicted_sql": "SELECT \n    sp.SPONSOR_NAME,\n    COUNT(DISTINCT d.IAP_SUBJECT_SESSION_KEY) AS `number of sessions held`,\n    COALESCE(SUM(d.MAX_ENROLLMENT), 0) AS `total number of enrollment`,\n    MIN(d.FEE) AS `minimum fee`,\n    MAX(d.FEE) AS `maximum fee`,\n    COUNT(DISTINCT CASE WHEN sess.HAS_SESSION_INFO = 'Y' THEN d.IAP_SUBJECT_SESSION_KEY END) AS `number of sessions with info`,\n    COUNT(DISTINCT CASE WHEN sess.HAS_SESSION_INFO = 'N' THEN d.IAP_SUBJECT_SESSION_KEY END) AS `number of sessions without info`\nFROM IAP_SUBJECT_DETAIL d\nJOIN IAP_SUBJECT_SESSION sess ON d.IAP_SUBJECT_SESSION_KEY = sess.IAP_SUBJECT_SESSION_KEY\nJOIN IAP_SUBJECT_SPONSOR sp ON d.IAP_SUBJECT_SPONSOR_KEY = sp.IAP_SUBJECT_SPONSOR_KEY\nGROUP BY sp.IAP_SUBJECT_SPONSOR_KEY, sp.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the individual's email and name, academic year, total number of IAP subjects, the minimum and maximum fees, and the total course enrollment for each individual and academic year?",
        "predicted_sql": "SELECT \n    p.PERSON_EMAIL AS email,\n    p.PERSON_NAME AS name,\n    t.ACADEMIC_YEAR AS academic_year,\n    COUNT(*) AS total_subjects,\n    MIN(d.FEE) AS min_fee,\n    MAX(d.FEE) AS max_fee,\n    SUM(d.MAX_ENROLLMENT) AS total_enrollment\nFROM IAP_SUBJECT_DETAIL d\nJOIN IAP_SUBJECT_PERSON p ON d.IAP_SUBJECT_PERSON_KEY = p.IAP_SUBJECT_PERSON_KEY\nJOIN (\n    SELECT DISTINCT ACADEMIC_TERM_CODE, ACADEMIC_YEAR\n    FROM TIME_DAY\n    WHERE ACADEMIC_TERM_CODE IS NOT NULL\n) t ON d.TERM_CODE = t.ACADEMIC_TERM_CODE\nGROUP BY p.IAP_SUBJECT_PERSON_KEY, t.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "What is the term code, term description, total number of IAP sessions, total fee collected, and minimum and maximum enrollment for each term code?",
        "predicted_sql": "SELECT \n    a.TERM_CODE,\n    a.TERM_DESCRIPTION,\n    COUNT(DISTINCT s.IAP_SUBJECT_SESSION_KEY) AS total_sessions,\n    SUM(d.FEE) AS total_fee,\n    MIN(d.MAX_ENROLLMENT) AS min_enrollment,\n    MAX(d.MAX_ENROLLMENT) AS max_enrollment\nFROM ACADEMIC_TERMS_ALL a\nJOIN IAP_SUBJECT_DETAIL d ON a.TERM_CODE = d.TERM_CODE\nJOIN IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nGROUP BY a.TERM_CODE, a.TERM_DESCRIPTION\nORDER BY a.TERM_CODE;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building, total number of subjects, total fee, and shortest and longest sessions for each physical IAP session location?",
        "predicted_sql": "WITH session_data AS (\n    SELECT \n        B.BUILDING_NUMBER,\n        B.BUILDING_NAME,\n        D.ACTIVITY_TITLE,\n        D.FEE,\n        S.SESSION_START_TIME,\n        S.SESSION_END_TIME,\n        (TIME_TO_SEC(STR_TO_DATE(S.SESSION_END_TIME, '%h%i%p')) - TIME_TO_SEC(STR_TO_DATE(S.SESSION_START_TIME, '%h%i%p'))) / 60 AS duration_min\n    FROM IAP_SUBJECT_SESSION S\n    INNER JOIN IAP_SUBJECT_DETAIL D ON S.IAP_SUBJECT_SESSION_KEY = D.IAP_SUBJECT_SESSION_KEY\n    INNER JOIN BUILDINGS B ON S.SESSION_LOCATION = B.BUILDING_NUMBER\n), \nsubject_agg AS (\n    SELECT \n        BUILDING_NUMBER,\n        COUNT(DISTINCT ACTIVITY_TITLE) AS total_subjects,\n        SUM(FEE) AS total_fee\n    FROM (\n        SELECT DISTINCT BUILDING_NUMBER, ACTIVITY_TITLE, FEE\n        FROM session_data\n    ) AS distinct_subjects\n    GROUP BY BUILDING_NUMBER\n),\nduration_agg AS (\n    SELECT \n        BUILDING_NUMBER,\n        MIN(duration_min) AS shortest_session_min,\n        MAX(duration_min) AS longest_session_min\n    FROM session_data\n    GROUP BY BUILDING_NUMBER\n)\nSELECT \n    B.BUILDING_NAME,\n    SA.total_subjects,\n    SA.total_fee,\n    DA.shortest_session_min,\n    DA.longest_session_min\nFROM BUILDINGS B\nJOIN subject_agg SA ON B.BUILDING_NUMBER = SA.BUILDING_NUMBER\nJOIN duration_agg DA ON B.BUILDING_NUMBER = DA.BUILDING_NUMBER\nORDER BY B.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is total number of subjects, the total fee, and the shortest and longest sessions, for all virtual IAP sessions?",
        "predicted_sql": "WITH virtual_sessions AS (\n    SELECT d.ACTIVITY_TITLE, d.FEE,\n           STR_TO_DATE(TRIM(s.SESSION_START_TIME), '%h%i%p') AS start_time,\n           STR_TO_DATE(TRIM(s.SESSION_END_TIME), '%h%i%p') AS end_time\n    FROM IAP_SUBJECT_DETAIL d\n    INNER JOIN IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\n    LEFT JOIN BUILDINGS b ON s.SESSION_LOCATION = b.BUILDING_NUMBER\n    WHERE b.BUILDING_NUMBER IS NULL\n),\nsubject_summary AS (\n    SELECT ACTIVITY_TITLE, MIN(FEE) AS subject_fee\n    FROM virtual_sessions\n    GROUP BY ACTIVITY_TITLE\n)\nSELECT \n    (SELECT COUNT(*) FROM subject_summary) AS total_subjects,\n    (SELECT SUM(subject_fee) FROM subject_summary) AS total_fee,\n    MIN(TIMESTAMPDIFF(MINUTE, start_time, end_time)) AS shortest_session_minutes,\n    MAX(TIMESTAMPDIFF(MINUTE, start_time, end_time)) AS longest_session_minutes\nFROM virtual_sessions;"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, full name of the department, course level, total number of courses, and total number of degree-granting courses for each school code, department, and course level?",
        "predicted_sql": "SELECT \n    sc.SCHOOL_CODE,\n    sc.SCHOOL_NAME,\n    d.DEPARTMENT_FULL_NAME,\n    cd.COURSE_LEVEL,\n    COUNT(DISTINCT cd.COURSE) AS total_courses,\n    COUNT(DISTINCT CASE WHEN cd.IS_DEGREE_GRANTING = 'Y' THEN cd.COURSE END) AS degree_granting_courses\nFROM SIS_COURSE_DESCRIPTION cd\nJOIN SIS_DEPARTMENT d ON cd.DEPARTMENT = d.DEPARTMENT_CODE\nJOIN SIS_SUBJECT_CODE sc ON cd.COURSE = sc.SUBJECT_CODE\nGROUP BY sc.SCHOOL_CODE, sc.SCHOOL_NAME, d.DEPARTMENT_FULL_NAME, cd.COURSE_LEVEL\nORDER BY sc.SCHOOL_CODE, d.DEPARTMENT_FULL_NAME, cd.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What are the different schools and departments that offer SIS courses? List their school code, school name, department code, department name, the total number of phone numbers, and the most common course level.",
        "predicted_sql": "WITH course_agg AS (\n    SELECT \n        s.SCHOOL_CODE,\n        s.SCHOOL_NAME,\n        d.DEPARTMENT_CODE,\n        a.SIS_ADMIN_DEPARTMENT_NAME AS DEPARTMENT_NAME,\n        c.COURSE_LEVEL,\n        COUNT(*) AS level_count\n    FROM SIS_COURSE_DESCRIPTION c\n    JOIN SIS_SUBJECT_CODE s ON c.COURSE = s.SUBJECT_CODE\n    JOIN SIS_DEPARTMENT d ON c.DEPARTMENT = d.DEPARTMENT_CODE\n    JOIN SIS_ADMIN_DEPARTMENT a ON d.DEPARTMENT_CODE = a.SIS_ADMIN_DEPARTMENT_CODE\n    GROUP BY s.SCHOOL_CODE, s.SCHOOL_NAME, d.DEPARTMENT_CODE, a.SIS_ADMIN_DEPARTMENT_NAME, c.COURSE_LEVEL\n),\nranked AS (\n    SELECT \n        SCHOOL_CODE,\n        SCHOOL_NAME,\n        DEPARTMENT_CODE,\n        DEPARTMENT_NAME,\n        COURSE_LEVEL,\n        level_count,\n        ROW_NUMBER() OVER (PARTITION BY SCHOOL_CODE, SCHOOL_NAME, DEPARTMENT_CODE, DEPARTMENT_NAME ORDER BY level_count DESC, COURSE_LEVEL) AS rn\n    FROM course_agg\n)\nSELECT \n    SCHOOL_CODE,\n    SCHOOL_NAME,\n    DEPARTMENT_CODE,\n    DEPARTMENT_NAME,\n    (SELECT COUNT(DISTINCT DEPARTMENT_PHONE_NUMBER) FROM SIS_ADMIN_DEPARTMENT WHERE SIS_ADMIN_DEPARTMENT_CODE = DEPARTMENT_CODE) AS total_phone_numbers,\n    COURSE_LEVEL AS most_common_course_level\nFROM ranked\nWHERE rn = 1;"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, DLC key, the graduate level, total number of SIS subjects, the minimum and maximum course numbers, and the total number of departments offering subjects for each school?",
        "predicted_sql": "SELECT \n    ssc.SCHOOL_CODE,\n    ssc.SCHOOL_NAME,\n    GROUP_CONCAT(DISTINCT sd.DLC_KEY ORDER BY sd.DLC_KEY) AS `DLC_key`,\n    scd.GRADUATE_LEVEL,\n    COUNT(DISTINCT ssc.SUBJECT_CODE) AS `total_SIS_subjects`,\n    MIN(CAST(ssc.COURSE_NUMBER AS UNSIGNED)) AS `min_course_number`,\n    MAX(CAST(ssc.COURSE_NUMBER AS UNSIGNED)) AS `max_course_number`,\n    COUNT(DISTINCT sd.DEPARTMENT_CODE) AS `total_departments_offering_subjects`\nFROM SIS_SUBJECT_CODE ssc\nINNER JOIN SIS_COURSE_DESCRIPTION scd ON ssc.SUBJECT_CODE = scd.COURSE\nINNER JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE\nGROUP BY ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, scd.GRADUATE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What is the building component, name of the building, square footage for all rooms, total number of floors, total number of rooms, total number of facility organizations, total number of supervisors, and total number of supervisees for each building component?",
        "predicted_sql": "WITH building_stats AS (\n    SELECT\n        sd.BUILDING_COMPONENT,\n        MAX(b.BUILDING_NAME) AS building_name,\n        SUM(sd.ROOM_SQUARE_FOOTAGE) AS total_sqft,\n        COUNT(DISTINCT sf.FLOOR) AS total_floors,\n        COUNT(DISTINCT sd.BUILDING_ROOM) AS total_rooms,\n        COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS total_facility_orgs\n    FROM SPACE_DETAIL sd\n    INNER JOIN BUILDINGS b ON b.BUILDING_KEY = sd.BUILDING_COMPONENT\n    INNER JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY\n    INNER JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY\n    GROUP BY sd.BUILDING_COMPONENT\n),\nsupervisor_agg AS (\n    SELECT\n        sd.BUILDING_COMPONENT,\n        ssu.MIT_ID,\n        MAX(ssu.NUM_OF_SUPERVISEES) AS num_supervisees\n    FROM SPACE_DETAIL sd\n    JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY\n    JOIN SPACE_SUPERVISOR_USAGE ssu ON FIND_IN_SET(su.DLC_KEY, ssu.DEPT_NAMES) > 0\n    GROUP BY sd.BUILDING_COMPONENT, ssu.MIT_ID\n),\nsupervisor_stats AS (\n    SELECT\n        BUILDING_COMPONENT,\n        COUNT(MIT_ID) AS total_supervisors,\n        SUM(num_supervisees) AS total_supervisees\n    FROM supervisor_agg\n    GROUP BY BUILDING_COMPONENT\n)\nSELECT\n    bs.BUILDING_COMPONENT AS building_component,\n    bs.building_name,\n    bs.total_sqft AS square_footage,\n    bs.total_floors,\n    bs.total_rooms,\n    bs.total_facility_orgs,\n    COALESCE(ss.total_supervisors, 0) AS total_supervisors,\n    COALESCE(ss.total_supervisees, 0) AS total_supervisees\nFROM building_stats bs\nLEFT JOIN supervisor_stats ss ON bs.BUILDING_COMPONENT = ss.BUILDING_COMPONENT\nORDER BY bs.BUILDING_COMPONENT;"
    },
    {
        "db_id": "dw",
        "question": "What is the DLC key, name of the DLC, total number of floors, total square footage, total number of facility organizations, total number of supervisors, total number of supervisees, and total building heights for each DLC?",
        "predicted_sql": "WITH dlc_org AS (\n    SELECT DISTINCT u.DLC_KEY, o.DLC_NAME\n    FROM SPACE_UNIT u\n    JOIN FCLT_ORGANIZATION o ON u.DLC_KEY = o.DLC_KEY\n),\nfacility_org AS (\n    SELECT DLC_KEY, COUNT(DISTINCT FCLT_ORGANIZATION_KEY) AS total_facility_orgs\n    FROM SPACE_UNIT\n    GROUP BY DLC_KEY\n),\nspace_agg AS (\n    SELECT \n        u.DLC_KEY,\n        SUM(d.ROOM_SQUARE_FOOTAGE) AS total_sqft,\n        COUNT(DISTINCT CONCAT(d.BUILDING_KEY, '|', d.FLOOR_KEY)) AS total_floors\n    FROM SPACE_UNIT u\n    JOIN SPACE_DETAIL d ON u.SPACE_UNIT_KEY = d.SPACE_UNIT_KEY\n    GROUP BY u.DLC_KEY\n),\nbuilding_height_agg AS (\n    SELECT \n        db.DLC_KEY,\n        SUM(CAST(b.BUILDING_HEIGHT AS DECIMAL(10,2))) AS total_building_heights\n    FROM (\n        SELECT DISTINCT u.DLC_KEY, d.BUILDING_KEY\n        FROM SPACE_UNIT u\n        JOIN SPACE_DETAIL d ON u.SPACE_UNIT_KEY = d.SPACE_UNIT_KEY\n    ) db\n    JOIN FCLT_BUILDING b ON db.BUILDING_KEY = b.FCLT_BUILDING_KEY\n    GROUP BY db.DLC_KEY\n),\nsupervisor_agg AS (\n    SELECT \n        u.DLC_KEY,\n        COUNT(DISTINCT s.MIT_ID) AS total_supervisors,\n        SUM(s.NUM_OF_SUPERVISEES) AS total_supervisees\n    FROM SPACE_UNIT u\n    JOIN SPACE_SUPERVISOR_USAGE s ON u.DLC_KEY = s.DEPT_NAMES\n    GROUP BY u.DLC_KEY\n)\nSELECT \n    d.DLC_KEY,\n    d.DLC_NAME,\n    COALESCE(sa.total_floors, 0) AS total_number_of_floors,\n    COALESCE(sa.total_sqft, 0) AS total_square_footage,\n    COALESCE(fo.total_facility_orgs, 0) AS total_number_of_facility_organizations,\n    COALESCE(sup.total_supervisors, 0) AS total_number_of_supervisors,\n    COALESCE(sup.total_supervisees, 0) AS total_number_of_supervisees,\n    COALESCE(bh.total_building_heights, 0) AS total_building_heights\nFROM dlc_org d\nLEFT JOIN facility_org fo ON d.DLC_KEY = fo.DLC_KEY\nLEFT JOIN space_agg sa ON d.DLC_KEY = sa.DLC_KEY\nLEFT JOIN building_height_agg bh ON d.DLC_KEY = bh.DLC_KEY\nLEFT JOIN supervisor_agg sup ON d.DLC_KEY = sup.DLC_KEY\nORDER BY d.DLC_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What is the department name, total number of types of TIP subjects, total number of enrolled students, the minimum and maximum rental new price for each department?",
        "predicted_sql": "SELECT \n    s.OFFER_DEPT_NAME,\n    s.subject_types,\n    s.total_enrolled,\n    r.min_rental_new_price,\n    r.max_rental_new_price\nFROM \n    (SELECT OFFER_DEPT_NAME,\n            COUNT(DISTINCT SUBJECT_ID) AS subject_types,\n            SUM(NUM_ENROLLED_STUDENTS) AS total_enrolled\n     FROM TIP_SUBJECT_OFFERED\n     GROUP BY OFFER_DEPT_NAME) s\nLEFT JOIN\n    (SELECT o.OFFER_DEPT_NAME,\n            MIN(m.RENTAL_NEW_PRICE) AS min_rental_new_price,\n            MAX(m.RENTAL_NEW_PRICE) AS max_rental_new_price\n     FROM TIP_SUBJECT_OFFERED o\n     JOIN TIP_DETAIL d ON o.TIP_SUBJECT_OFFERED_KEY = d.TIP_SUBJECT_OFFERED_KEY\n     JOIN TIP_MATERIAL m ON d.TIP_MATERIAL_KEY = m.TIP_MATERIAL_KEY\n     GROUP BY o.OFFER_DEPT_NAME) r\nON s.OFFER_DEPT_NAME = r.OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the details of courses offered in the current academic term, including the academic year, term code, hgn code, the total number of types of courses, the average number of units, the department name, the name and email address of the person in charge?",
        "predicted_sql": "SELECT\n    c.ACADEMIC_YEAR,\n    a.TERM_CODE,\n    s.HGN_CODE,\n    COUNT(*) AS total_number_of_courses,\n    AVG(c.TOTAL_UNITS) AS average_number_of_units,\n    c.DEPARTMENT_NAME,\n    e.FULL_NAME AS person_in_charge_name,\n    e.EMAIL_ADDRESS AS person_in_charge_email\nFROM ACADEMIC_TERMS a\nJOIN COURSE_CATALOG_SUBJECT_OFFERED c ON c.TERM_CODE = a.TERM_CODE\nJOIN SUBJECT_OFFERED s ON s.SUBJECT_ID = c.SUBJECT_ID AND s.TERM_CODE = a.TERM_CODE\nJOIN EMPLOYEE_DIRECTORY e ON e.MIT_ID = s.RESPONSIBLE_FACULTY_MIT_ID\nWHERE a.IS_CURRENT_TERM = 'Y'\n  AND c.IS_MASTER_SECTION = 'Y'\n  AND s.IS_MASTER_SECTION = 'Y'\nGROUP BY c.ACADEMIC_YEAR, a.TERM_CODE, s.HGN_CODE, c.DEPARTMENT_NAME, e.FULL_NAME, e.EMAIL_ADDRESS;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve information about the IAP subjects, including their titles, categories, session titles, session start time, session end time, sponsor names, and total number of sessions.",
        "predicted_sql": "SELECT \n    d.ACTIVITY_TITLE,\n    c.IAP_CATEGORY_NAME,\n    s.SESSION_TITLE,\n    s.SESSION_START_TIME,\n    s.SESSION_END_TIME,\n    sp.SPONSOR_NAME,\n    COUNT(*) OVER (PARTITION BY d.IAP_SUBJECT_CATEGORY_KEY, d.IAP_SUBJECT_SPONSOR_KEY, d.ACTIVITY_TITLE) AS total_sessions\nFROM IAP_SUBJECT_DETAIL d\nJOIN IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\nJOIN IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nJOIN IAP_SUBJECT_SPONSOR sp ON d.IAP_SUBJECT_SPONSOR_KEY = sp.IAP_SUBJECT_SPONSOR_KEY;"
    },
    {
        "db_id": "dw",
        "question": "Show the department names, the corresponding SIS subject code, subject code descriptions, graduate level, and the total number of courses per department.",
        "predicted_sql": "SELECT \n    d.DEPARTMENT_NAME,\n    s.SUBJECT_CODE,\n    s.SUBJECT_CODE_DESC,\n    c.GRADUATE_LEVEL,\n    COUNT(DISTINCT c.COURSE) AS total_courses\nFROM SIS_DEPARTMENT d\nINNER JOIN SIS_COURSE_DESCRIPTION c ON d.DEPARTMENT_CODE = c.DEPARTMENT\nINNER JOIN SIS_SUBJECT_CODE s ON c.COURSE = s.COURSE_NUMBER\nGROUP BY \n    d.DEPARTMENT_NAME,\n    s.SUBJECT_CODE,\n    s.SUBJECT_CODE_DESC,\n    c.GRADUATE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "For each term, list the term code, the term description, whether the term is current or not, and the total number of types of CIS courses.",
        "predicted_sql": "SELECT \n    a.TERM_CODE,\n    a.TERM_DESCRIPTION,\n    CASE \n        WHEN a.TERM_CODE = (SELECT TERM_CODE FROM ACADEMIC_TERM_PARAMETER WHERE IS_CURRENT_TERM = 'Y') THEN 'Y' \n        ELSE 'N' \n    END AS IS_CURRENT,\n    COUNT(DISTINCT \n        CASE \n            WHEN RIGHT(a.TERM_CODE, 2) = 'FA' AND c.IS_OFFERED_FALL_TERM = 'Y' THEN c.SUBJECT_ID\n            WHEN RIGHT(a.TERM_CODE, 2) = 'SP' AND c.IS_OFFERED_SPRING_TERM = 'Y' THEN c.SUBJECT_ID\n            WHEN RIGHT(a.TERM_CODE, 2) = 'SU' AND c.IS_OFFERED_SUMMER_TERM = 'Y' THEN c.SUBJECT_ID\n            WHEN RIGHT(a.TERM_CODE, 2) = 'JA' AND c.IS_OFFERED_IAP = 'Y' THEN c.SUBJECT_ID\n            ELSE NULL\n        END\n    ) AS TOTAL_CIS_COURSES\nFROM ACADEMIC_TERMS_ALL a\nLEFT JOIN CIS_COURSE_CATALOG c ON a.ACADEMIC_YEAR = c.ACADEMIC_YEAR\nGROUP BY a.TERM_CODE, a.TERM_DESCRIPTION\nORDER BY a.TERM_CODE;"
    },
    {
        "db_id": "dw",
        "question": "What is the author, school name, material status, total record counts, and total number of types of courses for each author and school?",
        "predicted_sql": "SELECT TM.AUTHOR, SD.SCHOOL_NAME, TMS.TIP_MATERIAL_STATUS AS MATERIAL_STATUS, SUM(TD.RECORD_COUNT) AS TOTAL_RECORD_COUNTS, COUNT(DISTINCT TD.SUBJECT_ID) AS TOTAL_NUMBER_OF_TYPES_OF_COURSES\nFROM TIP_DETAIL TD\nJOIN TIP_MATERIAL TM ON TD.TIP_MATERIAL_KEY = TM.TIP_MATERIAL_KEY\nJOIN TIP_MATERIAL_STATUS TMS ON TD.TIP_MATERIAL_STATUS_KEY = TMS.TIP_MATERIAL_STATUS_KEY\nJOIN TIP_SUBJECT_OFFERED TSO ON TD.TIP_SUBJECT_OFFERED_KEY = TSO.TIP_SUBJECT_OFFERED_KEY\nJOIN STUDENT_DEPARTMENT SD ON TSO.OFFER_DEPT_CODE = SD.DEPARTMENT_CODE\nGROUP BY TM.AUTHOR, SD.SCHOOL_NAME, TMS.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is the course number, subject title, material status, the total, min, and max new shelf price, the total, min, and max used shelf price, total number of schools and the total number of materials for each TIP subject and material status?",
        "predicted_sql": "WITH base AS (\n    SELECT \n        O.COURSE_NUMBER,\n        O.SUBJECT_TITLE,\n        S.TIP_MATERIAL_STATUS,\n        M.TIP_MATERIAL_KEY,\n        M.NEW_SHELF_PRICE,\n        M.USED_SHELF_PRICE,\n        O.OFFER_SCHOOL_NAME\n    FROM TIP_DETAIL D\n    JOIN TIP_MATERIAL M ON D.TIP_MATERIAL_KEY = M.TIP_MATERIAL_KEY\n    JOIN TIP_MATERIAL_STATUS S ON D.TIP_MATERIAL_STATUS_KEY = S.TIP_MATERIAL_STATUS_KEY\n    JOIN TIP_SUBJECT_OFFERED O ON D.TIP_SUBJECT_OFFERED_KEY = O.TIP_SUBJECT_OFFERED_KEY\n),\nmaterial_dedup AS (\n    SELECT DISTINCT\n        COURSE_NUMBER,\n        SUBJECT_TITLE,\n        TIP_MATERIAL_STATUS,\n        TIP_MATERIAL_KEY,\n        NEW_SHELF_PRICE,\n        USED_SHELF_PRICE\n    FROM base\n),\nmaterial_agg AS (\n    SELECT\n        COURSE_NUMBER,\n        SUBJECT_TITLE,\n        TIP_MATERIAL_STATUS,\n        COUNT(*) AS TOTAL_MATERIALS,\n        SUM(NEW_SHELF_PRICE) AS TOTAL_NEW_SHELF_PRICE,\n        MIN(NEW_SHELF_PRICE) AS MIN_NEW_SHELF_PRICE,\n        MAX(NEW_SHELF_PRICE) AS MAX_NEW_SHELF_PRICE,\n        SUM(USED_SHELF_PRICE) AS TOTAL_USED_SHELF_PRICE,\n        MIN(USED_SHELF_PRICE) AS MIN_USED_SHELF_PRICE,\n        MAX(USED_SHELF_PRICE) AS MAX_USED_SHELF_PRICE\n    FROM material_dedup\n    GROUP BY COURSE_NUMBER, SUBJECT_TITLE, TIP_MATERIAL_STATUS\n),\nschool_agg AS (\n    SELECT\n        COURSE_NUMBER,\n        SUBJECT_TITLE,\n        TIP_MATERIAL_STATUS,\n        COUNT(DISTINCT OFFER_SCHOOL_NAME) AS TOTAL_SCHOOLS\n    FROM base\n    GROUP BY COURSE_NUMBER, SUBJECT_TITLE, TIP_MATERIAL_STATUS\n)\nSELECT\n    m.COURSE_NUMBER,\n    m.SUBJECT_TITLE,\n    m.TIP_MATERIAL_STATUS,\n    m.TOTAL_NEW_SHELF_PRICE,\n    m.MIN_NEW_SHELF_PRICE,\n    m.MAX_NEW_SHELF_PRICE,\n    m.TOTAL_USED_SHELF_PRICE,\n    m.MIN_USED_SHELF_PRICE,\n    m.MAX_USED_SHELF_PRICE,\n    s.TOTAL_SCHOOLS,\n    m.TOTAL_MATERIALS\nFROM material_agg m\nJOIN school_agg s\n    ON m.COURSE_NUMBER = s.COURSE_NUMBER\n    AND m.SUBJECT_TITLE = s.SUBJECT_TITLE\n    AND m.TIP_MATERIAL_STATUS = s.TIP_MATERIAL_STATUS\nORDER BY m.COURSE_NUMBER, m.SUBJECT_TITLE, m.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is material status, the total number of materials, the total number of subjects, the total number of schools, and the most recent publication year for each material status?",
        "predicted_sql": "SELECT \n    tms.TIP_MATERIAL_STATUS AS material_status,\n    COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS total_materials,\n    COUNT(DISTINCT td.SUBJECT_ID) AS total_subjects,\n    COUNT(DISTINCT sd.SCHOOL_NAME) AS total_schools,\n    MAX(tm.YEAR) AS most_recent_publication_year\nFROM TIP_DETAIL td\nJOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nJOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nJOIN STUDENT_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE\nGROUP BY tms.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is the term description, whether the term is current or not, total number of types of TIP subjects offered and materials needed, the minimum and maximum number of enrolled students, the total number of schools offering subjects, and the total number of records for each term code?",
        "predicted_sql": "SELECT\n    a.TERM_CODE,\n    a.TERM_DESCRIPTION,\n    a.IS_CURRENT_TERM,\n    COUNT(DISTINCT s.COURSE_NUMBER) AS subjects_offered_count,\n    COUNT(DISTINCT m.ISBN) AS materials_needed_count,\n    MIN(s.NUM_ENROLLED_STUDENTS) AS min_enrolled,\n    MAX(s.NUM_ENROLLED_STUDENTS) AS max_enrolled,\n    COUNT(DISTINCT s.OFFER_SCHOOL_NAME) AS schools_count,\n    COALESCE(SUM(d.RECORD_COUNT), 0) AS total_records\nFROM\n    ACADEMIC_TERMS_ALL a\n    INNER JOIN TIP_SUBJECT_OFFERED s ON a.TERM_CODE = s.TERM_CODE\n    LEFT JOIN TIP_DETAIL d ON s.TIP_SUBJECT_OFFERED_KEY = d.TIP_SUBJECT_OFFERED_KEY\n    LEFT JOIN TIP_MATERIAL m ON d.TIP_MATERIAL_KEY = m.TIP_MATERIAL_KEY\n    LEFT JOIN TIP_MATERIAL_STATUS ms ON d.TIP_MATERIAL_STATUS_KEY = ms.TIP_MATERIAL_STATUS_KEY\nGROUP BY\n    a.TERM_CODE, a.TERM_DESCRIPTION, a.IS_CURRENT_TERM\nORDER BY\n    a.TERM_CODE;"
    },
    {
        "db_id": "dw",
        "question": "List all buildings with their names, building numbers, building height, street address, city, state, HR department name, assignable square footage, total and average square footage, ordered in descending order of assignable, total, and average square footage.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME,\n    b.BUILDING_NUMBER,\n    fb.BUILDING_HEIGHT,\n    b.BUILDING_STREET_ADDRESS,\n    fba.CITY,\n    fba.STATE,\n    fo.HR_DEPARTMENT_NAME,\n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE AS assignable_sqft,\n    SUM(CAST(fr.AREA AS DECIMAL(10,2))) AS total_sqft,\n    AVG(CAST(fr.AREA AS DECIMAL(10,2))) AS avg_sqft\nFROM BUILDINGS b\nINNER JOIN FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY\nINNER JOIN FAC_ROOMS fr ON b.BUILDING_KEY = fr.BUILDING_KEY\nINNER JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY\nINNER JOIN FAC_BUILDING_ADDRESS fba ON b.BUILDING_KEY = fba.BUILDING_KEY AND fba.ADDRESS_PURPOSE = 'STREET'\nGROUP BY \n    b.BUILDING_NAME,\n    b.BUILDING_NUMBER,\n    fb.BUILDING_HEIGHT,\n    b.BUILDING_STREET_ADDRESS,\n    fba.CITY,\n    fba.STATE,\n    fo.HR_DEPARTMENT_NAME,\n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE\nORDER BY \n    assignable_sqft DESC,\n    total_sqft DESC,\n    avg_sqft DESC;"
    },
    {
        "db_id": "dw",
        "question": "For the 2023 Fall term, what are the unique term descriptions, subject titles along with their prerequisites, total number of types of subjects per term code, instructor of this course, and the number of types of courses ever taught by the instructor?",
        "predicted_sql": "WITH term_total AS (\n    SELECT term_code, COUNT(DISTINCT subject_id) AS total_subjects\n    FROM COURSE_CATALOG_SUBJECT_OFFERED\n    WHERE term_code = '2023FA'\n    GROUP BY term_code\n),\ninstructor_total AS (\n    SELECT fall_instructors AS instructor, COUNT(DISTINCT subject_id) AS total_courses\n    FROM COURSE_CATALOG_SUBJECT_OFFERED\n    WHERE fall_instructors IS NOT NULL\n    GROUP BY fall_instructors\n)\nSELECT \n    a.TERM_DESCRIPTION,\n    c.SUBJECT_TITLE,\n    c.PREREQUISITES,\n    tt.total_subjects AS total_subjects_per_term,\n    c.FALL_INSTRUCTORS AS instructor,\n    COALESCE(it.total_courses, 0) AS instructor_total_courses\nFROM COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN ACADEMIC_TERMS a ON c.TERM_CODE = a.TERM_CODE\nJOIN term_total tt ON c.TERM_CODE = tt.term_code\nLEFT JOIN instructor_total it ON c.FALL_INSTRUCTORS = it.instructor\nWHERE c.TERM_CODE = '2023FA';"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the assignable floor area and building.",
        "predicted_sql": "SELECT \n    r.ROOM_FULL_NAME,\n    b.BUILDING_NAME,\n    f.FLOOR,\n    o.ORGANIZATION_NAME,\n    o.HR_DEPARTMENT_NAME,\n    (r.AREA / f.ASSIGNABLE_AREA) * 100 AS pct_of_floor_assignable_area,\n    (r.AREA / b.ASSIGNABLE_AREA) * 100 AS pct_of_building_assignable_area\nFROM FAC_ROOMS r\nJOIN FAC_BUILDING b ON r.BUILDING_KEY = b.FAC_BUILDING_KEY\nJOIN FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nJOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the floor area and building.",
        "predicted_sql": "SELECT\n    r.ROOM_FULL_NAME AS `Room Full Name`,\n    b.BUILDING_NAME AS `Building Name`,\n    f.FLOOR AS `Floor Number`,\n    o.ORGANIZATION_NAME AS `Organization`,\n    o.HR_DEPARTMENT_NAME AS `Department`,\n    ROUND((CAST(r.AREA AS DECIMAL) / SUM(CAST(r.AREA AS DECIMAL)) OVER (PARTITION BY r.FLOOR_KEY) * 100), 2) AS `% of Floor Area`,\n    ROUND((CAST(r.AREA AS DECIMAL) / SUM(CAST(r.AREA AS DECIMAL)) OVER (PARTITION BY r.BUILDING_KEY) * 100), 2) AS `% of Building Area`\nFROM FAC_ROOMS r\nLEFT JOIN FAC_BUILDING b ON r.BUILDING_KEY = b.FAC_BUILDING_KEY\nLEFT JOIN FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nLEFT JOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\nORDER BY b.BUILDING_NAME, f.FLOOR, r.ROOM_FULL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the academic year, and instructors names for courses offered in the academic year 2022, along with the total number of types of courses per instructor?",
        "predicted_sql": "SELECT a.ACADEMIC_YEAR, e.FULL_NAME, COUNT(DISTINCT s.SUBJECT_ID) AS total_types_of_courses\nFROM SUBJECT_OFFERED s\nJOIN ACADEMIC_TERMS_ALL a ON s.TERM_CODE = a.TERM_CODE\nJOIN EMPLOYEE_DIRECTORY e ON s.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nWHERE a.ACADEMIC_YEAR = '2022'\nGROUP BY a.ACADEMIC_YEAR, e.FULL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the building names, department names, organizations, their highest and lowest floor number, along with the total number of rooms per each building key?",
        "predicted_sql": "SELECT \n    b.FAC_BUILDING_KEY AS building_key,\n    b.BUILDING_NAME AS building_name,\n    GROUP_CONCAT(DISTINCT o.HR_DEPARTMENT_NAME ORDER BY o.HR_DEPARTMENT_NAME) AS department_names,\n    GROUP_CONCAT(DISTINCT o.ORGANIZATION ORDER BY o.ORGANIZATION) AS organizations,\n    MAX(CAST(f.LEVEL_ID AS SIGNED)) AS highest_floor_number,\n    MIN(CAST(f.LEVEL_ID AS SIGNED)) AS lowest_floor_number,\n    COUNT(DISTINCT r.FAC_ROOM_KEY) AS total_rooms\nFROM FAC_ROOMS r\nJOIN FAC_BUILDING b ON r.BUILDING_KEY = b.FAC_BUILDING_KEY\nJOIN FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nJOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\nGROUP BY b.FAC_BUILDING_KEY, b.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Provide the complete information for students with the first name Kevin, including their full names, email addresses, department names, department phone numbers, school names, and the total student count per department and school. If a student is associated with more than one department, list a separate row for each department.",
        "predicted_sql": "SELECT \n    m.FULL_NAME,\n    m.EMAIL_ADDRESS,\n    d.DEPARTMENT_NAME,\n    a.DEPARTMENT_PHONE_NUMBER,\n    d.SCHOOL_NAME,\n    c.total_students\nFROM MIT_STUDENT_DIRECTORY m\nINNER JOIN SIS_DEPARTMENT d ON m.DEPARTMENT = d.DEPARTMENT_CODE\nINNER JOIN SIS_ADMIN_DEPARTMENT a ON a.SIS_ADMIN_DEPARTMENT_CODE = d.DEPARTMENT_CODE\nINNER JOIN (\n    SELECT \n        d.DEPARTMENT_CODE,\n        d.SCHOOL_CODE,\n        COUNT(*) AS total_students\n    FROM MIT_STUDENT_DIRECTORY m\n    INNER JOIN SIS_DEPARTMENT d ON m.DEPARTMENT = d.DEPARTMENT_CODE\n    GROUP BY d.DEPARTMENT_CODE, d.SCHOOL_CODE\n) c ON d.DEPARTMENT_CODE = c.DEPARTMENT_CODE AND d.SCHOOL_CODE = c.SCHOOL_CODE\nWHERE m.FIRST_NAME = 'Kevin';"
    },
    {
        "db_id": "dw",
        "question": "What are the unique titles of subjects offered in the fall term along with their instructor names, instructor emails, and the total number of types of subjects per instructor?",
        "predicted_sql": "SELECT DISTINCT\n    c.SUBJECT_TITLE AS subject_title,\n    e.FULL_NAME AS instructor_name,\n    e.EMAIL_ADDRESS AS instructor_email,\n    ic.total_subjects AS total_subjects_per_instructor\nFROM COURSE_CATALOG_SUBJECT_OFFERED c\nINNER JOIN ACADEMIC_TERMS_ALL t ON c.TERM_CODE = t.TERM_CODE\nINNER JOIN EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nINNER JOIN (\n    SELECT RESPONSIBLE_FACULTY_MIT_ID, COUNT(DISTINCT SUBJECT_TITLE) AS total_subjects\n    FROM COURSE_CATALOG_SUBJECT_OFFERED\n    GROUP BY RESPONSIBLE_FACULTY_MIT_ID\n) ic ON ic.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nWHERE t.TERM_CODE LIKE '%FA'\nORDER BY c.SUBJECT_TITLE, e.FULL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List the building names, names of HR departments occupying them, the total gross square footage, the total and average assignable square footage, and the built year per building key.",
        "predicted_sql": "WITH BuildingDept AS (\n    SELECT DISTINCT\n        r.BUILDING_KEY,\n        o.HR_DEPARTMENT_NAME\n    FROM FAC_ROOMS r\n    INNER JOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\n),\nDeptCount AS (\n    SELECT BUILDING_KEY, COUNT(*) AS dept_count\n    FROM BuildingDept\n    GROUP BY BUILDING_KEY\n)\nSELECT\n    b.BUILDING_KEY,\n    b.BUILDING_NAME,\n    bd.HR_DEPARTMENT_NAME,\n    b.BLDG_GROSS_SQUARE_FOOTAGE AS total_gross_sqft,\n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE AS total_assignable_sqft,\n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE / dc.dept_count AS avg_assignable_sqft,\n    YEAR(STR_TO_DATE(fb.DATE_BUILT, '%m/%d/%Y')) AS built_year\nFROM BUILDINGS b\nINNER JOIN FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY\nINNER JOIN BuildingDept bd ON b.BUILDING_KEY = bd.BUILDING_KEY\nINNER JOIN DeptCount dc ON b.BUILDING_KEY = dc.BUILDING_KEY\nORDER BY b.BUILDING_KEY, bd.HR_DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve the titles of subjects offered in the summer term along with their descriptions, responsible faculty names, email address, building name, room name, floor level, building street address, and the total number of types of courses per departmnet.",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE,\n    c.SUBJECT_DESCRIPTION,\n    c.RESPONSIBLE_FACULTY_NAME,\n    e.EMAIL_ADDRESS,\n    b.BUILDING_NAME,\n    r.ROOM_FULL_NAME,\n    f.LEVEL_ID,\n    b.BUILDING_STREET_ADDRESS,\n    d.dept_course_count AS total_courses_per_department\nFROM COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN ACADEMIC_TERMS t ON c.TERM_CODE = t.TERM_CODE\nJOIN EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nJOIN FAC_ROOMS r ON c.MEET_PLACE = r.FAC_ROOM_KEY\nJOIN FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nJOIN BUILDINGS b ON r.BUILDING_KEY = b.BUILDING_KEY\nJOIN (\n    SELECT DEPARTMENT_CODE, COUNT(DISTINCT MASTER_SUBJECT_ID) AS dept_course_count\n    FROM COURSE_CATALOG_SUBJECT_OFFERED\n    GROUP BY DEPARTMENT_CODE\n) d ON c.DEPARTMENT_CODE = d.DEPARTMENT_CODE\nWHERE t.TERM_CODE LIKE '%SU';"
    },
    {
        "db_id": "dw",
        "question": "For each term code, list the term description, attribute desciption, department name, school name, and the number of subjects in the area of humanities, arts and social sciences.",
        "predicted_sql": "SELECT \n    C.TERM_CODE,\n    A.TERM_DESCRIPTION,\n    C.HASS_ATTRIBUTE_DESC AS ATTRIBUTE_DESCRIPTION,\n    D.DEPARTMENT_NAME,\n    D.SCHOOL_NAME,\n    COUNT(DISTINCT C.SUBJECT_ID) AS NUMBER_OF_SUBJECTS\nFROM COURSE_CATALOG_SUBJECT_OFFERED C\nINNER JOIN ACADEMIC_TERMS_ALL A ON C.TERM_CODE = A.TERM_CODE\nINNER JOIN SIS_DEPARTMENT D ON C.DEPARTMENT_CODE = D.DEPARTMENT_CODE\nINNER JOIN CIS_HASS_ATTRIBUTE H ON C.HASS_ATTRIBUTE = H.HASS_ATTRIBUTE\nWHERE H.CIS_ATTRIBUTE_GROUP = 'H'\nGROUP BY C.TERM_CODE, A.TERM_DESCRIPTION, C.HASS_ATTRIBUTE_DESC, D.DEPARTMENT_NAME, D.SCHOOL_NAME\nORDER BY C.TERM_CODE, A.TERM_DESCRIPTION, C.HASS_ATTRIBUTE_DESC, D.DEPARTMENT_NAME, D.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List building names, their height, street address, city, state, postal code, their gross and assignable square footage, the smallest and largest floor level and the total area of all rooms for each building key.",
        "predicted_sql": "SELECT \n    fb.FAC_BUILDING_KEY AS building_key,\n    fb.BUILDING_NAME,\n    fb.BUILDING_HEIGHT,\n    b.BUILDING_STREET_ADDRESS,\n    fba.CITY,\n    fba.STATE,\n    fba.POSTAL_CODE,\n    fb.EXT_GROSS_AREA AS gross_sq_ft,\n    fb.ASSIGNABLE_AREA AS assignable_sq_ft,\n    fa.min_floor AS smallest_floor,\n    fa.max_floor AS largest_floor,\n    COALESCE(ra.total_area, 0) AS total_room_area\nFROM FAC_BUILDING fb\nLEFT JOIN BUILDINGS b ON fb.FAC_BUILDING_KEY = b.BUILDING_KEY\nLEFT JOIN (\n    SELECT BUILDING_KEY,\n           MAX(CITY) AS CITY,\n           MAX(STATE) AS STATE,\n           MAX(POSTAL_CODE) AS POSTAL_CODE\n    FROM FAC_BUILDING_ADDRESS\n    WHERE ADDRESS_PURPOSE = 'STREET'\n    GROUP BY BUILDING_KEY\n) fba ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY\nLEFT JOIN (\n    SELECT BUILDING_KEY,\n           MIN(CAST(LEVEL_ID AS INTEGER)) AS min_floor,\n           MAX(CAST(LEVEL_ID AS INTEGER)) AS max_floor\n    FROM FAC_FLOOR\n    GROUP BY BUILDING_KEY\n) fa ON fb.FAC_BUILDING_KEY = fa.BUILDING_KEY\nLEFT JOIN (\n    SELECT BUILDING_KEY,\n           SUM(CAST(AREA AS REAL)) AS total_area\n    FROM FAC_ROOMS\n    GROUP BY BUILDING_KEY\n) ra ON fb.FAC_BUILDING_KEY = ra.BUILDING_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What is the category title, version, department name, school name, total number of courses for each course level, and the total number of degree-granting courses for each CIP category code?",
        "predicted_sql": "SELECT \n    c.CATEGORY_CODE,\n    c.CATEGORY_TITLE,\n    c.VERSION,\n    d.DEPARTMENT_NAME,\n    d.SCHOOL_NAME,\n    COUNT(CASE WHEN cd.COURSE_LEVEL = 'U' THEN 1 END) AS Undergraduate_Courses,\n    COUNT(CASE WHEN cd.COURSE_LEVEL = 'G' THEN 1 END) AS Graduate_Courses,\n    COUNT(CASE WHEN cd.IS_DEGREE_GRANTING = 'Y' THEN 1 END) AS Degree_Granting_Courses\nFROM SIS_COURSE_DESCRIPTION cd\nJOIN CIP c ON cd.CIP_PROGRAM_CODE = c.PROGRAM_CODE\nJOIN SIS_DEPARTMENT d ON cd.DEPARTMENT = d.DEPARTMENT_CODE\nGROUP BY \n    c.CATEGORY_CODE,\n    c.CATEGORY_TITLE,\n    c.VERSION,\n    d.DEPARTMENT_NAME,\n    d.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library materials, the minimum and maximum publication years, and the total number of materials status for each course name?",
        "predicted_sql": "SELECT \n    i.COURSE_NAME,\n    COUNT(DISTINCT c.CATALOG_SYSTEM_NUMBER) AS total_library_materials,\n    MIN(CAST(c.CATALOG_YEAR AS UNSIGNED)) AS min_publication_year,\n    MAX(CAST(c.CATALOG_YEAR AS UNSIGNED)) AS max_publication_year,\n    COUNT(*) AS total_materials_status\nFROM LIBRARY_RESERVE_MATRL_DETAIL f\nINNER JOIN LIBRARY_COURSE_INSTRUCTOR i ON f.LIBRARY_COURSE_INSTRUCTOR_KEY = i.LIBRARY_COURSE_INSTRUCTOR_KEY\nINNER JOIN LIBRARY_RESERVE_CATALOG c ON f.LIBRARY_RESERVE_CATALOG_KEY = c.LIBRARY_RESERVE_CATALOG_KEY\nINNER JOIN LIBRARY_MATERIAL_STATUS s ON f.LIBRARY_MATERIAL_STATUS_KEY = s.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY i.COURSE_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library reserve materials, the minimum and maximum publication years, and the total number of enrolled students for each course instructor?",
        "predicted_sql": "SELECT \n    c.INSTRUCTOR_NAME,\n    c.total_materials,\n    c.min_pub_year AS min_publication_year,\n    c.max_pub_year AS max_publication_year,\n    COALESCE(e.total_enrolled_students, 0) AS total_enrolled_students\nFROM (\n    SELECT \n        i.INSTRUCTOR_NAME,\n        COUNT(DISTINCT c.LIBRARY_RESERVE_CATALOG_KEY) AS total_materials,\n        MIN(CAST(c.CATALOG_YEAR AS UNSIGNED)) AS min_pub_year,\n        MAX(CAST(c.CATALOG_YEAR AS UNSIGNED)) AS max_pub_year\n    FROM LIBRARY_COURSE_INSTRUCTOR i\n    INNER JOIN LIBRARY_RESERVE_MATRL_DETAIL d ON i.LIBRARY_COURSE_INSTRUCTOR_KEY = d.LIBRARY_COURSE_INSTRUCTOR_KEY\n    INNER JOIN LIBRARY_RESERVE_CATALOG c ON d.LIBRARY_RESERVE_CATALOG_KEY = c.LIBRARY_RESERVE_CATALOG_KEY\n    GROUP BY i.INSTRUCTOR_NAME\n) c\nLEFT JOIN (\n    SELECT\n        inst_subj.INSTRUCTOR_NAME,\n        SUM(s.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\n    FROM (\n        SELECT DISTINCT i.INSTRUCTOR_NAME, d.LIBRARY_SUBJECT_OFFERED_KEY\n        FROM LIBRARY_COURSE_INSTRUCTOR i\n        INNER JOIN LIBRARY_RESERVE_MATRL_DETAIL d ON i.LIBRARY_COURSE_INSTRUCTOR_KEY = d.LIBRARY_COURSE_INSTRUCTOR_KEY\n    ) inst_subj\n    INNER JOIN LIBRARY_SUBJECT_OFFERED s ON inst_subj.LIBRARY_SUBJECT_OFFERED_KEY = s.LIBRARY_SUBJECT_OFFERED_KEY\n    GROUP BY inst_subj.INSTRUCTOR_NAME\n) e ON c.INSTRUCTOR_NAME = e.INSTRUCTOR_NAME\nORDER BY c.INSTRUCTOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the material status, term description, total number of courses and materials, occurences in departments and school, and the total number of instructors for each library material status code and term code?",
        "predicted_sql": "SELECT\n    lms.LIBRARY_MATERIAL_STATUS_CODE AS material_status_code,\n    ata.TERM_CODE AS term_code,\n    lms.LIBRARY_MATERIAL_STATUS AS material_status,\n    ata.TERM_DESCRIPTION AS term_description,\n    COUNT(DISTINCT lso.COURSE_NUMBER) AS total_courses,\n    COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS total_materials,\n    COUNT(DISTINCT lso.OFFER_DEPT_CODE) AS total_departments,\n    COUNT(DISTINCT lso.OFFER_SCHOOL_NAME) AS total_schools,\n    COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS total_instructors\nFROM LIBRARY_RESERVE_MATRL_DETAIL lrmd\nINNER JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nINNER JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nINNER JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY\nINNER JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nINNER JOIN ACADEMIC_TERMS_ALL ata ON lso.TERM_CODE = ata.TERM_CODE\nGROUP BY\n    lms.LIBRARY_MATERIAL_STATUS_CODE,\n    ata.TERM_CODE,\n    lms.LIBRARY_MATERIAL_STATUS,\n    ata.TERM_DESCRIPTION\nORDER BY\n    lms.LIBRARY_MATERIAL_STATUS_CODE,\n    ata.TERM_CODE;"
    },
    {
        "db_id": "dw",
        "question": "For building 36, list all space units, their floor and building name, building street address, their space usage, and the number of organizations and space units on the same building and floor.",
        "predicted_sql": "SELECT su.SPACE_UNIT, f.FLOOR, b.BUILDING_NAME, b.BUILDING_STREET_ADDRESS, u.SPACE_USAGE,\n       cnt.org_count, cnt.space_unit_count\nFROM SPACE_DETAIL sd\nJOIN BUILDINGS b ON sd.BUILDING_KEY = b.BUILDING_KEY\nJOIN SPACE_FLOOR f ON sd.FLOOR_KEY = f.FLOOR_KEY\nJOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY\nJOIN SPACE_USAGE u ON sd.SPACE_USAGE_KEY = u.SPACE_USAGE_KEY\nJOIN (\n    SELECT sd.BUILDING_KEY, sd.FLOOR_KEY,\n           COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS org_count,\n           COUNT(DISTINCT sd.SPACE_UNIT_KEY) AS space_unit_count\n    FROM SPACE_DETAIL sd\n    JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY\n    JOIN BUILDINGS b ON sd.BUILDING_KEY = b.BUILDING_KEY\n    WHERE b.BUILDING_NUMBER = '36'\n    GROUP BY sd.BUILDING_KEY, sd.FLOOR_KEY\n) cnt ON sd.BUILDING_KEY = cnt.BUILDING_KEY AND sd.FLOOR_KEY = cnt.FLOOR_KEY\nWHERE b.BUILDING_NUMBER = '36'\nORDER BY f.FLOOR, su.SPACE_UNIT;"
    },
    {
        "db_id": "dw",
        "question": "For each distinct mailing list containing more than 1000 people and with a name starting with A (case insensitive), provide its name, whether it is a mailing list, whether it is a moira group, whether it is a NFS group, the owner of the mailing list, and the number of people in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME AS name,\n    ml.IS_MOIRA_MAILING_LIST,\n    ml.IS_MOIRA_GROUP,\n    ml.IS_NFS_GROUP,\n    mo.OWNER AS owner,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS number_of_people\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN MOIRA_LIST_OWNER mo ON mld.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY\nWHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'A%'\nGROUP BY \n    ml.MOIRA_LIST_KEY,\n    ml.MOIRA_LIST_NAME,\n    ml.IS_MOIRA_MAILING_LIST,\n    ml.IS_MOIRA_GROUP,\n    ml.IS_NFS_GROUP,\n    mo.OWNER\nHAVING COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) > 1000\nORDER BY ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List the mailing lists with the largest number of members and the least number of members, including their names, owners, public status, hidden status, and number of members in the list. If a mailing list has multiple owners, create a separate entry for each owner. Similarly, if multiple lists share the minimum or maximum member count, include all those lists.",
        "predicted_sql": "WITH list_member_counts AS (\n    SELECT \n        l.MOIRA_LIST_KEY,\n        l.MOIRA_LIST_NAME,\n        l.IS_PUBLIC,\n        l.IS_HIDDEN,\n        COUNT(DISTINCT d.MOIRA_LIST_MEMBER) AS member_count\n    FROM MOIRA_LIST l\n    LEFT JOIN MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\n    WHERE l.IS_MOIRA_MAILING_LIST = 'Y'\n    GROUP BY l.MOIRA_LIST_KEY, l.MOIRA_LIST_NAME, l.IS_PUBLIC, l.IS_HIDDEN\n),\nmin_max AS (\n    SELECT \n        MIN(member_count) AS min_count,\n        MAX(member_count) AS max_count\n    FROM list_member_counts\n),\neligible_lists AS (\n    SELECT lmc.*\n    FROM list_member_counts lmc\n    CROSS JOIN min_max mm\n    WHERE lmc.member_count = mm.min_count OR lmc.member_count = mm.max_count\n),\nlist_owners AS (\n    SELECT DISTINCT \n        d.MOIRA_LIST_KEY,\n        o.OWNER\n    FROM MOIRA_LIST_DETAIL d\n    JOIN MOIRA_LIST_OWNER o ON d.MOIRA_LIST_OWNER_KEY = o.MOIRA_LIST_OWNER_KEY\n)\nSELECT \n    e.MOIRA_LIST_NAME AS name,\n    lo.OWNER AS owner,\n    e.IS_PUBLIC AS public_status,\n    e.IS_HIDDEN AS hidden_status,\n    e.member_count AS number_of_members\nFROM eligible_lists e\nJOIN list_owners lo ON e.MOIRA_LIST_KEY = lo.MOIRA_LIST_KEY\nORDER BY e.member_count DESC, e.MOIRA_LIST_NAME, lo.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with C (case insensitive) and containing faculty who teach courses in the summer in financial aid years after 2001, provide the name of the list, the number of people in the list, and the number of faculty in the list.",
        "predicted_sql": "WITH faculty_ids AS (\n    SELECT DISTINCT c.RESPONSIBLE_FACULTY_MIT_ID AS faculty_mit_id\n    FROM COURSE_CATALOG_SUBJECT_OFFERED c\n    INNER JOIN ACADEMIC_TERMS a ON c.TERM_CODE = a.TERM_CODE\n    WHERE LOWER(a.TERM_DESCRIPTION) LIKE '%summer%'\n      AND CAST(a.FINANCIAL_AID_YEAR AS UNSIGNED) > 2001\n      AND c.RESPONSIBLE_FACULTY_MIT_ID IS NOT NULL\n)\nSELECT \n    l.MOIRA_LIST_NAME,\n    COUNT(DISTINCT d.MOIRA_LIST_MEMBER) AS total_people,\n    COUNT(DISTINCT CASE WHEN f.faculty_mit_id IS NOT NULL THEN d.MOIRA_LIST_MEMBER_MIT_ID END) AS faculty_count\nFROM MOIRA_LIST l\nINNER JOIN MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\nLEFT JOIN faculty_ids f ON d.MOIRA_LIST_MEMBER_MIT_ID = f.faculty_mit_id\nWHERE LOWER(l.MOIRA_LIST_NAME) LIKE 'c%'\nGROUP BY l.MOIRA_LIST_KEY, l.MOIRA_LIST_NAME\nHAVING faculty_count > 0;"
    },
    {
        "db_id": "dw",
        "question": "Regarding the mailing list about duo users, provide the number of students in this list, and the number of departments and schools associated with these students.",
        "predicted_sql": "SELECT \n    COUNT(DISTINCT msd.EMAIL_ADDRESS) AS student_count,\n    COUNT(DISTINCT sd.DEPARTMENT_CODE) AS department_count,\n    COUNT(DISTINCT sd.SCHOOL_CODE) AS school_count\nFROM MOIRA_LIST ml\nINNER JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nINNER JOIN MIT_STUDENT_DIRECTORY msd ON mld.MOIRA_LIST_MEMBER_FULL_NAME = msd.FULL_NAME\nINNER JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nWHERE ml.MOIRA_LIST_NAME = 'cat-duo-users';"
    },
    {
        "db_id": "dw",
        "question": "For faculty who are responsible for courses in 2023 fall term, list the name of mailing lists with ten members that they subscribe to, the number of faculty in these lists, and the number of courses associated with those faculty.",
        "predicted_sql": "WITH list_10 AS (\n  SELECT MOIRA_LIST_KEY\n  FROM MOIRA_LIST_DETAIL\n  GROUP BY MOIRA_LIST_KEY\n  HAVING COUNT(DISTINCT MOIRA_LIST_MEMBER) = 10\n)\nSELECT\n  ml.MOIRA_LIST_NAME AS mailing_list_name,\n  COUNT(DISTINCT e.MIT_ID) AS number_of_faculty,\n  COUNT(DISTINCT c.SUBJECT_ID) AS number_of_courses\nFROM list_10 l10\nJOIN MOIRA_LIST ml ON l10.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nJOIN MOIRA_LIST_DETAIL mld ON l10.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN EMPLOYEE_DIRECTORY e ON mld.MOIRA_LIST_MEMBER = e.KRB_NAME\nJOIN COURSE_CATALOG_SUBJECT_OFFERED c ON e.MIT_ID = c.RESPONSIBLE_FACULTY_MIT_ID AND c.TERM_CODE = '2023FA'\nWHERE ml.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME\nORDER BY ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each course instructor in the 'keeper-zephyr' mailing list, provide the name of mailing lists they subscribe to, instructor name, earliest and latest publication years, and total number of enrolled students.",
        "predicted_sql": "WITH base_instructors AS (\n    SELECT DISTINCT sp.MIT_ID, sp.FULL_NAME AS instructor_name\n    FROM MOIRA_LIST ml\n    JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n    JOIN SE_PERSON sp ON mld.MOIRA_LIST_MEMBER_MIT_ID = sp.MIT_ID\n    JOIN LIBRARY_COURSE_INSTRUCTOR lci ON sp.FULL_NAME = lci.INSTRUCTOR_NAME\n    WHERE ml.MOIRA_LIST_NAME = 'keeper-zephyr'\n      AND ml.IS_MOIRA_MAILING_LIST = 'Y'\n),\nmailing_lists AS (\n    SELECT DISTINCT mld.MOIRA_LIST_MEMBER_MIT_ID AS MIT_ID, ml.MOIRA_LIST_NAME\n    FROM MOIRA_LIST_DETAIL mld\n    JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\n    WHERE mld.MOIRA_LIST_MEMBER_MIT_ID IN (SELECT MIT_ID FROM base_instructors)\n      AND ml.IS_MOIRA_MAILING_LIST = 'Y'\n),\npub_years AS (\n    SELECT sp.MIT_ID,\n           MIN(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS earliest_year,\n           MAX(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS latest_year\n    FROM SE_PERSON sp\n    JOIN LIBRARY_COURSE_INSTRUCTOR lci ON sp.FULL_NAME = lci.INSTRUCTOR_NAME\n    JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\n    JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\n    WHERE sp.MIT_ID IN (SELECT MIT_ID FROM base_instructors)\n      AND lrc.CATALOG_YEAR REGEXP '^[0-9]+$'\n      AND lrc.CATALOG_YEAR != '0'\n    GROUP BY sp.MIT_ID\n),\nenrollment AS (\n    SELECT instructor_mit_id AS MIT_ID, SUM(NUM_ENROLLED_STUDENTS) AS total_students\n    FROM (\n        SELECT DISTINCT sp.MIT_ID AS instructor_mit_id, lso.LIBRARY_SUBJECT_OFFERED_KEY, lso.NUM_ENROLLED_STUDENTS\n        FROM SE_PERSON sp\n        JOIN LIBRARY_COURSE_INSTRUCTOR lci ON sp.FULL_NAME = lci.INSTRUCTOR_NAME\n        JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\n        JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\n        WHERE sp.MIT_ID IN (SELECT MIT_ID FROM base_instructors)\n    ) sub\n    GROUP BY MIT_ID\n)\nSELECT \n    ml.MOIRA_LIST_NAME AS mailing_list_name,\n    bi.instructor_name,\n    py.earliest_year,\n    py.latest_year,\n    e.total_students\nFROM base_instructors bi\nJOIN mailing_lists ml ON bi.MIT_ID = ml.MIT_ID\nLEFT JOIN pub_years py ON bi.MIT_ID = py.MIT_ID\nLEFT JOIN enrollment e ON bi.MIT_ID = e.MIT_ID\nORDER BY bi.instructor_name, ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list with a name beginning with R (case insensitive), and that Professor Ayden Hopkins is subscribed to, list its name, description, owner, number of people in the list, and number of tenured faculty in the list.",
        "predicted_sql": "SELECT\n    L.MOIRA_LIST_NAME AS name,\n    L.MOIRA_LIST_DESCRIPTION AS description,\n    MAX(O.OWNER) AS owner,\n    COUNT(DISTINCT D.MOIRA_LIST_MEMBER) AS total_people,\n    COUNT(DISTINCT CASE\n        WHEN LOWER(P.PAYROLL_RANK) LIKE '%professor%'\n        AND LOWER(P.PAYROLL_RANK) NOT LIKE '%assistant%'\n        THEN D.MOIRA_LIST_MEMBER\n    END) AS tenured_faculty_count\nFROM MOIRA_LIST L\nINNER JOIN MOIRA_LIST_DETAIL D ON L.MOIRA_LIST_KEY = D.MOIRA_LIST_KEY\nINNER JOIN MOIRA_LIST_OWNER O ON D.MOIRA_LIST_OWNER_KEY = O.MOIRA_LIST_OWNER_KEY\nLEFT JOIN SE_PERSON P ON D.MOIRA_LIST_MEMBER = P.KRB_NAME\nWHERE L.IS_MOIRA_MAILING_LIST = 'Y'\n  AND LOWER(L.MOIRA_LIST_NAME) LIKE 'r%'\n  AND EXISTS (\n      SELECT 1\n      FROM MOIRA_LIST_DETAIL D2\n      INNER JOIN SE_PERSON P2 ON D2.MOIRA_LIST_MEMBER = P2.KRB_NAME\n      WHERE P2.FULL_NAME = 'Hopkins, Ayden'\n        AND D2.MOIRA_LIST_KEY = L.MOIRA_LIST_KEY\n  )\nGROUP BY L.MOIRA_LIST_KEY, L.MOIRA_LIST_NAME, L.MOIRA_LIST_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "For the email list with name 'date-destiny', list the name of the list, department name, the number of students from the Management department, and the percentage of students who are from the Management department, rounded to two decimal places.",
        "predicted_sql": "WITH dept_counts AS (\n  SELECT l.MOIRA_LIST_NAME AS list_name,\n         dept.SIS_ADMIN_DEPARTMENT_NAME AS dept_name,\n         COUNT(DISTINCT p.MIT_ID) AS dept_count\n  FROM MOIRA_LIST l\n  INNER JOIN MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\n  INNER JOIN SE_PERSON p ON d.MOIRA_LIST_MEMBER = p.KRB_NAME\n  INNER JOIN MIT_STUDENT_DIRECTORY s ON p.FULL_NAME = s.FULL_NAME\n  LEFT JOIN SIS_ADMIN_DEPARTMENT dept ON s.DEPARTMENT = dept.SIS_ADMIN_DEPARTMENT_CODE\n  WHERE l.MOIRA_LIST_NAME = 'date-destiny'\n  GROUP BY l.MOIRA_LIST_NAME, dept.SIS_ADMIN_DEPARTMENT_NAME\n)\nSELECT list_name AS `name of the list`,\n       dept_name AS `department name`,\n       dept_count AS `number of students from the Management department`,\n       ROUND(dept_count * 100.0 / SUM(dept_count) OVER (PARTITION BY list_name), 2) AS `percentage`\nFROM dept_counts\nWHERE dept_name = 'Management';"
    },
    {
        "db_id": "dw",
        "question": "For the building with the most floors, list the building name and the names of the mailing lists staring with a (case insensitive) that the building employees with kerberos starting with c (case insensitive) subscribe to.",
        "predicted_sql": "WITH max_building AS (\n    SELECT BUILDING_KEY\n    FROM FAC_FLOOR\n    GROUP BY BUILDING_KEY\n    HAVING COUNT(DISTINCT LEVEL_ID) = (\n        SELECT MAX(cnt)\n        FROM (\n            SELECT COUNT(DISTINCT LEVEL_ID) AS cnt\n            FROM FAC_FLOOR\n            GROUP BY BUILDING_KEY\n        ) t\n    )\n)\nSELECT DISTINCT b.BUILDING_NAME, ml.MOIRA_LIST_NAME\nFROM max_building mb\nJOIN FAC_BUILDING b ON b.FAC_BUILDING_KEY = mb.BUILDING_KEY\nJOIN FAC_ROOMS r ON r.BUILDING_KEY = b.FAC_BUILDING_KEY\nJOIN EMPLOYEE_DIRECTORY e ON e.OFFICE_LOCATION = r.FAC_ROOM_KEY\nJOIN MOIRA_LIST_DETAIL mld ON mld.MOIRA_LIST_MEMBER = e.KRB_NAME\nJOIN MOIRA_LIST ml ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nWHERE LOWER(e.KRB_NAME) LIKE 'c%'\n  AND LOWER(ml.MOIRA_LIST_NAME) LIKE 'a%'\n  AND ml.IS_MOIRA_MAILING_LIST = 'Y';"
    },
    {
        "db_id": "dw",
        "question": "For the email lists subscribed by faculty members with last names begin with Y, list the names of the lists, the total number of subjects managed by faculty in those mailing lists, and the number of such faculty in the lists.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME AS list_name,\n    COUNT(DISTINCT c.SUBJECT_ID) AS total_subjects,\n    COUNT(DISTINCT e.MIT_ID) AS num_faculty\nFROM EMPLOYEE_DIRECTORY e\nJOIN MOIRA_LIST_DETAIL mld ON e.MIT_ID = mld.MOIRA_LIST_MEMBER_MIT_ID\nJOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nLEFT JOIN COURSE_CATALOG_SUBJECT_OFFERED c ON e.MIT_ID = c.RESPONSIBLE_FACULTY_MIT_ID\nWHERE e.LAST_NAME LIKE 'Y%'\n  AND ml.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME\nORDER BY ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with H who are subscribed to mailing list 'beacon-date-date', list the names of the students, the phone numbers of departments they belong to, and the size of the mailing list 'beacon-date-date' that they are subscribed to.",
        "predicted_sql": "SELECT DISTINCT\n    s.FULL_NAME AS student_name,\n    a.DEPARTMENT_PHONE_NUMBER AS department_phone,\n    (SELECT COUNT(DISTINCT d2.MOIRA_LIST_MEMBER)\n     FROM MOIRA_LIST_DETAIL d2\n     WHERE d2.MOIRA_LIST_KEY = l.MOIRA_LIST_KEY) AS mailing_list_size\nFROM MIT_STUDENT_DIRECTORY s\nJOIN SE_PERSON p ON s.FULL_NAME = p.FULL_NAME\nJOIN MOIRA_LIST_DETAIL d ON p.KRB_NAME = d.MOIRA_LIST_MEMBER\nJOIN MOIRA_LIST l ON d.MOIRA_LIST_KEY = l.MOIRA_LIST_KEY\nJOIN SIS_DEPARTMENT dept ON s.DEPARTMENT = dept.DEPARTMENT_CODE\nJOIN SIS_ADMIN_DEPARTMENT a ON dept.DEPARTMENT_CODE = a.SIS_ADMIN_DEPARTMENT_CODE\nWHERE s.LAST_NAME LIKE 'H%'\n  AND l.MOIRA_LIST_NAME = 'beacon-date-date';"
    },
    {
        "db_id": "dw",
        "question": "Give the count of mailing lists with names starting with B that include members from the Electrical Engineering and Computer Science department, along with the name of the list starting with B that have the highest number of members from that department and the corresponding member count.",
        "predicted_sql": "WITH list_member_counts AS (\n    SELECT ml.MOIRA_LIST_KEY,\n           ml.MOIRA_LIST_NAME,\n           COUNT(DISTINCT p.MIT_ID) AS member_count\n    FROM MOIRA_LIST ml\n    JOIN MOIRA_LIST_DETAIL d ON ml.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\n    JOIN SE_PERSON p ON d.MOIRA_LIST_MEMBER = p.KRB_NAME\n    WHERE ml.MOIRA_LIST_NAME LIKE 'B%'\n      AND ml.IS_MOIRA_MAILING_LIST = 'Y'\n      AND p.ORGANIZATION = 'Electrical Engineering and Computer Science'\n    GROUP BY ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME\n)\nSELECT\n    (SELECT COUNT(*) FROM list_member_counts) AS total_lists,\n    (SELECT MOIRA_LIST_NAME FROM list_member_counts ORDER BY member_count DESC, MOIRA_LIST_NAME LIMIT 1) AS top_list_name,\n    (SELECT member_count FROM list_member_counts ORDER BY member_count DESC, MOIRA_LIST_NAME LIMIT 1) AS top_member_count;"
    },
    {
        "db_id": "dw",
        "question": "For the 'kangaroo-inspire-yearn' email list, for each department present in the list, list the department name, the number of students in that department, and its percentage relative to the students in the mailing list.",
        "predicted_sql": "SELECT \n    d.SIS_ADMIN_DEPARTMENT_NAME AS department_name,\n    COUNT(DISTINCT p.MIT_ID) AS student_count,\n    ROUND(COUNT(DISTINCT p.MIT_ID) * 100.0 / total.total_students, 2) AS percentage\nFROM MOIRA_LIST l\nJOIN MOIRA_LIST_DETAIL ld ON l.MOIRA_LIST_KEY = ld.MOIRA_LIST_KEY\nJOIN SE_PERSON p ON ld.MOIRA_LIST_MEMBER = p.KRB_NAME\nJOIN MIT_STUDENT_DIRECTORY msd ON p.FULL_NAME = msd.FULL_NAME\nJOIN SIS_ADMIN_DEPARTMENT d ON msd.DEPARTMENT = d.SIS_ADMIN_DEPARTMENT_CODE\nCROSS JOIN (\n    SELECT COUNT(DISTINCT p_inner.MIT_ID) AS total_students\n    FROM MOIRA_LIST l_inner\n    JOIN MOIRA_LIST_DETAIL ld_inner ON l_inner.MOIRA_LIST_KEY = ld_inner.MOIRA_LIST_KEY\n    JOIN SE_PERSON p_inner ON ld_inner.MOIRA_LIST_MEMBER = p_inner.KRB_NAME\n    JOIN MIT_STUDENT_DIRECTORY msd_inner ON p_inner.FULL_NAME = msd_inner.FULL_NAME\n    WHERE l_inner.MOIRA_LIST_NAME = 'kangaroo-inspire-yearn'\n) total\nWHERE l.MOIRA_LIST_NAME = 'kangaroo-inspire-yearn'\nGROUP BY d.SIS_ADMIN_DEPARTMENT_NAME, total.total_students\nORDER BY student_count DESC, department_name;"
    },
    {
        "db_id": "dw",
        "question": "Among the mailing lists subscribed by people with physical offices in building 24, provide the name of the most subscribed mailing list and the total number of subscribers.",
        "predicted_sql": "SELECT ml.MOIRA_LIST_NAME AS mailing_list_name,\n       COUNT(DISTINCT ed.MIT_ID) AS total_subscribers\nFROM MOIRA_LIST_DETAIL mld\nJOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nJOIN EMPLOYEE_DIRECTORY ed ON mld.MOIRA_LIST_MEMBER = ed.KRB_NAME\nWHERE ml.IS_MOIRA_MAILING_LIST = 'Y'\n  AND SUBSTRING_INDEX(ed.OFFICE_LOCATION, '-', 1) = '24'\nGROUP BY ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME\nORDER BY total_subscribers DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For email lists subscribed by either support staff or faculty, list its name, the number of subscribers that are support staff, the number of subscribers that are faculty, as well as its active status.",
        "predicted_sql": "SELECT \n    l.MOIRA_LIST_NAME AS list_name,\n    COUNT(DISTINCT CASE WHEN p.EMPLOYEE_TYPE = 'Support Staff' THEN p.MIT_ID END) AS support_staff_count,\n    COUNT(DISTINCT CASE WHEN p.EMPLOYEE_TYPE = 'Faculty' THEN p.MIT_ID END) AS faculty_count,\n    l.IS_ACTIVE AS active_status\nFROM MOIRA_LIST l\nJOIN MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\nJOIN SE_PERSON p ON d.MOIRA_LIST_MEMBER_MIT_ID = p.MIT_ID\nWHERE p.EMPLOYEE_TYPE IN ('Support Staff', 'Faculty')\nGROUP BY l.MOIRA_LIST_KEY, l.MOIRA_LIST_NAME, l.IS_ACTIVE;"
    },
    {
        "db_id": "dw",
        "question": "For the 'ocean-apple' mailing list, identify the department with the highest student count. Provide the department name, phone number, and the total number of students subscribed to the mailing list from that department. If multiple departments have the same highest count, list each one separately.",
        "predicted_sql": "WITH department_counts AS (\n    SELECT\n        d.SIS_ADMIN_DEPARTMENT_NAME AS department_name,\n        d.DEPARTMENT_PHONE_NUMBER AS phone_number,\n        COUNT(DISTINCT p.MIT_ID) AS student_count\n    FROM\n        MOIRA_LIST l\n        JOIN MOIRA_LIST_DETAIL ld ON l.MOIRA_LIST_KEY = ld.MOIRA_LIST_KEY\n        JOIN SE_PERSON p ON ld.MOIRA_LIST_MEMBER = p.KRB_NAME\n        JOIN MIT_STUDENT_DIRECTORY s ON p.FULL_NAME = s.FULL_NAME\n        JOIN SIS_ADMIN_DEPARTMENT d ON s.DEPARTMENT = d.SIS_ADMIN_DEPARTMENT_CODE\n    WHERE\n        l.MOIRA_LIST_NAME = 'ocean-apple'\n        AND l.IS_MOIRA_MAILING_LIST = 'Y'\n    GROUP BY\n        d.SIS_ADMIN_DEPARTMENT_NAME,\n        d.DEPARTMENT_PHONE_NUMBER\n)\nSELECT\n    department_name,\n    phone_number,\n    student_count\nFROM\n    department_counts\nWHERE\n    student_count = (SELECT MAX(student_count) FROM department_counts);"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list, list its owner, owner type, the member visibility ('Public Members' if public, and 'Hidden Members' otherwise), and the number of members of this type of visibility. For each owner and owner type, include a grand total for all members in the format of (owner, owner type, null, total members).",
        "predicted_sql": "(SELECT \n    mo.OWNER AS owner,\n    mo.OWNER_TYPE AS owner_type,\n    CASE WHEN ml.IS_PUBLIC = 'Y' THEN 'Public Members' ELSE 'Hidden Members' END AS visibility,\n    COUNT(*) AS member_count\n FROM MOIRA_LIST ml\n INNER JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n INNER JOIN MOIRA_LIST_OWNER mo ON mld.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY\n WHERE ml.IS_MOIRA_MAILING_LIST = 'Y'\n GROUP BY ml.MOIRA_LIST_KEY, mo.OWNER, mo.OWNER_TYPE, ml.IS_PUBLIC)\nUNION ALL\n(SELECT \n    mo.OWNER AS owner,\n    mo.OWNER_TYPE AS owner_type,\n    NULL AS visibility,\n    COUNT(*) AS member_count\n FROM MOIRA_LIST ml\n INNER JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n INNER JOIN MOIRA_LIST_OWNER mo ON mld.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY\n WHERE ml.IS_MOIRA_MAILING_LIST = 'Y'\n GROUP BY mo.OWNER, mo.OWNER_TYPE)\nORDER BY owner, owner_type, visibility IS NULL, visibility;"
    },
    {
        "db_id": "dw",
        "question": "Group biology courses by cluster type and course level. For each group, list the name of the department, the course title, cluster type, total enrollments, average enrollment within its cluster, course level, number of unique course materials, average new and used prices for TIP materials, total material record count for TIP materials, number of unique library titles, and number of unique library ISBNs.",
        "predicted_sql": "WITH subject_agg AS (\n    SELECT \n        s.CLUSTER_TYPE,\n        scd.COURSE_LEVEL,\n        GROUP_CONCAT(DISTINCT s.OFFER_DEPT_NAME) AS department_names,\n        GROUP_CONCAT(DISTINCT s.SUBJECT_TITLE) AS course_titles,\n        SUM(s.NUM_ENROLLED_STUDENTS) AS total_enrollments,\n        AVG(s.CLUSTER_ENROLLMENT_NUMBER) AS avg_cluster_enrollment\n    FROM SUBJECT_OFFERED_SUMMARY s\n    JOIN SIS_COURSE_DESCRIPTION scd ON s.COURSE_NUMBER = scd.COURSE\n    WHERE LOWER(s.OFFER_DEPT_NAME) LIKE '%biology%'\n    GROUP BY s.CLUSTER_TYPE, scd.COURSE_LEVEL\n),\ntip_agg AS (\n    SELECT \n        s.CLUSTER_TYPE,\n        scd.COURSE_LEVEL,\n        COUNT(DISTINCT tm.TIP_MATERIAL_KEY) AS unique_materials,\n        AVG(tm.NEW_SHELF_PRICE) AS avg_new_price,\n        AVG(tm.USED_SHELF_PRICE) AS avg_used_price,\n        SUM(td.RECORD_COUNT) AS total_record_count\n    FROM TIP_DETAIL td\n    JOIN SUBJECT_OFFERED_SUMMARY s ON td.TIP_SUBJECT_OFFERED_KEY = s.SUBJECT_OFFERED_SUMMARY_KEY\n    JOIN SIS_COURSE_DESCRIPTION scd ON s.COURSE_NUMBER = scd.COURSE\n    LEFT JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\n    WHERE LOWER(s.OFFER_DEPT_NAME) LIKE '%biology%'\n    GROUP BY s.CLUSTER_TYPE, scd.COURSE_LEVEL\n),\nlibrary_agg AS (\n    SELECT \n        s.CLUSTER_TYPE,\n        scd.COURSE_LEVEL,\n        COUNT(DISTINCT lrc.CATALOG_TITLE) AS unique_library_titles,\n        COUNT(DISTINCT lrc.CATALOG_ISBN) AS unique_library_isbns\n    FROM TIP_DETAIL td\n    JOIN SUBJECT_OFFERED_SUMMARY s ON td.TIP_SUBJECT_OFFERED_KEY = s.SUBJECT_OFFERED_SUMMARY_KEY\n    JOIN SIS_COURSE_DESCRIPTION scd ON s.COURSE_NUMBER = scd.COURSE\n    LEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON td.ISBN = lrc.CATALOG_ISBN\n    WHERE LOWER(s.OFFER_DEPT_NAME) LIKE '%biology%'\n    GROUP BY s.CLUSTER_TYPE, scd.COURSE_LEVEL\n)\nSELECT \n    sa.CLUSTER_TYPE,\n    sa.COURSE_LEVEL,\n    sa.department_names,\n    sa.course_titles,\n    sa.total_enrollments,\n    sa.avg_cluster_enrollment,\n    COALESCE(ta.unique_materials, 0) AS unique_course_materials,\n    COALESCE(ta.avg_new_price, 0) AS avg_new_price,\n    COALESCE(ta.avg_used_price, 0) AS avg_used_price,\n    COALESCE(ta.total_record_count, 0) AS total_material_record_count,\n    COALESCE(la.unique_library_titles, 0) AS unique_library_titles,\n    COALESCE(la.unique_library_isbns, 0) AS unique_library_isbns\nFROM subject_agg sa\nLEFT JOIN tip_agg ta ON sa.CLUSTER_TYPE = ta.CLUSTER_TYPE AND sa.COURSE_LEVEL = ta.COURSE_LEVEL\nLEFT JOIN library_agg la ON sa.CLUSTER_TYPE = la.CLUSTER_TYPE AND sa.COURSE_LEVEL = la.COURSE_LEVEL\nORDER BY sa.CLUSTER_TYPE, sa.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered this year in either the Fall or Spring term, list its department name, school name, subject ID, subject title, course level, total units, the term it is offered ('Spring' for Spring term and 'Fall' for Fall term), term description, the number of distinct instructors teaching in the Fall, and the number of distinct instructors teaching in the Spring.",
        "predicted_sql": "SELECT\n    c.DEPARTMENT_NAME AS department_name,\n    d.SCHOOL_NAME AS school_name,\n    c.SUBJECT_ID AS subject_id,\n    c.SUBJECT_TITLE AS subject_title,\n    sc.COURSE_LEVEL AS course_level,\n    c.TOTAL_UNITS AS total_units,\n    CASE\n        WHEN c.TERM_CODE LIKE '%FA' THEN 'Fall'\n        WHEN c.TERM_CODE LIKE '%SP' THEN 'Spring'\n    END AS term_offered,\n    a.TERM_DESCRIPTION AS term_description,\n    CASE\n        WHEN c.FALL_INSTRUCTORS IS NULL OR c.FALL_INSTRUCTORS = '' THEN 0\n        ELSE (LENGTH(c.FALL_INSTRUCTORS) - LENGTH(REPLACE(c.FALL_INSTRUCTORS, ',', '')) + 1)\n    END AS fall_instructor_count,\n    CASE\n        WHEN c.SPRING_INSTRUCTORS IS NULL OR c.SPRING_INSTRUCTORS = '' THEN 0\n        ELSE (LENGTH(c.SPRING_INSTRUCTORS) - LENGTH(REPLACE(c.SPRING_INSTRUCTORS, ',', '')) + 1)\n    END AS spring_instructor_count\nFROM\n    COURSE_CATALOG_SUBJECT_OFFERED c\n    INNER JOIN ACADEMIC_TERMS a ON c.TERM_CODE = a.TERM_CODE\n    INNER JOIN SIS_DEPARTMENT d ON c.DEPARTMENT_CODE = d.DEPARTMENT_CODE\n    INNER JOIN SIS_COURSE_DESCRIPTION sc ON c.SUBJECT_CODE = sc.COURSE\nWHERE\n    c.IS_OFFERED_THIS_YEAR = 'Y'\n    AND (c.TERM_CODE LIKE '%FA' OR c.TERM_CODE LIKE '%SP')\n    AND c.IS_MASTER_SECTION = 'Y'\nORDER BY\n    c.DEPARTMENT_NAME, c.SUBJECT_ID, term_offered;"
    },
    {
        "db_id": "dw",
        "question": "For Political Science courses with HASS attributes, for each attribute, list the name and description of the attribute, the number of unique subjects, average units, the total enrollment, the number of departments that grant degrees, and the subject code description.",
        "predicted_sql": "SELECT\n    c.HASS_ATTRIBUTE AS attribute_name,\n    c.HASS_ATTRIBUTE_DESC AS attribute_description,\n    COUNT(DISTINCT c.SUBJECT_ID) AS unique_subjects,\n    AVG(CAST(c.TOTAL_UNITS AS DECIMAL(5,2))) AS average_units,\n    COALESCE(SUM(s.NUM_ENROLLED_STUDENTS), 0) AS total_enrollment,\n    COUNT(DISTINCT CASE WHEN d.IS_DEGREE_GRANTING = 'Y' THEN d.DEPARTMENT_CODE END) AS degree_granting_depts,\n    MAX(sc.SUBJECT_CODE_DESC) AS subject_code_description\nFROM\n    CIS_COURSE_CATALOG c\nJOIN\n    SIS_SUBJECT_CODE sc ON c.SUBJECT_CODE = sc.SUBJECT_CODE\nJOIN\n    SIS_DEPARTMENT d ON sc.DEPARTMENT_CODE = d.DEPARTMENT_CODE\nLEFT JOIN\n    SUBJECT_OFFERED_SUMMARY s ON c.SUBJECT_ID = s.SUBJECT_ID\nWHERE\n    d.DEPARTMENT_NAME = 'Political Science'\n    AND c.HASS_ATTRIBUTE IS NOT NULL\nGROUP BY\n    c.HASS_ATTRIBUTE,\n    c.HASS_ATTRIBUTE_DESC;"
    },
    {
        "db_id": "dw",
        "question": "Group subjects by cluster type, department offering the subject, and the school name. For each group, list the cluster type, name of the department, school name, whether the department grants degrees, total number of subjects, total enrollment, and average enrollment. Exclude clusters or schools with no student data.",
        "predicted_sql": "SELECT \n    s.CLUSTER_TYPE,\n    s.OFFER_DEPT_NAME AS department_name,\n    d.SCHOOL_NAME AS school_name,\n    d.IS_DEGREE_GRANTING,\n    COUNT(DISTINCT s.SUBJECT_ID) AS total_subjects,\n    SUM(COALESCE(s.NUM_ENROLLED_STUDENTS, 0)) AS total_enrollment,\n    AVG(COALESCE(s.NUM_ENROLLED_STUDENTS, 0)) AS average_enrollment\nFROM SUBJECT_OFFERED_SUMMARY s\nINNER JOIN SIS_DEPARTMENT d ON s.OFFER_DEPT_CODE = d.DEPARTMENT_CODE\nGROUP BY s.CLUSTER_TYPE, s.OFFER_DEPT_NAME, d.SCHOOL_NAME, d.IS_DEGREE_GRANTING\nHAVING total_enrollment > 0;"
    },
    {
        "db_id": "dw",
        "question": "Group classes that take place in buildings at MIT by the building name and course level. For each group, provide the name of the building, the course level ('Graduate' or 'Undergraduate'), the total number of unique courses of such level, and total instructors for these courses. Include subtotals for each building and course level and a grand total across all buildings and course levels.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME AS building_name,\n    CASE \n        WHEN c.COURSE_LEVEL = 'G' THEN 'Graduate'\n        WHEN c.COURSE_LEVEL = 'U' THEN 'Undergraduate'\n        ELSE 'Other'\n    END AS course_level,\n    COUNT(DISTINCT s.SUBJECT_ID) AS total_unique_courses,\n    COUNT(DISTINCT s.RESPONSIBLE_FACULTY_NAME) AS total_instructors\nFROM FAC_BUILDING b\nJOIN SUBJECT_OFFERED s ON b.FAC_BUILDING_KEY = s.MEET_PLACE\nJOIN SIS_COURSE_DESCRIPTION c ON s.COURSE_NUMBER = c.COURSE\nWHERE b.SITE = 'MIT'\nGROUP BY b.BUILDING_NAME, c.COURSE_LEVEL\nUNION ALL\nSELECT \n    'All Buildings' AS building_name,\n    'All Levels' AS course_level,\n    COUNT(DISTINCT s.SUBJECT_ID) AS total_unique_courses,\n    COUNT(DISTINCT s.RESPONSIBLE_FACULTY_NAME) AS total_instructors\nFROM FAC_BUILDING b\nJOIN SUBJECT_OFFERED s ON b.FAC_BUILDING_KEY = s.MEET_PLACE\nJOIN SIS_COURSE_DESCRIPTION c ON s.COURSE_NUMBER = c.COURSE\nWHERE b.SITE = 'MIT'\nORDER BY \n    (building_name = 'All Buildings'),\n    building_name,\n    course_level;"
    },
    {
        "db_id": "dw",
        "question": "For each course, provide the room number of course location, building name, building number, building city, building state, area, organization name, room usage, term code, course level, the total number of subjects, unique meeting times, and total units. Do not include meet place or meet times with NULL values.",
        "predicted_sql": "SELECT\n    C.MEET_PLACE AS room_number,\n    B.BUILDING_NAME,\n    B.BUILDING_NUMBER,\n    A.CITY AS building_city,\n    A.STATE AS building_state,\n    R.AREA,\n    R.ORGANIZATION_NAME,\n    U.MAJOR_USE AS room_usage,\n    C.TERM_CODE,\n    S.COURSE_LEVEL,\n    agg.total_subjects,\n    agg.unique_meeting_times,\n    agg.total_units\nFROM COURSE_CATALOG_SUBJECT_OFFERED C\nINNER JOIN FAC_ROOMS R ON C.MEET_PLACE = R.FAC_ROOM_KEY\nINNER JOIN FAC_BUILDING B ON R.BUILDING_KEY = B.FAC_BUILDING_KEY\nINNER JOIN FAC_MAJOR_USE U ON R.MAJOR_USE_KEY = U.MAJOR_USE_KEY\nINNER JOIN FAC_BUILDING_ADDRESS A ON B.FAC_BUILDING_KEY = A.BUILDING_KEY\nINNER JOIN SIS_COURSE_DESCRIPTION S ON C.SUBJECT_CODE = S.COURSE\nINNER JOIN (\n    SELECT\n        S.COURSE AS course_key,\n        C.TERM_CODE AS term_code,\n        COUNT(DISTINCT C.SUBJECT_ID) AS total_subjects,\n        COUNT(DISTINCT C.MEET_TIME) AS unique_meeting_times,\n        SUM(C.TOTAL_UNITS) AS total_units\n    FROM COURSE_CATALOG_SUBJECT_OFFERED C\n    INNER JOIN SIS_COURSE_DESCRIPTION S ON C.SUBJECT_CODE = S.COURSE\n    WHERE C.MEET_PLACE IS NOT NULL\n      AND C.MEET_TIME IS NOT NULL\n    GROUP BY S.COURSE, C.TERM_CODE\n) agg ON S.COURSE = agg.course_key AND C.TERM_CODE = agg.term_code\nWHERE C.MEET_PLACE IS NOT NULL\n  AND C.MEET_TIME IS NOT NULL\n  AND A.ADDRESS_PURPOSE = 'STREET';"
    },
    {
        "db_id": "dw",
        "question": "Consider only books cataloged on or after 2000. For each library material status and department, list the material status, department name, number of associated catalog items, and the total number of enrolled students in courses using those materials. Include subtotals for each material status and a grand total across all status (the corresponding status field is 'Grand Total').",
        "predicted_sql": "WITH base AS (\n    SELECT\n        sts.LIBRARY_MATERIAL_STATUS AS material_status,\n        sis.DEPARTMENT_NAME AS department_name,\n        cat.LIBRARY_RESERVE_CATALOG_KEY AS catalog_key,\n        subj.LIBRARY_SUBJECT_OFFERED_KEY AS subject_key,\n        subj.NUM_ENROLLED_STUDENTS AS enrolled_students\n    FROM LIBRARY_RESERVE_CATALOG cat\n    JOIN LIBRARY_RESERVE_MATRL_DETAIL det ON cat.LIBRARY_RESERVE_CATALOG_KEY = det.LIBRARY_RESERVE_CATALOG_KEY\n    JOIN LIBRARY_MATERIAL_STATUS sts ON det.LIBRARY_MATERIAL_STATUS_KEY = sts.LIBRARY_MATERIAL_STATUS_KEY\n    JOIN LIBRARY_SUBJECT_OFFERED subj ON det.LIBRARY_SUBJECT_OFFERED_KEY = subj.LIBRARY_SUBJECT_OFFERED_KEY\n    JOIN SIS_SUBJECT_CODE sis ON subj.COURSE_NUMBER = sis.COURSE_NUMBER\n    WHERE CAST(cat.CATALOG_YEAR AS UNSIGNED) >= 2000\n),\ncatalog_agg AS (\n    SELECT material_status, department_name, COUNT(DISTINCT catalog_key) AS catalog_items\n    FROM base\n    GROUP BY material_status, department_name\n),\nstudents_agg AS (\n    SELECT material_status, department_name, SUM(enrolled_students) AS total_students\n    FROM (\n        SELECT DISTINCT material_status, department_name, subject_key, enrolled_students\n        FROM base\n    ) AS distinct_subjects\n    GROUP BY material_status, department_name\n),\nsummary AS (\n    SELECT \n        ca.material_status,\n        ca.department_name,\n        ca.catalog_items,\n        sa.total_students\n    FROM catalog_agg ca\n    INNER JOIN students_agg sa ON ca.material_status = sa.material_status AND ca.department_name = sa.department_name\n)\nSELECT\n    CASE WHEN GROUPING(material_status)=1 AND GROUPING(department_name)=1 THEN 'Grand Total' ELSE material_status END AS material_status,\n    department_name,\n    SUM(catalog_items) AS number_of_catalog_items,\n    SUM(total_students) AS total_enrolled_students\nFROM summary\nGROUP BY material_status, department_name WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each department in the library system, list the name of the department, total number of courses using library materials, the number of catalog items associated with those courses, and the average enrollment per course. Include a grand total across all departments (the corresponding department field should be 'Grand Total').",
        "predicted_sql": "WITH\n  dept_course_offerings AS (\n    SELECT\n      lci.DEPARTMENT,\n      lso.LIBRARY_SUBJECT_OFFERED_KEY,\n      MAX(lso.NUM_ENROLLED_STUDENTS) AS enrollment\n    FROM\n      LIBRARY_COURSE_INSTRUCTOR lci\n      JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\n      JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\n    GROUP BY\n      lci.DEPARTMENT,\n      lso.LIBRARY_SUBJECT_OFFERED_KEY\n  ),\n  dept_courses_agg AS (\n    SELECT\n      DEPARTMENT,\n      COUNT(*) AS total_courses,\n      SUM(enrollment) AS total_enrollment\n    FROM\n      dept_course_offerings\n    GROUP BY\n      DEPARTMENT\n  ),\n  dept_catalog_items AS (\n    SELECT\n      lci.DEPARTMENT,\n      COUNT(DISTINCT lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS total_catalog_items\n    FROM\n      LIBRARY_COURSE_INSTRUCTOR lci\n      JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\n    GROUP BY\n      lci.DEPARTMENT\n  ),\n  dept_results AS (\n    SELECT\n      dca.DEPARTMENT,\n      dca.total_courses,\n      dci.total_catalog_items,\n      dca.total_enrollment\n    FROM\n      dept_courses_agg dca\n      JOIN dept_catalog_items dci ON dca.DEPARTMENT = dci.DEPARTMENT\n  )\nSELECT\n  DEPARTMENT,\n  total_courses,\n  total_catalog_items,\n  total_enrollment / total_courses AS avg_enrollment\nFROM\n  dept_results\nUNION ALL\nSELECT\n  'Grand Total',\n  SUM(total_courses),\n  SUM(total_catalog_items),\n  SUM(total_enrollment) / SUM(total_courses)\nFROM\n  dept_results\nORDER BY\n  CASE WHEN DEPARTMENT = 'Grand Total' THEN 1 ELSE 0 END,\n  DEPARTMENT;"
    },
    {
        "db_id": "dw",
        "question": "For each department and school offering courses with materials, list the department name, school name, number of unique course materials, number of courses, average new and used shelf prices of materials, total material records, and number of distinct material statuses. Include a grand total across all schools and departments (the corresponding school and department fields should be null).",
        "predicted_sql": "WITH base AS (\n    SELECT \n        tso.OFFER_DEPT_NAME AS dept_name,\n        sd.SCHOOL_NAME AS school_name,\n        tm.TIP_MATERIAL_KEY AS material_key,\n        tm.NEW_SHELF_PRICE,\n        tm.USED_SHELF_PRICE,\n        td.RECORD_COUNT,\n        tms.TIP_MATERIAL_STATUS AS material_status,\n        tso.SUBJECT_ID\n    FROM TIP_SUBJECT_OFFERED tso\n    JOIN TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\n    JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\n    JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\n    JOIN SIS_DEPARTMENT sd ON sd.DEPARTMENT_CODE = tso.OFFER_DEPT_CODE\n    WHERE tso.IS_NO_COURSE_MATERIAL = 'N'\n),\ndetailed AS (\n    SELECT \n        dept_name,\n        school_name,\n        COUNT(DISTINCT material_key) AS num_unique_materials,\n        COUNT(DISTINCT SUBJECT_ID) AS num_courses,\n        AVG(CASE WHEN rn = 1 THEN NEW_SHELF_PRICE END) AS avg_new_price,\n        AVG(CASE WHEN rn = 1 THEN USED_SHELF_PRICE END) AS avg_used_price,\n        SUM(RECORD_COUNT) AS total_material_records,\n        COUNT(DISTINCT material_status) AS num_distinct_statuses\n    FROM (\n        SELECT *,\n            ROW_NUMBER() OVER (PARTITION BY dept_name, school_name, material_key ORDER BY (SELECT 0)) AS rn\n        FROM base\n    ) ranked\n    GROUP BY dept_name, school_name\n),\ngrand_total AS (\n    SELECT \n        NULL AS dept_name,\n        NULL AS school_name,\n        COUNT(DISTINCT material_key) AS num_unique_materials,\n        COUNT(DISTINCT SUBJECT_ID) AS num_courses,\n        AVG(CASE WHEN rn = 1 THEN NEW_SHELF_PRICE END) AS avg_new_price,\n        AVG(CASE WHEN rn = 1 THEN USED_SHELF_PRICE END) AS avg_used_price,\n        SUM(RECORD_COUNT) AS total_material_records,\n        COUNT(DISTINCT material_status) AS num_distinct_statuses\n    FROM (\n        SELECT *,\n            ROW_NUMBER() OVER (PARTITION BY material_key ORDER BY (SELECT 0)) AS rn\n        FROM base\n    ) ranked_global\n)\nSELECT * FROM detailed\nUNION ALL\nSELECT * FROM grand_total\nORDER BY school_name IS NULL, school_name, dept_name IS NULL, dept_name;"
    },
    {
        "db_id": "dw",
        "question": "For each TIP material status, list the total number of unique materials associated with the status, the total number of records associated with the status, and the total student enrollment associated with the status. Any material status with null values should be displayed as 'No material status'. Additionally, include a grand total across all material status (the material status for this row should be displayed as 'Grand Total').",
        "predicted_sql": "SELECT\n    CASE\n        WHEN GROUPING(s.TIP_MATERIAL_STATUS) = 1 THEN 'Grand Total'\n        WHEN s.TIP_MATERIAL_STATUS IS NULL THEN 'No material status'\n        ELSE s.TIP_MATERIAL_STATUS\n    END AS `Material Status`,\n    COUNT(DISTINCT d.TIP_MATERIAL_KEY) AS `Total Unique Materials`,\n    SUM(d.RECORD_COUNT) AS `Total Records`,\n    SUM(o.NUM_ENROLLED_STUDENTS) AS `Total Student Enrollment`\nFROM TIP_DETAIL d\nLEFT JOIN TIP_MATERIAL_STATUS s ON d.TIP_MATERIAL_STATUS_KEY = s.TIP_MATERIAL_STATUS_KEY\nINNER JOIN TIP_MATERIAL m ON d.TIP_MATERIAL_KEY = m.TIP_MATERIAL_KEY\nINNER JOIN TIP_SUBJECT_OFFERED o ON d.TIP_SUBJECT_OFFERED_KEY = o.TIP_SUBJECT_OFFERED_KEY\nGROUP BY s.TIP_MATERIAL_STATUS WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each room, list its associated building name, floor number, room number, ownership type, organization name, number of rooms, area, and percentage of area relative to the building. Include subtotals across floors, subtotals across all floors for each building, and a grand total across all buildings. For the subtotal for each building and the grand total, the percentage of area should be relative to area of all buildings. All numeric values should be rounded to integers and formatted using commas as thousands separators except the relative percentages which should be rounded to two decimal places.",
        "predicted_sql": "WITH base AS (\n    SELECT \n        b.FCLT_BUILDING_KEY AS building_key,\n        b.BUILDING_NAME_LONG AS building_name,\n        b.OWNERSHIP_TYPE,\n        f.FLOOR AS floor_number,\n        r.FCLT_ROOM_KEY AS room_key,\n        r.BUILDING_ROOM AS room_number,\n        o.ORGANIZATION_NAME AS org_name,\n        r.AREA\n    FROM FCLT_ROOMS r\n    JOIN FCLT_FLOOR f ON r.FCLT_FLOOR_KEY = f.FCLT_FLOOR_KEY\n    JOIN FCLT_BUILDING b ON f.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\n    JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY\n),\nbuilding_totals AS (\n    SELECT\n        building_key,\n        SUM(AREA) AS building_total_area,\n        COUNT(room_key) AS building_room_count\n    FROM base\n    GROUP BY building_key\n),\noverall_totals AS (\n    SELECT\n        SUM(AREA) AS overall_total_area,\n        COUNT(room_key) AS overall_room_count\n    FROM base\n),\nroom_details AS (\n    SELECT\n        building_name,\n        floor_number,\n        room_number,\n        OWNERSHIP_TYPE,\n        org_name AS organization_name,\n        1 AS num_rooms,\n        ROUND(AREA) AS area,\n        ROUND((AREA / bt.building_total_area) * 100, 2) AS percentage,\n        1 AS level,\n        building_key,\n        floor_number AS floor_sort,\n        room_number AS room_sort\n    FROM base\n    JOIN building_totals bt USING (building_key)\n),\nfloor_totals AS (\n    SELECT\n        MAX(building_name) AS building_name,\n        floor_number,\n        NULL AS room_number,\n        MAX(OWNERSHIP_TYPE) AS OWNERSHIP_TYPE,\n        NULL AS organization_name,\n        COUNT(room_key) AS num_rooms,\n        ROUND(SUM(AREA)) AS area,\n        ROUND((SUM(AREA) / MAX(bt.building_total_area)) * 100, 2) AS percentage,\n        2 AS level,\n        building_key,\n        floor_number AS floor_sort,\n        NULL AS room_sort\n    FROM base\n    JOIN building_totals bt USING (building_key)\n    GROUP BY building_key, floor_number\n),\nbuilding_totals_rows AS (\n    SELECT\n        MAX(building_name) AS building_name,\n        NULL AS floor_number,\n        NULL AS room_number,\n        MAX(OWNERSHIP_TYPE) AS OWNERSHIP_TYPE,\n        NULL AS organization_name,\n        COUNT(room_key) AS num_rooms,\n        ROUND(SUM(AREA)) AS area,\n        ROUND((SUM(AREA) / (SELECT overall_total_area FROM overall_totals)) * 100, 2) AS percentage,\n        3 AS level,\n        building_key,\n        NULL AS floor_sort,\n        NULL AS room_sort\n    FROM base\n    GROUP BY building_key\n),\ngrand_total AS (\n    SELECT\n        NULL AS building_name,\n        NULL AS floor_number,\n        NULL AS room_number,\n        NULL AS OWNERSHIP_TYPE,\n        NULL AS organization_name,\n        overall_room_count AS num_rooms,\n        ROUND(overall_total_area) AS area,\n        100.00 AS percentage,\n        4 AS level,\n        NULL AS building_key,\n        NULL AS floor_sort,\n        NULL AS room_sort\n    FROM overall_totals\n),\ncombined AS (\n    SELECT * FROM room_details\n    UNION ALL\n    SELECT * FROM floor_totals\n    UNION ALL\n    SELECT * FROM building_totals_rows\n    UNION ALL\n    SELECT * FROM grand_total\n)\nSELECT\n    building_name,\n    floor_number,\n    room_number,\n    OWNERSHIP_TYPE,\n    organization_name,\n    num_rooms,\n    area,\n    percentage\nFROM combined\nORDER BY\n    CASE WHEN building_key IS NULL THEN 1 ELSE 0 END,\n    building_key,\n    CASE WHEN floor_sort IS NULL THEN 1 ELSE 0 END,\n    floor_sort,\n    level,\n    room_sort;"
    },
    {
        "db_id": "dw",
        "question": "For each financial aid year and academic year, list the number of fiscal periods, quarters, the start term date, the end term date, and number of distinct department-level term parameters.",
        "predicted_sql": "SELECT \n    a.FINANCIAL_AID_YEAR,\n    a.ACADEMIC_YEAR,\n    COUNT(DISTINCT m.FISCAL_PERIOD) AS number_of_fiscal_periods,\n    COUNT(DISTINCT q.FY_QUARTER_CODE) AS number_of_quarters,\n    MIN(d.START_DATE) AS start_term_date,\n    MAX(d.END_DATE) AS end_term_date,\n    COUNT(DISTINCT p.TERM_PARAMETER) AS number_of_distinct_department_level_term_parameters\nFROM ACADEMIC_TERMS a\nJOIN TIME_DAY d ON a.TERM_START_DATE = d.CALENDAR_DATE\nJOIN TIME_MONTH m ON d.FISCAL_PERIOD = m.FISCAL_PERIOD\nJOIN TIME_QUARTER q ON m.FISCAL_YEAR = q.FISCAL_YEAR\nLEFT JOIN ACADEMIC_TERM_PARAMETER p ON a.TERM_CODE = p.TERM_CODE\nGROUP BY a.FINANCIAL_AID_YEAR, a.ACADEMIC_YEAR\nORDER BY a.FINANCIAL_AID_YEAR, a.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "Group buildings by campus sectors. For each group, list the campus sector, name of the building, city and state where the building is located, total number of floors, total assignable area, total number of rooms, total number of organizations, ownership type, and a rank column indicating the order (1-indexed) of this row within each sector based on the descending order of assignable area. Include subtotals for each sector and a grand total across all sectors. The subtotal and grand total only need to computed over the total number of floors and assignable area.",
        "predicted_sql": "WITH \nbuilding_floors AS (\n    SELECT FCLT_BUILDING_KEY, COUNT(DISTINCT FLOOR) AS total_floors\n    FROM FCLT_FLOOR\n    GROUP BY FCLT_BUILDING_KEY\n),\nbuilding_rooms AS (\n    SELECT FCLT_BUILDING_KEY, COUNT(*) AS total_rooms\n    FROM FCLT_ROOMS\n    GROUP BY FCLT_BUILDING_KEY\n),\nbuilding_orgs AS (\n    SELECT r.FCLT_BUILDING_KEY, COUNT(DISTINCT r.FCLT_ORGANIZATION_KEY) AS total_organizations\n    FROM FCLT_ROOMS r\n    WHERE r.FCLT_ORGANIZATION_KEY IS NOT NULL\n    GROUP BY r.FCLT_BUILDING_KEY\n),\nbuilding_address AS (\n    SELECT \n        FCLT_BUILDING_KEY,\n        CITY,\n        STATE,\n        ROW_NUMBER() OVER (PARTITION BY FCLT_BUILDING_KEY ORDER BY \n            CASE WHEN ADDRESS_PURPOSE = 'STREET' THEN 1 \n                 WHEN ADDRESS_PURPOSE = 'E911_1' THEN 2 \n                 ELSE 3 END) AS rn\n    FROM FCLT_BUILDING_ADDRESS\n    WHERE CITY IS NOT NULL AND STATE IS NOT NULL\n),\nbuilding_data AS (\n    SELECT \n        b.CAMPUS_SECTOR,\n        b.BUILDING_NAME_LONG,\n        addr.CITY,\n        addr.STATE,\n        COALESCE(bf.total_floors, 0) AS total_floors,\n        b.ASSIGNABLE_AREA,\n        COALESCE(br.total_rooms, 0) AS total_rooms,\n        COALESCE(bo.total_organizations, 0) AS total_organizations,\n        b.OWNERSHIP_TYPE,\n        RANK() OVER (PARTITION BY b.CAMPUS_SECTOR ORDER BY b.ASSIGNABLE_AREA DESC) AS rnk\n    FROM FCLT_BUILDING b\n    LEFT JOIN building_floors bf ON b.FCLT_BUILDING_KEY = bf.FCLT_BUILDING_KEY\n    LEFT JOIN building_rooms br ON b.FCLT_BUILDING_KEY = br.FCLT_BUILDING_KEY\n    LEFT JOIN building_orgs bo ON b.FCLT_BUILDING_KEY = bo.FCLT_BUILDING_KEY\n    LEFT JOIN building_address addr ON b.FCLT_BUILDING_KEY = addr.FCLT_BUILDING_KEY AND addr.rn = 1\n)\nSELECT \n    CAMPUS_SECTOR,\n    BUILDING_NAME_LONG,\n    CITY,\n    STATE,\n    total_floors,\n    ASSIGNABLE_AREA,\n    total_rooms,\n    total_organizations,\n    OWNERSHIP_TYPE,\n    rnk\nFROM building_data\nUNION ALL\nSELECT \n    CAMPUS_SECTOR,\n    'Sector Total' AS BUILDING_NAME_LONG,\n    NULL AS CITY,\n    NULL AS STATE,\n    SUM(total_floors),\n    SUM(ASSIGNABLE_AREA),\n    NULL,\n    NULL,\n    NULL,\n    NULL\nFROM building_data\nGROUP BY CAMPUS_SECTOR\nUNION ALL\nSELECT \n    NULL,\n    'Grand Total',\n    NULL,\n    NULL,\n    SUM(total_floors),\n    SUM(ASSIGNABLE_AREA),\n    NULL,\n    NULL,\n    NULL,\n    NULL\nFROM building_data\nORDER BY \n    (CAMPUS_SECTOR IS NULL),                     -- non-null sectors first\n    CAMPUS_SECTOR,                               -- then by sector name\n    CASE \n        WHEN BUILDING_NAME_LONG = 'Sector Total' THEN 2 \n        WHEN BUILDING_NAME_LONG = 'Grand Total' THEN 3 \n        ELSE 1                                   -- building rows\n    END,\n    rnk;                                         -- within building rows, by rank"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the name of the department, the title of the TIP material associated with the department, author, ISBN, library term code, and whether it is available in the library reserves ('Available in Library' if yes and 'Not Available in Library' otherwise), the total number of instructors per library book for the department, the total number of materials available in the library for the department, and the total number of available materials across all departments.",
        "predicted_sql": "WITH tip_base AS (\n    SELECT DISTINCT\n        tso.OFFER_DEPT_NAME AS dept_name,\n        tm.TITLE,\n        tm.AUTHOR,\n        tm.ISBN\n    FROM TIP_SUBJECT_OFFERED tso\n    JOIN TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\n    JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\n),\nlibrary_details AS (\n    SELECT\n        lso.OFFER_DEPT_NAME AS lib_dept,\n        lrc.CATALOG_ISBN AS lib_isbn,\n        lrm.TERM_CODE AS term_code,\n        lrm.LIBRARY_COURSE_INSTRUCTOR_KEY AS instructor_key\n    FROM LIBRARY_RESERVE_CATALOG lrc\n    JOIN LIBRARY_RESERVE_MATRL_DETAIL lrm ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrm.LIBRARY_RESERVE_CATALOG_KEY\n    JOIN LIBRARY_SUBJECT_OFFERED lso ON lrm.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\n    WHERE lrc.CATALOG_ISBN IS NOT NULL\n),\nlib_agg AS (\n    SELECT\n        lib_dept AS dept_name,\n        lib_isbn AS isbn,\n        MAX(term_code) AS lib_term_code,\n        COUNT(DISTINCT instructor_key) AS num_instructors\n    FROM library_details\n    GROUP BY lib_dept, lib_isbn\n),\ndept_total AS (\n    SELECT\n        lib_dept AS dept_name,\n        COUNT(DISTINCT lib_isbn) AS dept_available_materials\n    FROM library_details\n    GROUP BY lib_dept\n),\noverall_total AS (\n    SELECT COUNT(DISTINCT lib_isbn) AS overall_available_materials\n    FROM library_details\n)\nSELECT\n    tb.dept_name,\n    tb.TITLE,\n    tb.AUTHOR,\n    tb.ISBN,\n    la.lib_term_code AS library_term_code,\n    CASE WHEN la.isbn IS NOT NULL THEN 'Available in Library' ELSE 'Not Available in Library' END AS availability,\n    COALESCE(la.num_instructors, 0) AS instructors_per_book,\n    COALESCE(dt.dept_available_materials, 0) AS dept_total_materials,\n    ot.overall_available_materials\nFROM tip_base tb\nLEFT JOIN lib_agg la ON tb.dept_name = la.dept_name AND tb.ISBN = la.isbn\nLEFT JOIN dept_total dt ON tb.dept_name = dt.dept_name\nCROSS JOIN overall_total ot\nORDER BY tb.dept_name, tb.TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For each department and material status, list the name of the department, the material status, the number of TIP materials associated with this department and status, the number of library materials associated with this department and status, the total number of TIP and library materials associated with this department and status. Include a subtotal for each department and a grand total across all departments.",
        "predicted_sql": "WITH combined AS (\n    SELECT \n        tso.OFFER_DEPT_NAME AS dept,\n        tms.TIP_MATERIAL_STATUS AS status,\n        1 AS tip_cnt,\n        0 AS lib_cnt\n    FROM TIP_DETAIL td\n    INNER JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\n    INNER JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\n    UNION ALL\n    SELECT\n        lso.OFFER_DEPT_NAME AS dept,\n        lms.LIBRARY_MATERIAL_STATUS AS status,\n        0 AS tip_cnt,\n        1 AS lib_cnt\n    FROM LIBRARY_RESERVE_MATRL_DETAIL lrd\n    INNER JOIN LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\n    INNER JOIN LIBRARY_MATERIAL_STATUS lms ON lrd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\n)\nSELECT\n    dept AS department_name,\n    status AS material_status,\n    SUM(tip_cnt) AS number_of_TIP_materials,\n    SUM(lib_cnt) AS number_of_library_materials,\n    SUM(tip_cnt + lib_cnt) AS total_materials\nFROM combined\nGROUP BY dept, status WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each building that is not a subdivision, list the building number, full name, street address, building type, occupancy date, ownership type, and site location. You should also include three rows at the end showing the number of owned, leased, all buildings at MIT that are not subdivisions, in the format of (null, #building Buildings, null, null, null, null, null).",
        "predicted_sql": "SELECT building_number, full_name, street_address, building_type, occupancy_date, ownership_type, site_location\nFROM (\n    (SELECT 1 AS sort_order, 0 AS sub_sort,\n            fb.BUILDING_NUMBER AS building_number,\n            fb.BUILDING_NAME_LONG AS full_name,\n            b.BUILDING_STREET_ADDRESS AS street_address,\n            fb.BUILDING_TYPE AS building_type,\n            fb.DATE_OCCUPIED AS occupancy_date,\n            fb.OWNERSHIP_TYPE AS ownership_type,\n            fb.SITE AS site_location,\n            CAST(fb.BUILDING_NUMBER AS UNSIGNED) AS bldg_num_sort\n     FROM FAC_BUILDING fb\n     INNER JOIN BUILDINGS b ON fb.FAC_BUILDING_KEY = b.BUILDING_KEY\n     WHERE fb.PARENT_BUILDING_NUMBER IS NULL\n       AND fb.SITE = 'MIT')\n    UNION ALL\n    (SELECT 2, 1,\n            NULL,\n            CONCAT((SELECT COUNT(*) FROM FAC_BUILDING WHERE PARENT_BUILDING_NUMBER IS NULL AND SITE = 'MIT' AND OWNERSHIP_TYPE = 'OWNED'), ' Owned Buildings'),\n            NULL, NULL, NULL, NULL, NULL, NULL)\n    UNION ALL\n    (SELECT 2, 2,\n            NULL,\n            CONCAT((SELECT COUNT(*) FROM FAC_BUILDING WHERE PARENT_BUILDING_NUMBER IS NULL AND SITE = 'MIT' AND OWNERSHIP_TYPE = 'LEASED'), ' Leased Buildings'),\n            NULL, NULL, NULL, NULL, NULL, NULL)\n    UNION ALL\n    (SELECT 2, 3,\n            NULL,\n            CONCAT((SELECT COUNT(*) FROM FAC_BUILDING WHERE PARENT_BUILDING_NUMBER IS NULL AND SITE = 'MIT'), ' All Buildings'),\n            NULL, NULL, NULL, NULL, NULL, NULL)\n) AS combined\nORDER BY sort_order, sub_sort, bldg_num_sort, building_number;"
    },
    {
        "db_id": "dw",
        "question": "For each owned building that is not a subdivision, list the construction start year, the building number, and the year of initial occupancy. Display the construction start year only if it differs from the previous row. If the year of initial occupancy or construction start year is unknown, display 'UNKNOWN'. You should also include a row at the end showing the total number of owned buildings that are not subdivisions, in the format of (null, #building Buildings, null).",
        "predicted_sql": "WITH base AS (\n    SELECT \n        BUILDING_NUMBER AS bldg_num,\n        DATE_BUILT,\n        DATE_OCCUPIED\n    FROM FAC_BUILDING\n    WHERE OWNERSHIP_TYPE = 'OWNED'\n      AND (PARENT_BUILDING_NUMBER IS NULL OR PARENT_BUILDING_NUMBER = '')\n),\nprep AS (\n    SELECT\n        bldg_num,\n        CASE \n            WHEN DATE_BUILT IS NULL OR DATE_BUILT = '' THEN 'UNKNOWN'\n            ELSE SUBSTRING_INDEX(DATE_BUILT, '/', -1)\n        END AS constr_year,\n        CASE \n            WHEN DATE_OCCUPIED IS NULL OR DATE_OCCUPIED = '' THEN 'UNKNOWN'\n            ELSE SUBSTRING_INDEX(DATE_OCCUPIED, '/', -1)\n        END AS occup_year,\n        CASE \n            WHEN DATE_BUILT IS NULL OR DATE_BUILT = '' THEN 9999\n            ELSE CAST(SUBSTRING_INDEX(DATE_BUILT, '/', -1) AS UNSIGNED)\n        END AS constr_year_num,\n        CAST(bldg_num AS UNSIGNED) AS bldg_num_num\n    FROM base\n),\nordered AS (\n    SELECT\n        bldg_num,\n        constr_year,\n        occup_year,\n        constr_year_num,\n        bldg_num_num,\n        LAG(constr_year) OVER (ORDER BY constr_year_num, bldg_num_num) AS prev_constr_year\n    FROM prep\n),\nbuilding_rows AS (\n    SELECT\n        CASE WHEN prev_constr_year IS NULL OR constr_year != prev_constr_year THEN constr_year ELSE NULL END AS construction_start_year,\n        bldg_num AS building_number,\n        occup_year AS year_of_initial_occupancy,\n        constr_year_num,\n        bldg_num_num,\n        0 AS seq\n    FROM ordered\n),\nsummary AS (\n    SELECT\n        NULL AS construction_start_year,\n        CONCAT(cnt, ' Buildings') AS building_number,\n        NULL AS year_of_initial_occupancy,\n        NULL AS constr_year_num,\n        NULL AS bldg_num_num,\n        1 AS seq\n    FROM (SELECT COUNT(*) AS cnt FROM base) t\n)\nSELECT construction_start_year, building_number, year_of_initial_occupancy\nFROM (\n    SELECT * FROM building_rows\n    UNION ALL\n    SELECT * FROM summary\n) combined\nORDER BY seq, constr_year_num, bldg_num_num;"
    },
    {
        "db_id": "dw",
        "question": "Group all buildings at MIT into either owned or leased. For each group, state the ownership type, usage type, number of buildings, gross square footage, number of rooms, and the number of associated organizations. Display the ownership type only if it differs from the previous row. Include subtotals for each group and a grand total across all groups. The subtotal and grand total rows should not include ownership type and usage type. Footage should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH latest_buildings AS (\n    SELECT b.FCLT_BUILDING_KEY, b.OWNERSHIP_TYPE, b.BUILDING_USE, b.EXT_GROSS_AREA\n    FROM FCLT_BUILDING_HIST b\n    WHERE b.SITE = 'MIT'\n      AND (b.FCLT_BUILDING_KEY, b.FISCAL_PERIOD) IN (\n          SELECT FCLT_BUILDING_KEY, MAX(FISCAL_PERIOD)\n          FROM FCLT_BUILDING_HIST\n          WHERE SITE = 'MIT'\n          GROUP BY FCLT_BUILDING_KEY\n      )\n),\nbuilding_rooms AS (\n    SELECT b.FCLT_BUILDING_KEY,\n           COUNT(DISTINCT r.FCLT_ROOM_KEY) AS room_cnt,\n           COUNT(DISTINCT r.FCLT_ORGANIZATION_KEY) AS org_cnt_per_bldg\n    FROM latest_buildings b\n    LEFT JOIN FCLT_ROOMS r ON b.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY\n    GROUP BY b.FCLT_BUILDING_KEY\n),\nbuilding_data AS (\n    SELECT b.FCLT_BUILDING_KEY,\n           b.OWNERSHIP_TYPE,\n           b.BUILDING_USE,\n           b.EXT_GROSS_AREA,\n           COALESCE(br.room_cnt, 0) AS room_cnt,\n           COALESCE(br.org_cnt_per_bldg, 0) AS org_cnt_per_bldg\n    FROM latest_buildings b\n    LEFT JOIN building_rooms br ON b.FCLT_BUILDING_KEY = br.FCLT_BUILDING_KEY\n),\nbuilding_org_map AS (\n    SELECT DISTINCT r.FCLT_BUILDING_KEY, r.FCLT_ORGANIZATION_KEY\n    FROM FCLT_ROOMS r\n    WHERE r.FCLT_ORGANIZATION_KEY IS NOT NULL\n)\nSELECT\n    CASE\n        WHEN base.grp_owner = 1 OR base.grp_use = 1 THEN ''\n        WHEN LAG(base.ownership_type) OVER (ORDER BY base.grp_owner, base.ownership_type, base.grp_use, base.usage_type) = base.ownership_type THEN ''\n        ELSE base.ownership_type\n    END AS `Ownership Type`,\n    CASE WHEN base.grp_owner = 1 OR base.grp_use = 1 THEN '' ELSE base.usage_type END AS `Usage Type`,\n    base.num_buildings AS `Number of Buildings`,\n    base.gross_sq_ft AS `Gross Square Footage`,\n    base.num_rooms AS `Number of Rooms`,\n    base.num_organizations AS `Number of Organizations`\nFROM (\n    SELECT\n        bd.OWNERSHIP_TYPE AS ownership_type,\n        bd.BUILDING_USE AS usage_type,\n        COUNT(DISTINCT bd.FCLT_BUILDING_KEY) AS num_buildings,\n        FORMAT(ROUND(SUM(\n            CASE\n                WHEN bom.FCLT_ORGANIZATION_KEY IS NOT NULL THEN bd.EXT_GROSS_AREA / bd.org_cnt_per_bldg\n                ELSE bd.EXT_GROSS_AREA\n            END\n        )), 0) AS gross_sq_ft,\n        ROUND(SUM(\n            CASE\n                WHEN bom.FCLT_ORGANIZATION_KEY IS NOT NULL THEN bd.room_cnt / bd.org_cnt_per_bldg\n                ELSE bd.room_cnt\n            END\n        )) AS num_rooms,\n        COUNT(DISTINCT bom.FCLT_ORGANIZATION_KEY) AS num_organizations,\n        GROUPING(bd.OWNERSHIP_TYPE) AS grp_owner,\n        GROUPING(bd.BUILDING_USE) AS grp_use\n    FROM building_data bd\n    LEFT JOIN building_org_map bom ON bd.FCLT_BUILDING_KEY = bom.FCLT_BUILDING_KEY\n    GROUP BY bd.OWNERSHIP_TYPE, bd.BUILDING_USE WITH ROLLUP\n) base\nORDER BY base.grp_owner, base.ownership_type, base.grp_use, base.usage_type;"
    },
    {
        "db_id": "dw",
        "question": "For each building use, list the type, the number of distinct buildings (excluding subdivisions) of this use, the total gross square footage of these buildings, and the number of unique organizations associated with the rooms in these buildings. If the building is used as a residence, display the usage type as \"RESIDENTIAL.\" You should also include a row at the end showing the total number of buildings, the gross square footage, and the number of organizations across all types of building use. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH \nbuilding_parent AS (\n    SELECT \n        FCLT_BUILDING_KEY,\n        COALESCE(PARENT_BUILDING_NUMBER, BUILDING_NUMBER) AS parent_id,\n        BUILDING_TYPE,\n        EXT_GROSS_AREA\n    FROM FCLT_BUILDING\n),\nparent_attributes AS (\n    SELECT \n        parent_id,\n        MIN(BUILDING_TYPE) AS building_type,\n        SUM(EXT_GROSS_AREA) AS total_gross_area\n    FROM building_parent\n    GROUP BY parent_id\n),\nparent_org_pairs AS (\n    SELECT DISTINCT\n        bp.parent_id,\n        o.FCLT_ORGANIZATION_KEY\n    FROM building_parent bp\n    INNER JOIN FCLT_ROOMS r ON bp.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY\n    INNER JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY\n),\ntype_building_agg AS (\n    SELECT \n        CASE WHEN pa.building_type = 'RESIDENT' THEN 'RESIDENTIAL' ELSE pa.building_type END AS type,\n        COUNT(*) AS num_buildings,\n        SUM(pa.total_gross_area) AS total_gross_area\n    FROM parent_attributes pa\n    GROUP BY CASE WHEN pa.building_type = 'RESIDENT' THEN 'RESIDENTIAL' ELSE pa.building_type END\n),\ntype_org_agg AS (\n    SELECT \n        CASE WHEN pa.building_type = 'RESIDENT' THEN 'RESIDENTIAL' ELSE pa.building_type END AS type,\n        COUNT(DISTINCT pop.FCLT_ORGANIZATION_KEY) AS num_organizations\n    FROM parent_org_pairs pop\n    INNER JOIN parent_attributes pa ON pop.parent_id = pa.parent_id\n    GROUP BY CASE WHEN pa.building_type = 'RESIDENT' THEN 'RESIDENTIAL' ELSE pa.building_type END\n),\ntotals AS (\n    SELECT \n        'TOTAL' AS type,\n        (SELECT COUNT(*) FROM parent_attributes) AS num_buildings,\n        (SELECT SUM(total_gross_area) FROM parent_attributes) AS total_gross_area,\n        (SELECT COUNT(DISTINCT FCLT_ORGANIZATION_KEY) FROM parent_org_pairs) AS num_organizations\n)\nSELECT \n    type,\n    FORMAT(num_buildings, 0) AS `Number of Buildings`,\n    FORMAT(total_gross_area, 0) AS `Total Gross Square Footage`,\n    FORMAT(num_organizations, 0) AS `Number of Organizations`\nFROM (\n    SELECT tba.type, tba.num_buildings, tba.total_gross_area, COALESCE(toa.num_organizations, 0) AS num_organizations\n    FROM type_building_agg tba\n    LEFT JOIN type_org_agg toa ON tba.type = toa.type\n    UNION ALL\n    SELECT type, num_buildings, total_gross_area, num_organizations FROM totals\n) AS combined\nORDER BY CASE WHEN type = 'TOTAL' THEN 1 ELSE 0 END, type;"
    },
    {
        "db_id": "dw",
        "question": "For each organization except Cambridge-MIT Institute, list its ID, number, level, formatted name according to level (if level is 2, there should be 1 space before the name, if level is 3, there should be 2 space before the name, up to level 6), whether it is assignable ('ASSIGNABLE' if assignable, 'NON-ASSIGNABLE' otherwise), total area, number of rooms, and average room area. Area and number of rooms should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    o.ORGANIZATION_ID AS ID,\n    o.ORGANIZATION_NUMBER AS `number`,\n    o.ORGANIZATION_LEVEL AS `level`,\n    CONCAT(REPEAT(' ', CAST(o.ORGANIZATION_LEVEL AS UNSIGNED) - 1), o.ORGANIZATION_NAME) AS formatted_name,\n    CASE WHEN o.ASSIGNABLE = '1' THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END AS assignable,\n    FORMAT(COALESCE(ROUND(SUM(r.AREA)), 0), 0) AS total_area,\n    FORMAT(COUNT(r.FCLT_ROOM_KEY), 0) AS number_of_rooms,\n    ROUND(AVG(r.AREA), 2) AS average_room_area\nFROM FCLT_ORGANIZATION o\nLEFT JOIN FCLT_ROOMS r ON o.FCLT_ORGANIZATION_KEY = r.FCLT_ORGANIZATION_KEY\nWHERE o.ORGANIZATION_NAME != 'Cambridge-MIT Institute'\nGROUP BY o.FCLT_ORGANIZATION_KEY\nORDER BY o.ORGANIZATION_ID;"
    },
    {
        "db_id": "dw",
        "question": "Group all rooms into whether or not they are assignable and the major use descriptions. For each group, state \"ASSIGNABLE\" if the room is assignable and \"NON-ASSIGNABLE\" otherwise, the major use description, the total number of rooms, total area, and average area. Include subtotals for each group and a grand total across all groups. The assignable status and major use descriptions should only be displayed when they differ from the previous row. Do not include rooms whose major use or major use description starts with 'ZUSE.' The results should be sorted by assignable status and major use description. The subtotal and grand total rows should not include assignable status or major use description.",
        "predicted_sql": "WITH Aggregated AS (\n    SELECT\n        CASE WHEN MU.ASSIGNABLE = '1' THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END AS assignable_status,\n        MU.DESCRIPTION AS major_use_desc,\n        COUNT(*) AS total_rooms,\n        SUM(R.AREA) AS total_area,\n        AVG(R.AREA) AS avg_area,\n        GROUPING(MU.ASSIGNABLE) AS grp_assignable,\n        GROUPING(MU.DESCRIPTION) AS grp_desc\n    FROM FCLT_ROOMS R\n    JOIN FCLT_MAJOR_USE MU ON R.FCLT_MAJOR_USE_KEY = MU.FCLT_MAJOR_USE_KEY\n    WHERE NOT (MU.MAJOR_USE LIKE 'ZUSE.%' OR MU.DESCRIPTION LIKE 'ZUSE.%')\n    GROUP BY MU.ASSIGNABLE, MU.DESCRIPTION WITH ROLLUP\n)\nSELECT\n    CASE\n        WHEN grp_desc = 1 OR grp_assignable = 1 THEN NULL\n        ELSE \n            CASE \n                WHEN assignable_status = LAG(assignable_status) OVER (\n                        ORDER BY grp_assignable, assignable_status, grp_desc, major_use_desc\n                    ) THEN NULL\n                ELSE assignable_status\n            END\n    END AS `ASSIGNABLE_STATUS`,\n    CASE WHEN grp_desc = 1 OR grp_assignable = 1 THEN NULL ELSE major_use_desc END AS `MAJOR_USE_DESC`,\n    total_rooms AS `TOTAL_ROOMS`,\n    total_area AS `TOTAL_AREA`,\n    avg_area AS `AVG_AREA`\nFROM Aggregated\nORDER BY grp_assignable, assignable_status, grp_desc, major_use_desc;"
    },
    {
        "db_id": "dw",
        "question": "List each floor key and department name within the Stata building, as well as the number of rooms, total area, and average area per department on each floor. Include subtotals for each floor and a grand total across all floors. Sort the results by floor key and department name in ascending order. Exclude departments without any rooms in the building. Only the first row of each floor group should include the floor key, and the subtotal and grand total rows should not include floor key or department name. Number of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH aggregated AS (\n    SELECT\n        f.FLOOR_KEY,\n        o.ORGANIZATION_NAME AS department_name,\n        COUNT(*) AS num_rooms,\n        SUM(CAST(f.AREA AS DECIMAL(10,2))) AS total_area,\n        GROUPING(f.FLOOR_KEY) AS grp_floor,\n        GROUPING(o.ORGANIZATION_NAME) AS grp_dept\n    FROM FAC_ROOMS f\n    INNER JOIN BUILDINGS b ON f.BUILDING_KEY = b.BUILDING_KEY\n    INNER JOIN FCLT_ORGANIZATION o ON f.ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY\n    WHERE b.BUILDING_NAME LIKE '%Stata%'\n    GROUP BY f.FLOOR_KEY, o.ORGANIZATION_NAME WITH ROLLUP\n)\nSELECT\n    CASE\n        WHEN grp_dept = 1 OR grp_floor = 1 THEN ''\n        ELSE \n            CASE \n                WHEN ROW_NUMBER() OVER (PARTITION BY FLOOR_KEY ORDER BY department_name) = 1 \n                THEN FLOOR_KEY \n                ELSE '' \n            END\n    END AS floor_key,\n    CASE WHEN grp_dept = 1 OR grp_floor = 1 THEN '' ELSE department_name END AS department_name,\n    FORMAT(num_rooms, 0) AS number_of_rooms,\n    FORMAT(ROUND(total_area), 0) AS total_area,\n    ROUND(total_area / num_rooms, 2) AS average_area\nFROM aggregated\nORDER BY\n    grp_floor ASC,\n    FLOOR_KEY ASC,\n    grp_dept ASC,\n    department_name ASC;"
    },
    {
        "db_id": "dw",
        "question": "List each building key and floor key within the department of facilities, the number of rooms, total area, average area per floor, building name, access level, zip code, and city. Include subtotals for each building and a grand total across all buildings. The subtotals and grand total should not include zip code or city. Numbers of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT\n    CASE\n        WHEN GROUPING(b.BUILDING_KEY) = 1 THEN NULL\n        ELSE b.BUILDING_KEY\n    END AS building_key,\n    CASE\n        WHEN GROUPING(r.FLOOR_KEY) = 1 AND GROUPING(b.BUILDING_KEY) = 0 THEN 'Total'\n        WHEN GROUPING(r.FLOOR_KEY) = 1 AND GROUPING(b.BUILDING_KEY) = 1 THEN 'Grand Total'\n        ELSE r.FLOOR_KEY\n    END AS floor_key,\n    FORMAT(COUNT(r.FAC_ROOM_KEY), 0) AS number_of_rooms,\n    FORMAT(ROUND(SUM(CAST(r.AREA AS DECIMAL(10,2))), 0), 0) AS total_area,\n    FORMAT(ROUND(AVG(CAST(r.AREA AS DECIMAL(10,2))), 0), 0) AS average_area_per_floor,\n    CASE WHEN GROUPING(b.BUILDING_KEY) = 0 THEN b.BUILDING_NAME_LONG ELSE NULL END AS building_name,\n    CASE WHEN GROUPING(b.BUILDING_KEY) = 0 THEN b.ACCESS_LEVEL_NAME ELSE NULL END AS access_level,\n    CASE WHEN GROUPING(r.FLOOR_KEY) = 0 THEN a.POSTAL_CODE ELSE NULL END AS zip_code,\n    CASE WHEN GROUPING(r.FLOOR_KEY) = 0 THEN a.CITY ELSE NULL END AS city\nFROM FAC_ROOMS r\nJOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\nJOIN FAC_BUILDING b ON r.BUILDING_KEY = b.BUILDING_KEY\nLEFT JOIN (\n    SELECT BUILDING_KEY, POSTAL_CODE, CITY\n    FROM FAC_BUILDING_ADDRESS\n    WHERE ADDRESS_PURPOSE = 'STREET'\n    GROUP BY BUILDING_KEY\n) a ON b.BUILDING_KEY = a.BUILDING_KEY\nWHERE o.ORGANIZATION_NAME LIKE '%Facilities%'\nGROUP BY b.BUILDING_KEY, r.FLOOR_KEY WITH ROLLUP\nORDER BY GROUPING(b.BUILDING_KEY), b.BUILDING_KEY, GROUPING(r.FLOOR_KEY), r.FLOOR_KEY;"
    },
    {
        "db_id": "dw",
        "question": "List the department, school, course number, subject title, total number of enrolled students, term code, and count of distinct catalog ISBNs. Add a summary row at the bottom showing the total number of students and distinct catalog ISBNs for the current term in the format of ('TOTAL:', null, null, null, total number of students, null, number of distinct catalog ISBNs).",
        "predicted_sql": "WITH current_term AS (\n    SELECT TERM_CODE\n    FROM ACADEMIC_TERM_PARAMETER\n    WHERE IS_CURRENT_TERM = 'Y'\n),\ncurrent_subjects AS (\n    SELECT \n        s.LIBRARY_SUBJECT_OFFERED_KEY,\n        s.OFFER_DEPT_NAME,\n        s.OFFER_SCHOOL_NAME,\n        s.COURSE_NUMBER,\n        s.SUBJECT_TITLE,\n        s.NUM_ENROLLED_STUDENTS,\n        s.TERM_CODE\n    FROM LIBRARY_SUBJECT_OFFERED s\n    INNER JOIN current_term ct ON s.TERM_CODE = ct.TERM_CODE\n),\nsubject_reserves AS (\n    SELECT \n        cs.LIBRARY_SUBJECT_OFFERED_KEY,\n        COUNT(DISTINCT rc.CATALOG_ISBN) AS distinct_isbn_count\n    FROM current_subjects cs\n    LEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL m ON cs.LIBRARY_SUBJECT_OFFERED_KEY = m.LIBRARY_SUBJECT_OFFERED_KEY\n    LEFT JOIN LIBRARY_RESERVE_CATALOG rc ON m.LIBRARY_RESERVE_CATALOG_KEY = rc.LIBRARY_RESERVE_CATALOG_KEY\n    GROUP BY cs.LIBRARY_SUBJECT_OFFERED_KEY\n),\nsubject_details AS (\n    SELECT \n        cs.OFFER_DEPT_NAME AS department,\n        cs.OFFER_SCHOOL_NAME AS school,\n        cs.COURSE_NUMBER AS course_number,\n        cs.SUBJECT_TITLE AS subject_title,\n        cs.NUM_ENROLLED_STUDENTS AS enrolled_students,\n        cs.TERM_CODE AS term_code,\n        COALESCE(sr.distinct_isbn_count, 0) AS distinct_isbn_count\n    FROM current_subjects cs\n    LEFT JOIN subject_reserves sr ON cs.LIBRARY_SUBJECT_OFFERED_KEY = sr.LIBRARY_SUBJECT_OFFERED_KEY\n),\ntotal_students AS (\n    SELECT SUM(NUM_ENROLLED_STUDENTS) AS total_students\n    FROM current_subjects\n),\ntotal_isbns AS (\n    SELECT COUNT(DISTINCT rc.CATALOG_ISBN) AS total_isbn_count\n    FROM LIBRARY_RESERVE_CATALOG rc\n    INNER JOIN LIBRARY_RESERVE_MATRL_DETAIL m ON rc.LIBRARY_RESERVE_CATALOG_KEY = m.LIBRARY_RESERVE_CATALOG_KEY\n    INNER JOIN current_subjects cs ON m.LIBRARY_SUBJECT_OFFERED_KEY = cs.LIBRARY_SUBJECT_OFFERED_KEY\n)\nSELECT department, school, course_number, subject_title, enrolled_students, term_code, distinct_isbn_count\nFROM subject_details\nUNION ALL\nSELECT 'TOTAL:', NULL, NULL, NULL, total_students, NULL, total_isbn_count\nFROM total_students, total_isbns\nORDER BY \n    CASE WHEN department = 'TOTAL:' THEN 1 ELSE 0 END,\n    department, school, course_number;"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list that involves subscribers that work in departments with names starting with 'Computer Science', state the ownership type, the list name, the number of owners, and the number of subscribers. Display the ownership type only if it differs from the previous entry. Include subtotals (the corresponding type field shoud be 'SUBTOTAL') for each ownership type and a grand total (the corresponding type field shoud be 'TOTAL') across all ownership types.",
        "predicted_sql": "WITH base AS (\n    SELECT \n        o.OWNER_TYPE AS ownership_type,\n        l.MOIRA_LIST_NAME AS list_name,\n        COUNT(DISTINCT o.OWNER) AS num_owners,\n        COUNT(DISTINCT d.MOIRA_LIST_MEMBER_MIT_ID) AS num_subscribers\n    FROM MOIRA_LIST l\n    INNER JOIN MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\n    INNER JOIN MOIRA_LIST_OWNER o ON d.MOIRA_LIST_OWNER_KEY = o.MOIRA_LIST_OWNER_KEY\n    INNER JOIN EMPLOYEE_DIRECTORY e ON d.MOIRA_LIST_MEMBER_MIT_ID = e.MIT_ID\n    WHERE l.IS_MOIRA_MAILING_LIST = 'Y'\n        AND e.DEPARTMENT_NAME LIKE 'Computer Science%'\n    GROUP BY o.OWNER_TYPE, l.MOIRA_LIST_NAME\n),\nroll AS (\n    SELECT \n        ownership_type,\n        list_name,\n        SUM(num_owners) AS num_owners,\n        SUM(num_subscribers) AS num_subscribers,\n        GROUPING(ownership_type) AS g_type,\n        GROUPING(list_name) AS g_list\n    FROM base\n    GROUP BY ownership_type, list_name WITH ROLLUP\n)\nSELECT \n    CASE \n        WHEN g_list = 1 AND g_type = 0 THEN 'SUBTOTAL'\n        WHEN g_list = 1 AND g_type = 1 THEN 'TOTAL'\n        ELSE \n            CASE \n                WHEN ownership_type = LAG(ownership_type) OVER (ORDER BY g_type, ownership_type, g_list, list_name) THEN NULL\n                ELSE ownership_type\n            END\n    END AS ownership_type,\n    list_name,\n    num_owners,\n    num_subscribers\nFROM roll\nORDER BY g_type, ownership_type, g_list, list_name;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list its name, number of unique sessions, total number of attendees, active period (in the format of 'beginning term code-end term code'), the most common sponsor name, and the most common session start time. Include a grand total row showing the total number of sessions and attendees across all categories in the format of ('TOTAL', number of sessions, number of attendees, null, null, null).",
        "predicted_sql": "WITH \ncategory_agg AS (\n    SELECT \n        c.IAP_SUBJECT_CATEGORY_KEY,\n        c.IAP_CATEGORY_NAME,\n        COUNT(DISTINCT d.IAP_SUBJECT_SESSION_KEY) AS unique_sessions,\n        COALESCE(SUM(d.MAX_ENROLLMENT), 0) AS total_attendees,\n        MIN(d.TERM_CODE) AS min_term,\n        MAX(d.TERM_CODE) AS max_term\n    FROM IAP_SUBJECT_CATEGORY c\n    LEFT JOIN IAP_SUBJECT_DETAIL d ON c.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY\n    GROUP BY c.IAP_SUBJECT_CATEGORY_KEY, c.IAP_CATEGORY_NAME\n),\nsponsor_counts AS (\n    SELECT \n        c.IAP_SUBJECT_CATEGORY_KEY,\n        s.SPONSOR_NAME,\n        COUNT(*) AS cnt\n    FROM IAP_SUBJECT_CATEGORY c\n    LEFT JOIN IAP_SUBJECT_DETAIL d ON c.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY\n    LEFT JOIN IAP_SUBJECT_SPONSOR s ON d.IAP_SUBJECT_SPONSOR_KEY = s.IAP_SUBJECT_SPONSOR_KEY\n    WHERE s.SPONSOR_NAME IS NOT NULL\n    GROUP BY c.IAP_SUBJECT_CATEGORY_KEY, s.SPONSOR_NAME\n),\nranked_sponsor AS (\n    SELECT \n        IAP_SUBJECT_CATEGORY_KEY,\n        SPONSOR_NAME,\n        ROW_NUMBER() OVER (PARTITION BY IAP_SUBJECT_CATEGORY_KEY ORDER BY cnt DESC, SPONSOR_NAME ASC) AS rn\n    FROM sponsor_counts\n),\nsponsor_mode AS (\n    SELECT IAP_SUBJECT_CATEGORY_KEY, SPONSOR_NAME AS mode_sponsor\n    FROM ranked_sponsor\n    WHERE rn = 1\n),\nstart_time_counts AS (\n    SELECT \n        c.IAP_SUBJECT_CATEGORY_KEY,\n        sess.SESSION_START_TIME,\n        COUNT(*) AS cnt\n    FROM IAP_SUBJECT_CATEGORY c\n    LEFT JOIN IAP_SUBJECT_DETAIL d ON c.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY\n    LEFT JOIN IAP_SUBJECT_SESSION sess ON d.IAP_SUBJECT_SESSION_KEY = sess.IAP_SUBJECT_SESSION_KEY\n    WHERE sess.SESSION_START_TIME IS NOT NULL\n    GROUP BY c.IAP_SUBJECT_CATEGORY_KEY, sess.SESSION_START_TIME\n),\nranked_start_time AS (\n    SELECT \n        IAP_SUBJECT_CATEGORY_KEY,\n        SESSION_START_TIME,\n        ROW_NUMBER() OVER (PARTITION BY IAP_SUBJECT_CATEGORY_KEY ORDER BY cnt DESC, SESSION_START_TIME ASC) AS rn\n    FROM start_time_counts\n),\ntime_mode AS (\n    SELECT IAP_SUBJECT_CATEGORY_KEY, SESSION_START_TIME AS mode_start_time\n    FROM ranked_start_time\n    WHERE rn = 1\n)\nSELECT \n    IAP_CATEGORY_NAME AS \"Category Name\",\n    unique_sessions AS \"Number of Unique Sessions\",\n    total_attendees AS \"Total Attendees\",\n    (min_term || '-' || max_term) AS \"Active Period\",\n    mode_sponsor AS \"Most Common Sponsor\",\n    mode_start_time AS \"Most Common Start Time\"\nFROM category_agg agg\nLEFT JOIN sponsor_mode sp ON agg.IAP_SUBJECT_CATEGORY_KEY = sp.IAP_SUBJECT_CATEGORY_KEY\nLEFT JOIN time_mode tm ON agg.IAP_SUBJECT_CATEGORY_KEY = tm.IAP_SUBJECT_CATEGORY_KEY\n\nUNION ALL\n\nSELECT \n    'TOTAL',\n    SUM(unique_sessions),\n    SUM(total_attendees),\n    NULL,\n    NULL,\n    NULL\nFROM category_agg\n\nORDER BY \n    CASE WHEN \"Category Name\" = 'TOTAL' THEN 1 ELSE 0 END,\n    \"Category Name\";"
    },
    {
        "db_id": "dw",
        "question": "For each building type, list the name of the building type, the number of buildings that are not subdivisions, number of employees, number of unique building street address, number of unique city, number of unique state, number of unique postal code, and average gross square footage per employee. For building type of 'resident', display it as 'RESIDENTIAL'. Include a grand total across all building types (the corresponding type field is 'TOTAL').",
        "predicted_sql": "WITH building_latest AS (\n    SELECT \n        FCLT_BUILDING_KEY AS building_key,\n        BUILDING_TYPE,\n        PARENT_BUILDING_NUMBER,\n        EXT_GROSS_AREA,\n        ROW_NUMBER() OVER (PARTITION BY FCLT_BUILDING_KEY ORDER BY FISCAL_PERIOD DESC) AS rn\n    FROM FCLT_BUILDING_HIST\n),\nbuilding_current AS (\n    SELECT building_key, BUILDING_TYPE, PARENT_BUILDING_NUMBER, EXT_GROSS_AREA\n    FROM building_latest\n    WHERE rn = 1\n),\nemployee_per_building AS (\n    SELECT r.BUILDING_KEY, COUNT(DISTINCT e.MIT_ID) AS emp_count\n    FROM EMPLOYEE_DIRECTORY e\n    INNER JOIN FAC_ROOMS r ON e.OFFICE_LOCATION = r.FAC_ROOM_KEY\n    GROUP BY r.BUILDING_KEY\n),\naddress_ranked AS (\n    SELECT \n        BUILDING_KEY,\n        CITY,\n        STATE,\n        POSTAL_CODE,\n        ROW_NUMBER() OVER (PARTITION BY BUILDING_KEY ORDER BY CITY, STATE, POSTAL_CODE) AS rn\n    FROM FAC_BUILDING_ADDRESS\n    WHERE ADDRESS_PURPOSE = 'STREET'\n),\naddress_selected AS (\n    SELECT BUILDING_KEY, CITY, STATE, POSTAL_CODE\n    FROM address_ranked\n    WHERE rn = 1\n),\nbuilding_details AS (\n    SELECT \n        bc.building_key,\n        CASE WHEN LOWER(bc.BUILDING_TYPE) = 'resident' THEN 'RESIDENTIAL' ELSE bc.BUILDING_TYPE END AS btype,\n        bc.PARENT_BUILDING_NUMBER,\n        bc.EXT_GROSS_AREA,\n        b.BUILDING_STREET_ADDRESS AS street_addr,\n        addr.CITY,\n        addr.STATE,\n        addr.POSTAL_CODE,\n        COALESCE(epb.emp_count, 0) AS emp_count\n    FROM building_current bc\n    LEFT JOIN BUILDINGS b ON bc.building_key = b.BUILDING_KEY\n    LEFT JOIN address_selected addr ON bc.building_key = addr.BUILDING_KEY\n    LEFT JOIN employee_per_building epb ON bc.building_key = epb.BUILDING_KEY\n)\nSELECT\n    CASE WHEN GROUPING(btype) = 1 THEN 'TOTAL' ELSE btype END AS building_type,\n    SUM(CASE WHEN (PARENT_BUILDING_NUMBER IS NULL OR TRIM(PARENT_BUILDING_NUMBER) = '') THEN 1 ELSE 0 END) AS num_buildings_not_subdivisions,\n    SUM(emp_count) AS num_employees,\n    COUNT(DISTINCT street_addr) AS num_unique_street_address,\n    COUNT(DISTINCT CITY) AS num_unique_city,\n    COUNT(DISTINCT STATE) AS num_unique_state,\n    COUNT(DISTINCT POSTAL_CODE) AS num_unique_postal_code,\n    SUM(EXT_GROSS_AREA) / NULLIF(SUM(emp_count), 0) AS avg_gross_sqft_per_employee\nFROM building_details\nGROUP BY btype WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "Group spaces in the Stata building by the access level and usage type. For each group, state the access level, usage type, name of the space, the number of spaces, total area across all rooms in the space, and average area across all rooms in the space. Display the access level only if it differs from the previous entry. Include subtotals for each access level, usage type, and space name, subtotals for each access level, and a grand total across all access levels. Exclude usage type that includes \"STORAGE\". All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT\n    Z.ACCESS_LEVEL AS access_level,\n    SU.SPACE_USAGE AS usage_type,\n    FO.DLC_NAME AS space_name,\n    FORMAT(COUNT(*), 0) AS num_spaces,\n    FORMAT(ROUND(SUM(SD.ROOM_SQUARE_FOOTAGE)), 0) AS total_area,\n    FORMAT(ROUND(AVG(SD.ROOM_SQUARE_FOOTAGE)), 0) AS avg_area\nFROM ZPM_ROOMS_LOAD Z\nJOIN SPACE_DETAIL SD\n    ON Z.BUILDING_ROOM = SD.BUILDING_ROOM\n    AND Z.BUILDING_COMPONENT = SD.BUILDING_COMPONENT\nJOIN SPACE_USAGE SU\n    ON SD.SPACE_USAGE_KEY = SU.SPACE_USAGE_KEY\nJOIN SPACE_UNIT SU2\n    ON Z.SPACE_UNIT_CODE = SU2.SPACE_UNIT_CODE\nJOIN FCLT_ORGANIZATION FO\n    ON SU2.FCLT_ORGANIZATION_KEY = FO.FCLT_ORGANIZATION_KEY\nWHERE Z.BUILDING_COMPONENT = '1'\n    AND SU.SPACE_USAGE NOT LIKE '%STORAGE%'\nGROUP BY Z.ACCESS_LEVEL, SU.SPACE_USAGE, FO.DLC_NAME WITH ROLLUP\nORDER BY\n    (Z.ACCESS_LEVEL IS NULL), Z.ACCESS_LEVEL,\n    (SU.SPACE_USAGE IS NULL), SU.SPACE_USAGE,\n    (FO.DLC_NAME IS NULL), FO.DLC_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List each organization's break group, ID, name, and formatted name according to its level, along with whether its members are emeritus or non-emeritus. Also, include the organization number, level, employer count, and hierarchy type for each organization. Exclude organizations '139' and '250'. Sort the results by hierarchy type and ensure totals for employer counts are displayed.",
        "predicted_sql": "WITH faculty_agg AS (\n    SELECT\n        u.DLC_KEY,\n        CASE \n            WHEN f.EMERITUS_STATUS = 'Emeritus' THEN 'Emeritus' \n            ELSE 'Non-Emeritus' \n        END AS emeritus_status,\n        COUNT(DISTINCT f.MIT_ID) AS employer_count\n    FROM HR_FACULTY_ROSTER f\n    JOIN HR_ORG_UNIT u ON f.HR_ORG_UNIT_TITLE = u.HR_ORG_UNIT_TITLE\n    GROUP BY u.DLC_KEY, \n        CASE \n            WHEN f.EMERITUS_STATUS = 'Emeritus' THEN 'Emeritus' \n            ELSE 'Non-Emeritus' \n        END\n),\ndetail AS (\n    SELECT\n        o.ORGANIZATION_SORT AS break_group,\n        o.ORGANIZATION_ID AS ID,\n        o.ORGANIZATION_NAME AS name,\n        CASE CAST(o.ORGANIZATION_LEVEL AS INTEGER)\n            WHEN 1 THEN o.ORGANIZATION_NAME\n            WHEN 2 THEN '  ' || o.ORGANIZATION_NAME\n            WHEN 3 THEN '    ' || o.ORGANIZATION_NAME\n            WHEN 4 THEN '      ' || o.ORGANIZATION_NAME\n            WHEN 5 THEN '        ' || o.ORGANIZATION_NAME\n            WHEN 6 THEN '          ' || o.ORGANIZATION_NAME\n            ELSE o.ORGANIZATION_NAME\n        END AS formatted_name,\n        fa.emeritus_status,\n        o.ORGANIZATION_NUMBER AS org_number,\n        o.ORGANIZATION_LEVEL AS level,\n        fa.employer_count,\n        h.HIERARCHY_TYPE\n    FROM FCLT_ORGANIZATION o\n    JOIN faculty_agg fa ON o.DLC_KEY = fa.DLC_KEY\n    JOIN MASTER_DEPT_HIERARCHY h ON o.DLC_KEY = h.DLC_KEY\n    WHERE o.ORGANIZATION_ID NOT IN ('139', '250')\n)\nSELECT break_group, ID, name, formatted_name, emeritus_status, org_number, level, employer_count, hierarchy_type\nFROM detail\nUNION ALL\nSELECT \n    NULL,\n    NULL,\n    NULL,\n    'Total',\n    NULL,\n    NULL,\n    NULL,\n    SUM(employer_count),\n    'Total'\nFROM detail\nORDER BY \n    CASE WHEN hierarchy_type = 'Total' THEN 1 ELSE 0 END,\n    hierarchy_type,\n    ID,\n    emeritus_status;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its title, name of the building of the course location, duration (in terms of days), and a running average of the duration (in terms of days) using a window of two preceding and two following courses (partitioned by academic year and sorted by course start date).",
        "predicted_sql": "SELECT \n    C.SUBJECT_TITLE AS title,\n    B.BUILDING_NAME AS building_name,\n    DATEDIFF(T.TERM_END_DATE, T.TERM_START_DATE) AS duration,\n    AVG(DATEDIFF(T.TERM_END_DATE, T.TERM_START_DATE)) OVER (\n        PARTITION BY T.ACADEMIC_YEAR \n        ORDER BY T.TERM_START_DATE \n        ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING\n    ) AS running_avg_duration\nFROM COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN ACADEMIC_TERMS T ON C.EFFECTIVE_TERM_CODE = T.TERM_CODE\nLEFT JOIN FCLT_ROOMS R ON C.MEET_PLACE = R.BUILDING_ROOM\nLEFT JOIN FCLT_BUILDING B ON R.FCLT_BUILDING_KEY = B.FCLT_BUILDING_KEY;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, the start date, the name of the course before it, and the name of the course after it, access level of the building, and the assignable area of the room used for the course, sorted by the ascending order start date and course name.",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE AS course_name,\n    b.BUILDING_NAME_LONG AS building_name,\n    a.TERM_START_DATE AS start_date,\n    LAG(c.SUBJECT_TITLE) OVER (ORDER BY a.TERM_START_DATE, c.SUBJECT_TITLE) AS previous_course_name,\n    LEAD(c.SUBJECT_TITLE) OVER (ORDER BY a.TERM_START_DATE, c.SUBJECT_TITLE) AS next_course_name,\n    b.ACCESS_LEVEL_NAME AS access_level,\n    r.AREA AS assignable_area\nFROM COURSE_CATALOG_SUBJECT_OFFERED c\nLEFT JOIN ACADEMIC_TERMS a ON c.TERM_CODE = a.TERM_CODE\nLEFT JOIN FCLT_ROOMS r ON c.MEET_PLACE = r.BUILDING_ROOM\nLEFT JOIN FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nORDER BY a.TERM_START_DATE, c.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, and the cumulative number of courses, including the course itself, held in the same year or preceding years (partitioned by academic year and sorted in the ascending order of course start date).",
        "predicted_sql": "SELECT \n    sub.SUBJECT_TITLE AS course_name,\n    bld.BUILDING_NAME AS building_name,\n    COUNT(*) OVER (PARTITION BY term.ACADEMIC_YEAR ORDER BY term.TERM_START_DATE) AS cumulative_courses\nFROM COURSE_CATALOG_SUBJECT_OFFERED sub\nJOIN ACADEMIC_TERMS term ON sub.EFFECTIVE_TERM_CODE = term.TERM_CODE\nJOIN FCLT_ROOMS room ON sub.MEET_PLACE = room.FCLT_ROOM_KEY\nJOIN FCLT_BUILDING bld ON room.FCLT_BUILDING_KEY = bld.FCLT_BUILDING_KEY\nORDER BY term.ACADEMIC_YEAR, term.TERM_START_DATE;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the cluster type. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), cluster type, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and cluster type.",
        "predicted_sql": "WITH base AS (\n    SELECT \n        CASE WHEN a.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END AS current_status,\n        s.CLUSTER_TYPE,\n        DATEDIFF(a.TERM_END_DATE, a.TERM_START_DATE) AS duration,\n        s.TOTAL_UNITS AS total_units\n    FROM SUBJECT_SUMMARY s\n    INNER JOIN ACADEMIC_TERMS_ALL a ON s.TERM_CODE = a.TERM_CODE\n    WHERE s.DEPARTMENT_NAME LIKE '%Biology%' OR s.DEPARTMENT_NAME LIKE '%Chemistry%'\n)\nSELECT \n    display_status AS current_status,\n    cluster_type,\n    max_duration,\n    max_units,\n    avg_duration,\n    avg_units\nFROM (\n    SELECT \n        CASE \n            WHEN GROUPING(current_status) = 1 AND GROUPING(cluster_type) = 1 THEN 'TOTAL'\n            WHEN GROUPING(cluster_type) = 1 THEN 'SUBTOTAL'\n            ELSE current_status\n        END AS display_status,\n        current_status AS original_status,\n        cluster_type,\n        GROUPING(current_status) AS grp_status,\n        GROUPING(cluster_type) AS grp_cluster,\n        MAX(duration) AS max_duration,\n        MAX(total_units) AS max_units,\n        AVG(duration) AS avg_duration,\n        AVG(total_units) AS avg_units\n    FROM base\n    GROUP BY current_status, cluster_type WITH ROLLUP\n) AS rolled\nORDER BY \n    grp_status,\n    original_status,\n    grp_cluster,\n    cluster_type;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the department name. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), department name, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and department.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN GROUPING(original_current_status) = 1 AND GROUPING(department) = 1 THEN 'TOTAL'\n        WHEN GROUPING(department) = 1 THEN 'SUBTOTAL'\n        ELSE original_current_status\n    END AS current_status,\n    department AS department_name,\n    MAX(duration_days) AS max_duration,\n    MAX(total_units) AS max_units,\n    AVG(duration_days) AS avg_duration,\n    AVG(total_units) AS avg_units\nFROM (\n    SELECT \n        CASE WHEN A.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END AS original_current_status,\n        O.OFFER_DEPT_NAME AS department,\n        DATEDIFF(A.TERM_END_DATE, A.TERM_START_DATE) AS duration_days,\n        S.TOTAL_UNITS AS total_units\n    FROM SUBJECT_SUMMARY S\n    JOIN ACADEMIC_TERMS_ALL A ON S.TERM_CODE = A.TERM_CODE\n    JOIN SUBJECT_OFFERED O ON S.SUBJECT_ID = O.SUBJECT_ID AND S.TERM_CODE = O.TERM_CODE\n    WHERE O.OFFER_DEPT_NAME IN ('Biology', 'Chemistry')\n) AS base\nGROUP BY original_current_status, department WITH ROLLUP\nORDER BY \n    GROUPING(original_current_status),\n    original_current_status,\n    GROUPING(department),\n    department;"
    },
    {
        "db_id": "dw",
        "question": "Group master courses by department. For each group, state the name of the department, the master course code, the number of subjects, the total new shelf price of associated TIP materials, and the number of unique TIP materials. Display the department and master course only if it differs from the previous entry. Include subtotals for each department and a grand total across all departments. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH subject_groups AS (\n    SELECT OFFER_DEPT_NAME AS dept,\n           MASTER_COURSE_NUMBER AS master_course,\n           COUNT(DISTINCT SUBJECT_ID) AS num_subjects\n    FROM TIP_SUBJECT_OFFERED\n    GROUP BY OFFER_DEPT_NAME, MASTER_COURSE_NUMBER\n),\ndistinct_materials AS (\n    SELECT DISTINCT s.OFFER_DEPT_NAME,\n                    s.MASTER_COURSE_NUMBER,\n                    m.TIP_MATERIAL_KEY,\n                    m.NEW_SHELF_PRICE\n    FROM TIP_SUBJECT_OFFERED s\n    JOIN TIP_DETAIL d ON s.TIP_SUBJECT_OFFERED_KEY = d.TIP_SUBJECT_OFFERED_KEY\n    JOIN TIP_MATERIAL m ON d.TIP_MATERIAL_KEY = m.TIP_MATERIAL_KEY\n),\nmaterial_groups AS (\n    SELECT OFFER_DEPT_NAME AS dept,\n           MASTER_COURSE_NUMBER AS master_course,\n           COUNT(*) AS num_materials,\n           SUM(NEW_SHELF_PRICE) AS total_price\n    FROM distinct_materials\n    GROUP BY OFFER_DEPT_NAME, MASTER_COURSE_NUMBER\n)\nSELECT \n    CASE \n        WHEN GROUPING(sg.dept) = 1 THEN 'Grand Total'\n        ELSE sg.dept\n    END AS department,\n    CASE \n        WHEN GROUPING(sg.master_course) = 1 AND GROUPING(sg.dept) = 0 THEN 'Department Total'\n        WHEN GROUPING(sg.master_course) = 1 AND GROUPING(sg.dept) = 1 THEN ''\n        ELSE sg.master_course\n    END AS master_course,\n    FORMAT(COALESCE(SUM(sg.num_subjects), 0), 0) AS num_subjects,\n    FORMAT(COALESCE(SUM(mg.total_price), 0), 0) AS total_new_shelf_price,\n    FORMAT(COALESCE(SUM(mg.num_materials), 0), 0) AS num_unique_materials\nFROM subject_groups sg\nLEFT JOIN material_groups mg ON sg.dept = mg.dept AND sg.master_course = mg.master_course\nGROUP BY sg.dept, sg.master_course WITH ROLLUP\nORDER BY GROUPING(sg.dept), sg.dept, GROUPING(sg.master_course), sg.master_course;"
    },
    {
        "db_id": "dw",
        "question": "For each term and department, list the term, department, the number of courses, average number of equivalent subjects, the school name, and department phone number. Include subtotals for each term (the corresponding term field is 'SUBTOTAL') and a grand total across all terms (the corresponding term field is 'TOTAL'). Do not repeat the term if it is the same as the previous row. Sort the table by term and department.",
        "predicted_sql": "WITH subject_data AS (\n  SELECT \n    C.TERM_CODE,\n    C.DEPARTMENT_CODE,\n    MAX(C.DEPARTMENT_NAME) AS DEPARTMENT_NAME,\n    MAX(D.SCHOOL_NAME) AS SCHOOL_NAME,\n    MAX(A.DEPARTMENT_PHONE_NUMBER) AS DEPARTMENT_PHONE_NUMBER,\n    MAX(CASE \n          WHEN C.EQUIVALENT_SUBJECTS IS NULL OR C.EQUIVALENT_SUBJECTS = '' THEN 0 \n          ELSE (LENGTH(C.EQUIVALENT_SUBJECTS) - LENGTH(REPLACE(C.EQUIVALENT_SUBJECTS, ',', '')) + 1) \n        END) AS equiv_count\n  FROM COURSE_CATALOG_SUBJECT_OFFERED C\n  LEFT JOIN SIS_DEPARTMENT D ON C.DEPARTMENT_CODE = D.DEPARTMENT_CODE\n  LEFT JOIN SIS_ADMIN_DEPARTMENT A ON D.DEPARTMENT_CODE = A.SIS_ADMIN_DEPARTMENT_CODE\n  GROUP BY C.TERM_CODE, C.DEPARTMENT_CODE, C.SUBJECT_ID\n),\nrollup_data AS (\n  SELECT \n    CASE \n      WHEN GROUPING(TERM_CODE) = 1 THEN 'TOTAL'\n      WHEN GROUPING(DEPARTMENT_CODE) = 1 THEN 'SUBTOTAL'\n      ELSE TERM_CODE\n    END AS term_display,\n    CASE WHEN GROUPING(DEPARTMENT_CODE) = 1 THEN NULL ELSE MAX(DEPARTMENT_NAME) END AS department,\n    COUNT(*) AS number_of_courses,\n    AVG(equiv_count) AS avg_equivalent_subjects,\n    CASE WHEN GROUPING(DEPARTMENT_CODE) = 0 THEN MAX(SCHOOL_NAME) ELSE NULL END AS school_name,\n    CASE WHEN GROUPING(DEPARTMENT_CODE) = 0 THEN MAX(DEPARTMENT_PHONE_NUMBER) ELSE NULL END AS department_phone_number,\n    TERM_CODE AS raw_term_code,\n    GROUPING(TERM_CODE) AS g_term,\n    GROUPING(DEPARTMENT_CODE) AS g_dept,\n    MAX(DEPARTMENT_NAME) AS raw_department_name\n  FROM subject_data\n  GROUP BY TERM_CODE, DEPARTMENT_CODE WITH ROLLUP\n)\nSELECT \n  CASE \n    WHEN term_display = LAG(term_display) OVER (ORDER BY g_term, raw_term_code, g_dept, raw_department_name) \n    THEN NULL \n    ELSE term_display \n  END AS term,\n  department,\n  number_of_courses,\n  avg_equivalent_subjects,\n  school_name,\n  department_phone_number\nFROM rollup_data\nORDER BY g_term, raw_term_code, g_dept, raw_department_name;"
    },
    {
        "db_id": "dw",
        "question": "Group sessions by their current term status. For each group, state the status ('CURRENT' if is current term and 'NOT CURRENT' otherwise), name of the session, number of IAP sessions, total IAP session time in days, and average IAP session time in days. Show a subtotal for each current status and a grand total row across all status. Order the results by current status and cluster type. Display the the current status only if it differs from the previous entry.",
        "predicted_sql": "WITH session_data AS (\n    SELECT \n        CASE WHEN a.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END AS term_status,\n        c.IAP_CATEGORY_NAME AS category_name,\n        (TIME_TO_SEC(STR_TO_DATE(s.SESSION_END_TIME, '%h%i%p')) - TIME_TO_SEC(STR_TO_DATE(s.SESSION_START_TIME, '%h%i%p'))) / 86400.0 AS duration_days\n    FROM IAP_SUBJECT_DETAIL d\n    INNER JOIN ACADEMIC_TERMS a ON d.TERM_CODE = a.TERM_CODE\n    INNER JOIN IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\n    INNER JOIN IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\n)\nSELECT \n    term_status AS `current_status`,\n    category_name AS `session_name`,\n    COUNT(*) AS `number_of_sessions`,\n    COALESCE(SUM(duration_days), 0) AS `total_session_time_days`,\n    COALESCE(AVG(duration_days), 0) AS `average_session_time_days`\nFROM session_data\nGROUP BY term_status, category_name WITH ROLLUP\nORDER BY \n    GROUPING(term_status),\n    term_status,\n    GROUPING(category_name),\n    category_name;"
    },
    {
        "db_id": "dw",
        "question": "List each academic year, the term code, and the number of newly introduced subjects in this term. Display the academic year only if it differs from the previous entry. Include a grand total (the corresponding year field should be 'TOTAL') stating the total number of subjects across all academic years.",
        "predicted_sql": "WITH distinct_subject_terms AS (\n  SELECT DISTINCT SUBJECT_ID, TERM_CODE\n  FROM COURSE_CATALOG_SUBJECT_OFFERED\n),\nsubject_terms_with_date AS (\n  SELECT d.SUBJECT_ID, d.TERM_CODE, a.ACADEMIC_YEAR, a.TERM_START_DATE\n  FROM distinct_subject_terms d\n  JOIN ACADEMIC_TERMS_ALL a ON d.TERM_CODE = a.TERM_CODE\n),\nsubject_first_term AS (\n  SELECT \n    SUBJECT_ID,\n    TERM_CODE,\n    ACADEMIC_YEAR,\n    TERM_START_DATE,\n    ROW_NUMBER() OVER (PARTITION BY SUBJECT_ID ORDER BY TERM_START_DATE) AS rn\n  FROM subject_terms_with_date\n),\nterm_counts AS (\n  SELECT \n    ACADEMIC_YEAR,\n    TERM_CODE,\n    COUNT(*) AS new_subjects,\n    MIN(TERM_START_DATE) AS term_start_date\n  FROM subject_first_term\n  WHERE rn = 1\n  GROUP BY ACADEMIC_YEAR, TERM_CODE\n)\nSELECT \n  academic_year,\n  term_code,\n  new_subjects\nFROM (\n  SELECT \n    CASE \n      WHEN LAG(ACADEMIC_YEAR) OVER (ORDER BY term_start_date) = ACADEMIC_YEAR THEN NULL\n      ELSE ACADEMIC_YEAR\n    END AS academic_year,\n    TERM_CODE,\n    new_subjects,\n    term_start_date\n  FROM term_counts\n  UNION ALL\n  SELECT \n    'TOTAL' AS academic_year,\n    NULL AS TERM_CODE,\n    SUM(new_subjects) AS new_subjects,\n    NULL AS term_start_date\n  FROM term_counts\n) AS combined\nORDER BY \n  CASE WHEN academic_year = 'TOTAL' THEN 2 ELSE 1 END,\n  term_start_date;"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with e (case insensitive), containing 10 to 20 members inclusive, and where over 75% are computer science students, provide the list name, owner, and member count.",
        "predicted_sql": "SELECT \n    l.MOIRA_LIST_NAME AS list_name,\n    o.OWNER AS owner,\n    COUNT(DISTINCT d.MOIRA_LIST_MEMBER) AS member_count\nFROM \n    MOIRA_LIST l\n    INNER JOIN MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\n    INNER JOIN MOIRA_LIST_OWNER o ON d.MOIRA_LIST_OWNER_KEY = o.MOIRA_LIST_OWNER_KEY\n    LEFT JOIN SE_PERSON s ON d.MOIRA_LIST_MEMBER = s.KRB_NAME\n    LEFT JOIN MIT_STUDENT_DIRECTORY sd ON s.FULL_NAME = sd.FULL_NAME\nWHERE \n    LOWER(l.MOIRA_LIST_NAME) LIKE 'e%'\nGROUP BY \n    l.MOIRA_LIST_KEY, l.MOIRA_LIST_NAME, o.OWNER\nHAVING \n    COUNT(DISTINCT d.MOIRA_LIST_MEMBER) BETWEEN 10 AND 20\n    AND COUNT(DISTINCT CASE WHEN LOWER(sd.DEPARTMENT_NAME) LIKE '%computer science%' THEN d.MOIRA_LIST_MEMBER END) > 0.75 * COUNT(DISTINCT d.MOIRA_LIST_MEMBER);"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with K, list their names, the phone numbers of departments they belong to, total number of mailing lists each student is in, and the average size of the mailing lists each student is in.",
        "predicted_sql": "WITH list_sizes AS (\n    SELECT\n        l.MOIRA_LIST_KEY,\n        COUNT(DISTINCT ld.MOIRA_LIST_MEMBER) AS list_size\n    FROM MOIRA_LIST l\n    JOIN MOIRA_LIST_DETAIL ld ON l.MOIRA_LIST_KEY = ld.MOIRA_LIST_KEY\n    WHERE l.IS_MOIRA_MAILING_LIST = 'Y'\n    GROUP BY l.MOIRA_LIST_KEY\n),\nstudent_mailing_stats AS (\n    SELECT\n        p.MIT_ID,\n        COUNT(DISTINCT ls.MOIRA_LIST_KEY) AS total_mailing_lists,\n        AVG(ls.list_size) AS avg_mailing_list_size\n    FROM SE_PERSON p\n    LEFT JOIN MOIRA_LIST_DETAIL ld ON p.MIT_ID = ld.MOIRA_LIST_MEMBER_MIT_ID\n    LEFT JOIN list_sizes ls ON ld.MOIRA_LIST_KEY = ls.MOIRA_LIST_KEY\n    GROUP BY p.MIT_ID\n)\nSELECT\n    s.FULL_NAME AS student_name,\n    adm.DEPARTMENT_PHONE_NUMBER AS department_phone,\n    sms.total_mailing_lists,\n    sms.avg_mailing_list_size\nFROM MIT_STUDENT_DIRECTORY s\nJOIN SE_PERSON p ON s.FULL_NAME = p.FULL_NAME\nJOIN SIS_DEPARTMENT dept ON s.DEPARTMENT = dept.DEPARTMENT_CODE\nJOIN SIS_ADMIN_DEPARTMENT adm ON dept.DEPARTMENT_CODE = adm.SIS_ADMIN_DEPARTMENT_CODE\nLEFT JOIN student_mailing_stats sms ON p.MIT_ID = sms.MIT_ID\nWHERE s.LAST_NAME LIKE 'K%'\nORDER BY s.FULL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "From the 100 email lists with the most number of subscribers, list their names, their total number of subscribers, their public status, the name of the department with the most presence in the list, and the number of students from this department in the list.",
        "predicted_sql": "WITH ListTotal AS (\n    SELECT MOIRA_LIST_KEY, COUNT(*) AS total_subscribers\n    FROM MOIRA_LIST_DETAIL\n    GROUP BY MOIRA_LIST_KEY\n),\nRankedLists AS (\n    SELECT \n        ml.MOIRA_LIST_KEY,\n        ml.MOIRA_LIST_NAME,\n        ml.IS_PUBLIC,\n        lt.total_subscribers,\n        ROW_NUMBER() OVER (ORDER BY lt.total_subscribers DESC) AS rn\n    FROM MOIRA_LIST ml\n    JOIN ListTotal lt ON ml.MOIRA_LIST_KEY = lt.MOIRA_LIST_KEY\n),\nDeptStudentCounts AS (\n    SELECT \n        mld.MOIRA_LIST_KEY,\n        sd.DEPARTMENT_NAME,\n        COUNT(*) AS student_count\n    FROM MOIRA_LIST_DETAIL mld\n    INNER JOIN MIT_STUDENT_DIRECTORY msd ON mld.MOIRA_LIST_MEMBER_FULL_NAME = msd.FULL_NAME\n    INNER JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\n    GROUP BY mld.MOIRA_LIST_KEY, sd.DEPARTMENT_NAME\n),\nRankedDepts AS (\n    SELECT \n        dsc.MOIRA_LIST_KEY,\n        dsc.DEPARTMENT_NAME,\n        dsc.student_count,\n        ROW_NUMBER() OVER (PARTITION BY dsc.MOIRA_LIST_KEY ORDER BY dsc.student_count DESC, dsc.DEPARTMENT_NAME ASC) AS rn\n    FROM DeptStudentCounts dsc\n)\nSELECT \n    rl.MOIRA_LIST_NAME AS list_name,\n    rl.total_subscribers,\n    rl.IS_PUBLIC AS public_status,\n    rd.DEPARTMENT_NAME AS department_name,\n    COALESCE(rd.student_count, 0) AS student_count\nFROM RankedLists rl\nLEFT JOIN RankedDepts rd ON rl.MOIRA_LIST_KEY = rd.MOIRA_LIST_KEY AND rd.rn = 1\nWHERE rl.rn <= 100\nORDER BY rl.total_subscribers DESC;"
    },
    {
        "db_id": "dw",
        "question": "Calculate the total assignable and non-assignable area for each building by summing up the respective areas of all its floors. For each building, list the building name, building number, total assignable area, total non-assignable area, and total room count, sorted in descending order of the total assignable area.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME,\n    b.BUILDING_NUMBER,\n    COALESCE(f.total_assignable, 0) AS total_assignable_area,\n    COALESCE(f.total_non_assignable, 0) AS total_non_assignable_area,\n    COALESCE(r.total_rooms, 0) AS total_room_count\nFROM FAC_BUILDING b\nLEFT JOIN (\n    SELECT BUILDING_KEY,\n           SUM(ASSIGNABLE_AREA) AS total_assignable,\n           SUM(NON_ASSIGNABLE_AREA) AS total_non_assignable\n    FROM FAC_FLOOR\n    GROUP BY BUILDING_KEY\n) f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nLEFT JOIN (\n    SELECT BUILDING_KEY,\n           COUNT(*) AS total_rooms\n    FROM FAC_ROOMS\n    GROUP BY BUILDING_KEY\n) r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY\nORDER BY total_assignable_area DESC;"
    },
    {
        "db_id": "dw",
        "question": "List all rooms in building 45, including their full name, area, major use, the organization that occupies them, the count of rooms per major use, and the total area occupied by rooms for each organization.",
        "predicted_sql": "SELECT \n    r.ROOM_FULL_NAME,\n    r.AREA,\n    m.MAJOR_USE,\n    o.ORGANIZATION_NAME,\n    COUNT(*) OVER (PARTITION BY r.MAJOR_USE_KEY) AS rooms_per_major_use,\n    SUM(CAST(r.AREA AS DECIMAL(10,2))) OVER (PARTITION BY r.ORGANIZATION_KEY) AS total_area_per_org\nFROM FAC_ROOMS r\nJOIN FAC_MAJOR_USE m ON r.MAJOR_USE_KEY = m.MAJOR_USE_KEY\nJOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\nWHERE r.BUILDING_KEY = '45';"
    },
    {
        "db_id": "dw",
        "question": "List the name, number, construction date, and type of all buildings, along with the count of addresses associated with each building, the average gross area of the buildings, and the total number of rooms in each building. Sort the results by building name.",
        "predicted_sql": "SELECT\n    b.BUILDING_NAME AS name,\n    b.BUILDING_NUMBER AS number,\n    b.DATE_BUILT AS construction_date,\n    b.BUILDING_TYPE AS type,\n    b.EXT_GROSS_AREA AS gross_area,\n    COALESCE(a.addr_count, 0) AS address_count,\n    COALESCE(r.room_count, 0) AS room_count\nFROM FAC_BUILDING b\nLEFT JOIN (\n    SELECT BUILDING_KEY, COUNT(*) AS addr_count\n    FROM FAC_BUILDING_ADDRESS\n    GROUP BY BUILDING_KEY\n) a ON b.FAC_BUILDING_KEY = a.BUILDING_KEY\nLEFT JOIN (\n    SELECT BUILDING_KEY, COUNT(*) AS room_count\n    FROM FAC_ROOMS\n    GROUP BY BUILDING_KEY\n) r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY\nORDER BY b.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list its name, number of unique courses offered, the number of unique reserved materials, and the number of unique instructors associated with those courses, sorted by the number of unique courses offered in descending order.",
        "predicted_sql": "SELECT \n    s.OFFER_DEPT_NAME AS department_name,\n    COUNT(DISTINCT s.MASTER_COURSE_NUMBER) AS unique_courses,\n    COUNT(DISTINCT rc.LIBRARY_RESERVE_CATALOG_KEY) AS unique_reserved_materials,\n    COUNT(DISTINCT i.INSTRUCTOR_NAME) AS unique_instructors\nFROM LIBRARY_SUBJECT_OFFERED s\nLEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL d ON s.LIBRARY_SUBJECT_OFFERED_KEY = d.LIBRARY_SUBJECT_OFFERED_KEY\nLEFT JOIN LIBRARY_RESERVE_CATALOG rc ON d.LIBRARY_RESERVE_CATALOG_KEY = rc.LIBRARY_RESERVE_CATALOG_KEY\nLEFT JOIN LIBRARY_COURSE_INSTRUCTOR i ON d.LIBRARY_COURSE_INSTRUCTOR_KEY = i.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY s.OFFER_DEPT_NAME\nORDER BY unique_courses DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each course title, list the title, the total number of reserved materials, and the count of distinct material status associated with those materials, sorted by the total number of reserved materials in descending order.",
        "predicted_sql": "SELECT \n    s.SUBJECT_TITLE AS title,\n    COUNT(DISTINCT r.LIBRARY_RESERVE_CATALOG_KEY) AS total_reserved_materials,\n    COUNT(DISTINCT m.LIBRARY_MATERIAL_STATUS) AS distinct_status_count\nFROM LIBRARY_RESERVE_MATRL_DETAIL r\nJOIN LIBRARY_SUBJECT_OFFERED s ON r.LIBRARY_SUBJECT_OFFERED_KEY = s.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN LIBRARY_MATERIAL_STATUS m ON r.LIBRARY_MATERIAL_STATUS_KEY = m.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY s.SUBJECT_TITLE\nORDER BY total_reserved_materials DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each instructor, list their name, the number of unique courses they teach, the total number of material assignments, average publication year, and number of distinct status, sorted by the number of unique courses in descending order.",
        "predicted_sql": "SELECT\n    i.INSTRUCTOR_NAME AS instructor_name,\n    COUNT(DISTINCT i.COURSE_NAME) AS unique_courses,\n    COUNT(m.LIBRARY_RESERVE_CATALOG_KEY) AS total_assignments,\n    AVG(CAST(c.CATALOG_YEAR AS INTEGER)) AS avg_publication_year,\n    COUNT(DISTINCT s.LIBRARY_MATERIAL_STATUS) AS distinct_status_count\nFROM LIBRARY_COURSE_INSTRUCTOR i\nLEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL m ON i.LIBRARY_COURSE_INSTRUCTOR_KEY = m.LIBRARY_COURSE_INSTRUCTOR_KEY\nLEFT JOIN LIBRARY_RESERVE_CATALOG c ON m.LIBRARY_RESERVE_CATALOG_KEY = c.LIBRARY_RESERVE_CATALOG_KEY\nLEFT JOIN LIBRARY_MATERIAL_STATUS s ON m.LIBRARY_MATERIAL_STATUS_KEY = s.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY i.INSTRUCTOR_NAME\nORDER BY unique_courses DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each publication year, list the year, the total number of reserved materials, the average length of their titles, distinct number of status, and number of courses, sorted by publication year in descending order.",
        "predicted_sql": "WITH \ndistinct_materials AS (\n    SELECT \n        c.CATALOG_YEAR,\n        c.LIBRARY_RESERVE_CATALOG_KEY,\n        LENGTH(c.CATALOG_TITLE) AS title_len\n    FROM LIBRARY_RESERVE_CATALOG c\n    WHERE EXISTS (\n        SELECT 1 \n        FROM LIBRARY_RESERVE_MATRL_DETAIL d\n        WHERE d.LIBRARY_RESERVE_CATALOG_KEY = c.LIBRARY_RESERVE_CATALOG_KEY\n    )\n),\nyear_stats AS (\n    SELECT\n        CATALOG_YEAR,\n        COUNT(*) AS total_materials,\n        AVG(title_len) AS avg_title_length\n    FROM distinct_materials\n    GROUP BY CATALOG_YEAR\n),\nyear_status_course AS (\n    SELECT\n        c.CATALOG_YEAR,\n        COUNT(DISTINCT s.LIBRARY_MATERIAL_STATUS) AS distinct_status_count,\n        COUNT(DISTINCT i.COURSE_NAME) AS number_courses\n    FROM LIBRARY_RESERVE_CATALOG c\n    INNER JOIN LIBRARY_RESERVE_MATRL_DETAIL d ON c.LIBRARY_RESERVE_CATALOG_KEY = d.LIBRARY_RESERVE_CATALOG_KEY\n    INNER JOIN LIBRARY_MATERIAL_STATUS s ON d.LIBRARY_MATERIAL_STATUS_KEY = s.LIBRARY_MATERIAL_STATUS_KEY\n    INNER JOIN LIBRARY_COURSE_INSTRUCTOR i ON d.LIBRARY_COURSE_INSTRUCTOR_KEY = i.LIBRARY_COURSE_INSTRUCTOR_KEY\n    GROUP BY c.CATALOG_YEAR\n)\nSELECT \n    y.CATALOG_YEAR AS publication_year,\n    y.total_materials,\n    y.avg_title_length,\n    sc.distinct_status_count,\n    sc.number_courses\nFROM year_stats y\nJOIN year_status_course sc ON y.CATALOG_YEAR = sc.CATALOG_YEAR\nORDER BY CAST(y.CATALOG_YEAR AS UNSIGNED) DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list the category name, the sponsor name, the number of activities offered, and the average fee per activity, sorted by the number of activities in descending order.",
        "predicted_sql": "SELECT \n    c.IAP_CATEGORY_NAME AS category_name,\n    s.SPONSOR_NAME AS sponsor_name,\n    COUNT(*) AS number_of_activities,\n    AVG(d.FEE) AS average_fee\nFROM IAP_SUBJECT_DETAIL d\nINNER JOIN IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\nINNER JOIN IAP_SUBJECT_SPONSOR s ON d.IAP_SUBJECT_SPONSOR_KEY = s.IAP_SUBJECT_SPONSOR_KEY\nGROUP BY c.IAP_CATEGORY_KEY, c.IAP_CATEGORY_NAME, s.SPONSOR_KEY, s.SPONSOR_NAME\nORDER BY number_of_activities DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor, list the sponsor name, the number of IAP sessions hosted, and the number of unique subjects organized.",
        "predicted_sql": "SELECT \n    sp.SPONSOR_NAME,\n    COUNT(s.IAP_SUBJECT_SESSION_KEY) AS `Number of IAP Sessions`,\n    COUNT(DISTINCT d.IAP_SUBJECT_SESSION_KEY) AS `Number of Unique Subjects`\nFROM \n    IAP_SUBJECT_SPONSOR sp\n    LEFT JOIN IAP_SUBJECT_DETAIL d ON sp.IAP_SUBJECT_SPONSOR_KEY = d.IAP_SUBJECT_SPONSOR_KEY\n    LEFT JOIN IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    sp.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each person role and IAP category, list the role, the category name, the number of people in this role, and the average fee, sorted by the role count in descending order.",
        "predicted_sql": "SELECT \n    p.PERSON_ROLE AS role,\n    c.IAP_CATEGORY_NAME AS category_name,\n    COUNT(DISTINCT p.IAP_SUBJECT_PERSON_KEY) AS number_of_people,\n    AVG(d.FEE) AS average_fee\nFROM \n    IAP_SUBJECT_PERSON p\n    JOIN IAP_SUBJECT_DETAIL d ON p.IAP_SUBJECT_PERSON_KEY = d.IAP_SUBJECT_PERSON_KEY\n    JOIN IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\nGROUP BY \n    p.PERSON_ROLE, c.IAP_CATEGORY_NAME\nORDER BY \n    number_of_people DESC;"
    },
    {
        "db_id": "dw",
        "question": "List the names of the buildings with the most floors. If there are ties, list each one separately.",
        "predicted_sql": "WITH building_floors AS (\n  SELECT b.FAC_BUILDING_KEY, b.BUILDING_NAME, COUNT(DISTINCT f.LEVEL_ID) AS floors\n  FROM FAC_BUILDING b\n  JOIN FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\n  GROUP BY b.FAC_BUILDING_KEY, b.BUILDING_NAME\n)\nSELECT BUILDING_NAME\nFROM building_floors\nWHERE floors = (SELECT MAX(floors) FROM building_floors);"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered in the summer term, list the subject titles, number of instructors, and the length of the longest instructor name.",
        "predicted_sql": "SELECT C.SUBJECT_TITLE, COUNT(DISTINCT E.MIT_ID) AS number_of_instructors, MAX(LENGTH(E.FULL_NAME)) AS longest_instructor_name_length\nFROM COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN ACADEMIC_TERMS_ALL A ON C.TERM_CODE = A.TERM_CODE\nJOIN EMPLOYEE_DIRECTORY E ON C.RESPONSIBLE_FACULTY_MIT_ID = E.MIT_ID\nWHERE A.TERM_CODE LIKE '%SU'\nGROUP BY C.SUBJECT_ID, C.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For the mailing list with owner key LIST69.377-keeper-xenon, list the owner, total number of mailing lists, and total number of members across all these mailing lists.",
        "predicted_sql": "SELECT \n    o.OWNER AS owner,\n    COUNT(DISTINCT d.MOIRA_LIST_KEY) AS total_mailing_lists,\n    COUNT(d.MOIRA_LIST_MEMBER) AS total_members\nFROM MOIRA_LIST_OWNER o\nJOIN MOIRA_LIST_DETAIL d ON o.MOIRA_LIST_OWNER_KEY = d.MOIRA_LIST_OWNER_KEY\nJOIN MOIRA_LIST l ON d.MOIRA_LIST_KEY = l.MOIRA_LIST_KEY\nWHERE o.MOIRA_LIST_OWNER_KEY = 'LIST69.377-keeper-xenon'\nAND l.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY o.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For each school, list the school name, total number of courses that appear in SIS subject code catalog, and the total number of degree-granting courses that appear in SIS subject code catalog.",
        "predicted_sql": "SELECT d.SCHOOL_NAME,\n       COUNT(DISTINCT cd.COURSE) AS total_courses,\n       COUNT(DISTINCT CASE WHEN cd.IS_DEGREE_GRANTING = 'Y' THEN cd.COURSE END) AS degree_granting_courses\nFROM SIS_COURSE_DESCRIPTION cd\nJOIN SIS_DEPARTMENT d ON cd.DEPARTMENT = d.DEPARTMENT_CODE\nJOIN SIS_SUBJECT_CODE sc ON cd.COURSE = sc.COURSE_NUMBER\nGROUP BY d.SCHOOL_NAME\nORDER BY d.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the department name, department phone number, number of students, and the length of the longest student full name in that department.",
        "predicted_sql": "SELECT d.DEPARTMENT_NAME, a.DEPARTMENT_PHONE_NUMBER, COUNT(*) AS number_of_students, MAX(LENGTH(s.FULL_NAME)) AS longest_full_name_length\nFROM SIS_DEPARTMENT d\nJOIN MIT_STUDENT_DIRECTORY s ON d.DEPARTMENT_CODE = s.DEPARTMENT\nJOIN SIS_ADMIN_DEPARTMENT a ON d.DEPARTMENT_CODE = a.SIS_ADMIN_DEPARTMENT_CODE\nGROUP BY d.DEPARTMENT_CODE, d.DEPARTMENT_NAME, a.DEPARTMENT_PHONE_NUMBER;"
    }
]