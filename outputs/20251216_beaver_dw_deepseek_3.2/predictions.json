[
    {
        "db_id": "dw",
        "question": "What is the current building key, building street address, city, state, and postal code of the history department?",
        "predicted_sql": "SELECT \n    FBA.FCLT_BUILDING_KEY AS building_key,\n    B.BUILDING_STREET_ADDRESS AS building_street_address,\n    FBA.CITY AS city,\n    FBA.STATE AS state,\n    FBA.POSTAL_CODE AS postal_code\nFROM MASTER_DEPT_HIERARCHY MDH\nINNER JOIN FCLT_ORG_DLC_KEY FODK ON MDH.DLC_KEY = FODK.DLC_KEY\nINNER JOIN FCLT_ROOMS FR ON FODK.FCLT_ORGANIZATION_KEY = FR.FCLT_ORGANIZATION_KEY\nINNER JOIN FCLT_BUILDING_ADDRESS FBA ON FR.FCLT_BUILDING_KEY = FBA.FCLT_BUILDING_KEY\nINNER JOIN BUILDINGS B ON FBA.FCLT_BUILDING_KEY = B.BUILDING_KEY\nWHERE LOWER(MDH.DLC_NAME) LIKE '%history department%';"
    },
    {
        "db_id": "dw",
        "question": "Show the unique activity titles, locations, term start date, and supervisor name for all independent activities, sorted by the ascending order of start date.",
        "predicted_sql": "SELECT DISTINCT \n    d.ACTIVITY_TITLE,\n    s.SESSION_LOCATION,\n    a.TERM_START_DATE,\n    p.PERSON_NAME AS SUPERVISOR_NAME\nFROM IAP_SUBJECT_DETAIL d\nJOIN ACADEMIC_TERMS_ALL a ON d.TERM_CODE = a.TERM_CODE\nJOIN IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nJOIN IAP_SUBJECT_PERSON p ON d.IAP_SUBJECT_PERSON_KEY = p.IAP_SUBJECT_PERSON_KEY\nORDER BY a.TERM_START_DATE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the unique course instructor names, course titles, and the amount of material for each course instructor key and the key of subject offered.",
        "predicted_sql": "SELECT DISTINCT \n    LCI.INSTRUCTOR_NAME,\n    LSO.SUBJECT_TITLE,\n    COUNT(DISTINCT LRC.CATALOG_ISBN) AS amount_of_material,\n    LCI.LIBRARY_COURSE_INSTRUCTOR_KEY,\n    LSO.LIBRARY_SUBJECT_OFFERED_KEY\nFROM LIBRARY_COURSE_INSTRUCTOR LCI\nJOIN LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN LIBRARY_SUBJECT_OFFERED LSO ON LRMD.LIBRARY_SUBJECT_OFFERED_KEY = LSO.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN LIBRARY_RESERVE_CATALOG LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\nGROUP BY \n    LCI.INSTRUCTOR_NAME,\n    LSO.SUBJECT_TITLE,\n    LCI.LIBRARY_COURSE_INSTRUCTOR_KEY,\n    LSO.LIBRARY_SUBJECT_OFFERED_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What is the room, floor, building key, building street address, city, state, and postal code of Professor Summer Haynes's office?",
        "predicted_sql": "SELECT \n    FAC_ROOMS.ROOM,\n    FAC_ROOMS.FLOOR,\n    FAC_BUILDING_ADDRESS.BUILDING_KEY,\n    BUILDINGS.BUILDING_STREET_ADDRESS,\n    FAC_BUILDING_ADDRESS.CITY,\n    FAC_BUILDING_ADDRESS.STATE,\n    FAC_BUILDING_ADDRESS.POSTAL_CODE\nFROM EMPLOYEE_DIRECTORY\nINNER JOIN FAC_ROOMS ON EMPLOYEE_DIRECTORY.OFFICE_LOCATION = FAC_ROOMS.FAC_ROOM_KEY\nINNER JOIN FAC_BUILDING_ADDRESS ON FAC_ROOMS.BUILDING_KEY = FAC_BUILDING_ADDRESS.BUILDING_KEY AND FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET'\nINNER JOIN BUILDINGS ON FAC_BUILDING_ADDRESS.BUILDING_KEY = BUILDINGS.BUILDING_KEY\nWHERE EMPLOYEE_DIRECTORY.FULL_NAME = 'Haynes, Summer';"
    },
    {
        "db_id": "dw",
        "question": "List the unique full room names, their corresponding building names, street addresses, cities, states, postal codes, and building heights for rooms associated with subjects that Computer Science students can enroll in.",
        "predicted_sql": "SELECT DISTINCT\n    R.ROOM_FULL_NAME,\n    BLD.BUILDING_NAME,\n    A.STREET_NUMBER || ' ' || A.STREET_NAME || COALESCE(' ' || A.STREET_SUFFIX, '') AS STREET_ADDRESS,\n    A.CITY,\n    A.STATE,\n    A.POSTAL_CODE,\n    B.BUILDING_HEIGHT\nFROM COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN FCLT_ROOMS R ON C.MEET_PLACE = R.FCLT_ROOM_KEY\nJOIN FCLT_BUILDING_ADDRESS A ON R.FCLT_BUILDING_KEY = A.FCLT_BUILDING_KEY AND A.ADDRESS_PURPOSE = 'STREET'\nJOIN FCLT_BUILDING B ON R.FCLT_BUILDING_KEY = B.FCLT_BUILDING_KEY\nJOIN BUILDINGS BLD ON R.FCLT_BUILDING_KEY = BLD.BUILDING_KEY\nWHERE C.DEPARTMENT_NAME LIKE '%Computer Sci%';"
    },
    {
        "db_id": "dw",
        "question": "List the unique term code, subject title, room, floor, building key, building street address, city, state, and postal code, formats, and number of enrolled students for all courses with more than 300 attendees.",
        "predicted_sql": "SELECT DISTINCT\n    so.TERM_CODE,\n    so.SUBJECT_TITLE,\n    fr.ROOM,\n    fr.FLOOR,\n    b.BUILDING_KEY,\n    b.BUILDING_STREET_ADDRESS,\n    fba.CITY,\n    fba.STATE,\n    fba.POSTAL_CODE,\n    so.FORM_TYPE AS formats,\n    so.NUM_ENROLLED_STUDENTS\nFROM SUBJECT_OFFERED so\nJOIN FCLT_ROOMS fr ON so.MEET_PLACE = fr.FCLT_ROOM_KEY\nJOIN BUILDINGS b ON fr.FCLT_BUILDING_KEY = b.BUILDING_KEY\nJOIN FCLT_BUILDING_ADDRESS fba ON fr.FCLT_BUILDING_KEY = fba.FCLT_BUILDING_KEY\nWHERE so.NUM_ENROLLED_STUDENTS > 300;"
    },
    {
        "db_id": "dw",
        "question": "What are the subject titles, their material titles, ISBN numbers, new shelf prices, and total costs of new materials for each subject title, sorted by individual item prices in ascending order?",
        "predicted_sql": "SELECT \n    tso.SUBJECT_TITLE,\n    tm.TITLE AS material_title,\n    tm.ISBN,\n    tm.NEW_SHELF_PRICE,\n    SUM(tm.NEW_SHELF_PRICE) OVER (PARTITION BY tso.SUBJECT_TITLE) AS total_cost\nFROM \n    TIP_SUBJECT_OFFERED tso\nJOIN \n    TIP_DETAIL td ON tso.SUBJECT_ID = td.SUBJECT_ID\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nORDER BY \n    tm.NEW_SHELF_PRICE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the long names of buildings constructed before 1950 that have more than 100 employees, the built year of the building, and number of employees.",
        "predicted_sql": "WITH building_employees AS (\n    SELECT \n        bh.BUILDING_NAME_LONG,\n        bh.DATE_BUILT,\n        COUNT(DISTINCT ed.MIT_ID) AS employee_count\n    FROM FCLT_BUILDING_HIST bh\n    JOIN FCLT_ROOMS r ON bh.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY\n    JOIN EMPLOYEE_DIRECTORY ed ON r.BUILDING_ROOM = ed.OFFICE_LOCATION\n    WHERE CAST(SUBSTR(bh.DATE_BUILT, -4) AS INTEGER) < 1950\n    GROUP BY bh.FCLT_BUILDING_KEY, bh.BUILDING_NAME_LONG, bh.DATE_BUILT\n    HAVING COUNT(DISTINCT ed.MIT_ID) > 100\n)\nSELECT \n    BUILDING_NAME_LONG,\n    CAST(SUBSTR(DATE_BUILT, -4) AS INTEGER) AS built_year,\n    employee_count AS number_of_employees\nFROM building_employees\nORDER BY employee_count DESC, BUILDING_NAME_LONG;"
    },
    {
        "db_id": "dw",
        "question": "For each building key, what is the building name and the number of courses offered by the Center for International Studies?",
        "predicted_sql": "SELECT \n    FB.FCLT_BUILDING_KEY AS building_key,\n    FB.BUILDING_NAME AS building_name,\n    COUNT(DISTINCT CIS.SUBJECT_ID) AS number_of_courses\nFROM \n    FCLT_BUILDING FB\nLEFT JOIN \n    FCLT_ROOMS FR ON FB.FCLT_BUILDING_KEY = FR.FCLT_BUILDING_KEY\nLEFT JOIN \n    COURSE_CATALOG_SUBJECT_OFFERED CCO ON FR.FCLT_ROOM_KEY = CCO.MEET_PLACE\nLEFT JOIN \n    CIS_COURSE_CATALOG CIS ON CCO.SUBJECT_ID = CIS.SUBJECT_ID\nGROUP BY \n    FB.FCLT_BUILDING_KEY, FB.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building that accomodates the most students, and how many students does it accomodate?",
        "predicted_sql": "SELECT b.BUILDING_NAME, COUNT(*) AS number_of_students\nFROM MIT_STUDENT_DIRECTORY s\nJOIN FCLT_ROOMS r ON s.OFFICE_LOCATION = r.BUILDING_ROOM\nJOIN FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nGROUP BY b.FCLT_BUILDING_KEY, b.BUILDING_NAME\nORDER BY number_of_students DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "List the name and floor of the building with the largest floor number.",
        "predicted_sql": "SELECT b.BUILDING_NAME, f.FLOOR\nFROM FAC_BUILDING b\nJOIN FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nWHERE CAST(f.FLOOR AS INTEGER) = (\n    SELECT MAX(CAST(FLOOR AS INTEGER)) \n    FROM FAC_FLOOR\n);"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category and academic year, list the category name, academic year, total fee collected, total number of IAP subjects, and the minimum and maximum enrollment.",
        "predicted_sql": "SELECT \n    c.IAP_CATEGORY_NAME AS category_name,\n    t.ACADEMIC_YEAR AS academic_year,\n    SUM(d.FEE) AS total_fee_collected,\n    COUNT(DISTINCT d.ACTIVITY_TITLE) AS total_subjects,\n    MIN(d.MAX_ENROLLMENT) AS min_enrollment,\n    MAX(d.MAX_ENROLLMENT) AS max_enrollment\nFROM \n    IAP_SUBJECT_DETAIL d\nJOIN \n    IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    TIME_DAY t ON d.TERM_CODE = t.ACADEMIC_TERM_CODE\nGROUP BY \n    c.IAP_CATEGORY_NAME, t.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor of the independent activity periods, list the sponsor name, number of sessions held, the total number of enrollment, the minimum and maximum fee, the number of sessions with info, and the number of sessions without info.",
        "predicted_sql": "SELECT \n    sp.SPONSOR_NAME,\n    COUNT(DISTINCT s.IAP_SUBJECT_SESSION_KEY) AS number_of_sessions_held,\n    SUM(d.MAX_ENROLLMENT) AS total_enrollment,\n    MIN(d.FEE) AS minimum_fee,\n    MAX(d.FEE) AS maximum_fee,\n    COUNT(CASE WHEN s.HAS_SESSION_INFO = 'Y' THEN 1 END) AS sessions_with_info,\n    COUNT(CASE WHEN s.HAS_SESSION_INFO = 'N' THEN 1 END) AS sessions_without_info\nFROM \n    IAP_SUBJECT_SPONSOR sp\nJOIN \n    IAP_SUBJECT_DETAIL d ON sp.IAP_SUBJECT_SPONSOR_KEY = d.IAP_SUBJECT_SPONSOR_KEY\nJOIN \n    IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    sp.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the individual's email and name, academic year, total number of IAP subjects, the minimum and maximum fees, and the total course enrollment for each individual and academic year?",
        "predicted_sql": "SELECT \n    p.PERSON_EMAIL AS email,\n    p.PERSON_NAME AS name,\n    t.ACADEMIC_YEAR AS academic_year,\n    COUNT(DISTINCT d.ACTIVITY_TITLE) AS total_number_of_iap_subjects,\n    MIN(d.FEE) AS min_fee,\n    MAX(d.FEE) AS max_fee,\n    SUM(d.MAX_ENROLLMENT) AS total_course_enrollment\nFROM IAP_SUBJECT_DETAIL d\nJOIN IAP_SUBJECT_PERSON p ON d.IAP_SUBJECT_PERSON_KEY = p.IAP_SUBJECT_PERSON_KEY\nJOIN TIME_DAY t ON d.TERM_CODE = t.ACADEMIC_TERM_CODE\nGROUP BY p.PERSON_EMAIL, p.PERSON_NAME, t.ACADEMIC_YEAR\nORDER BY p.PERSON_EMAIL, t.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "What is the term code, term description, total number of IAP sessions, total fee collected, and minimum and maximum enrollment for each term code?",
        "predicted_sql": "SELECT \n    ata.TERM_CODE,\n    ata.TERM_DESCRIPTION,\n    COUNT(DISTINCT iss.IAP_SUBJECT_SESSION_KEY) AS total_number_of_iap_sessions,\n    SUM(isd.FEE) AS total_fee_collected,\n    MIN(isd.MAX_ENROLLMENT) AS minimum_enrollment,\n    MAX(isd.MAX_ENROLLMENT) AS maximum_enrollment\nFROM ACADEMIC_TERMS_ALL ata\nJOIN IAP_SUBJECT_DETAIL isd ON ata.TERM_CODE = isd.TERM_CODE\nJOIN IAP_SUBJECT_SESSION iss ON isd.IAP_SUBJECT_SESSION_KEY = iss.IAP_SUBJECT_SESSION_KEY\nGROUP BY ata.TERM_CODE, ata.TERM_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building, total number of subjects, total fee, and shortest and longest sessions for each physical IAP session location?",
        "predicted_sql": "SELECT \n  B.BUILDING_NAME,\n  COUNT(DISTINCT SD.IAP_SUBJECT_CATEGORY_KEY) AS total_subjects,\n  (\n    SELECT SUM(FEE) \n    FROM (\n      SELECT DISTINCT SD2.IAP_SUBJECT_CATEGORY_KEY, SD2.FEE\n      FROM IAP_SUBJECT_SESSION SS2\n      JOIN BUILDINGS B2 ON SS2.SESSION_LOCATION = B2.BUILDING_NUMBER\n      JOIN IAP_SUBJECT_DETAIL SD2 ON SS2.IAP_SUBJECT_SESSION_KEY = SD2.IAP_SUBJECT_SESSION_KEY\n      WHERE B2.BUILDING_NUMBER = B.BUILDING_NUMBER\n    )\n  ) AS total_fee,\n  MIN(\n    ( \n      CASE \n        WHEN SUBSTR(SS.SESSION_END_TIME,5,2) = 'AM' AND CAST(SUBSTR(SS.SESSION_END_TIME,1,2) AS INTEGER) = 12 THEN 0\n        WHEN SUBSTR(SS.SESSION_END_TIME,5,2) = 'AM' THEN CAST(SUBSTR(SS.SESSION_END_TIME,1,2) AS INTEGER)\n        WHEN SUBSTR(SS.SESSION_END_TIME,5,2) = 'PM' AND CAST(SUBSTR(SS.SESSION_END_TIME,1,2) AS INTEGER) = 12 THEN 12\n        ELSE CAST(SUBSTR(SS.SESSION_END_TIME,1,2) AS INTEGER) + 12\n      END * 60 + CAST(SUBSTR(SS.SESSION_END_TIME,3,2) AS INTEGER)\n    ) - \n    ( \n      CASE \n        WHEN SUBSTR(SS.SESSION_START_TIME,5,2) = 'AM' AND CAST(SUBSTR(SS.SESSION_START_TIME,1,2) AS INTEGER) = 12 THEN 0\n        WHEN SUBSTR(SS.SESSION_START_TIME,5,2) = 'AM' THEN CAST(SUBSTR(SS.SESSION_START_TIME,1,2) AS INTEGER)\n        WHEN SUBSTR(SS.SESSION_START_TIME,5,2) = 'PM' AND CAST(SUBSTR(SS.SESSION_START_TIME,1,2) AS INTEGER) = 12 THEN 12\n        ELSE CAST(SUBSTR(SS.SESSION_START_TIME,1,2) AS INTEGER) + 12\n      END * 60 + CAST(SUBSTR(SS.SESSION_START_TIME,3,2) AS INTEGER)\n    )\n  ) AS shortest_session_minutes,\n  MAX(\n    ( \n      CASE \n        WHEN SUBSTR(SS.SESSION_END_TIME,5,2) = 'AM' AND CAST(SUBSTR(SS.SESSION_END_TIME,1,2) AS INTEGER) = 12 THEN 0\n        WHEN SUBSTR(SS.SESSION_END_TIME,5,2) = 'AM' THEN CAST(SUBSTR(SS.SESSION_END_TIME,1,2) AS INTEGER)\n        WHEN SUBSTR(SS.SESSION_END_TIME,5,2) = 'PM' AND CAST(SUBSTR(SS.SESSION_END_TIME,1,2) AS INTEGER) = 12 THEN 12\n        ELSE CAST(SUBSTR(SS.SESSION_END_TIME,1,2) AS INTEGER) + 12\n      END * 60 + CAST(SUBSTR(SS.SESSION_END_TIME,3,2) AS INTEGER)\n    ) - \n    ( \n      CASE \n        WHEN SUBSTR(SS.SESSION_START_TIME,5,2) = 'AM' AND CAST(SUBSTR(SS.SESSION_START_TIME,1,2) AS INTEGER) = 12 THEN 0\n        WHEN SUBSTR(SS.SESSION_START_TIME,5,2) = 'AM' THEN CAST(SUBSTR(SS.SESSION_START_TIME,1,2) AS INTEGER)\n        WHEN SUBSTR(SS.SESSION_START_TIME,5,2) = 'PM' AND CAST(SUBSTR(SS.SESSION_START_TIME,1,2) AS INTEGER) = 12 THEN 12\n        ELSE CAST(SUBSTR(SS.SESSION_START_TIME,1,2) AS INTEGER) + 12\n      END * 60 + CAST(SUBSTR(SS.SESSION_START_TIME,3,2) AS INTEGER)\n    )\n  ) AS longest_session_minutes\nFROM IAP_SUBJECT_SESSION SS\nJOIN BUILDINGS B ON SS.SESSION_LOCATION = B.BUILDING_NUMBER\nJOIN IAP_SUBJECT_DETAIL SD ON SS.IAP_SUBJECT_SESSION_KEY = SD.IAP_SUBJECT_SESSION_KEY\nGROUP BY B.BUILDING_NUMBER, B.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is total number of subjects, the total fee, and the shortest and longest sessions, for all virtual IAP sessions?",
        "predicted_sql": "SELECT \n    COUNT(DISTINCT sd.ACTIVITY_TITLE) AS total_number_of_subjects,\n    SUM(sd.FEE) AS total_fee,\n    MIN(\n        (CASE \n            WHEN SUBSTR(ss.SESSION_END_TIME, -2) = 'PM' AND CAST(SUBSTR(ss.SESSION_END_TIME, 1, LENGTH(ss.SESSION_END_TIME)-2) AS INTEGER) < 1200 \n            THEN CAST(SUBSTR(ss.SESSION_END_TIME, 1, LENGTH(ss.SESSION_END_TIME)-2) AS INTEGER) + 1200\n            ELSE CAST(SUBSTR(ss.SESSION_END_TIME, 1, LENGTH(ss.SESSION_END_TIME)-2) AS INTEGER)\n        END) - \n        (CASE \n            WHEN SUBSTR(ss.SESSION_START_TIME, -2) = 'PM' AND CAST(SUBSTR(ss.SESSION_START_TIME, 1, LENGTH(ss.SESSION_START_TIME)-2) AS INTEGER) < 1200 \n            THEN CAST(SUBSTR(ss.SESSION_START_TIME, 1, LENGTH(ss.SESSION_START_TIME)-2) AS INTEGER) + 1200\n            ELSE CAST(SUBSTR(ss.SESSION_START_TIME, 1, LENGTH(ss.SESSION_START_TIME)-2) AS INTEGER)\n        END)\n    ) AS shortest_session_minutes,\n    MAX(\n        (CASE \n            WHEN SUBSTR(ss.SESSION_END_TIME, -2) = 'PM' AND CAST(SUBSTR(ss.SESSION_END_TIME, 1, LENGTH(ss.SESSION_END_TIME)-2) AS INTEGER) < 1200 \n            THEN CAST(SUBSTR(ss.SESSION_END_TIME, 1, LENGTH(ss.SESSION_END_TIME)-2) AS INTEGER) + 1200\n            ELSE CAST(SUBSTR(ss.SESSION_END_TIME, 1, LENGTH(ss.SESSION_END_TIME)-2) AS INTEGER)\n        END) - \n        (CASE \n            WHEN SUBSTR(ss.SESSION_START_TIME, -2) = 'PM' AND CAST(SUBSTR(ss.SESSION_START_TIME, 1, LENGTH(ss.SESSION_START_TIME)-2) AS INTEGER) < 1200 \n            THEN CAST(SUBSTR(ss.SESSION_START_TIME, 1, LENGTH(ss.SESSION_START_TIME)-2) AS INTEGER) + 1200\n            ELSE CAST(SUBSTR(ss.SESSION_START_TIME, 1, LENGTH(ss.SESSION_START_TIME)-2) AS INTEGER)\n        END)\n    ) AS longest_session_minutes\nFROM IAP_SUBJECT_SESSION ss\nINNER JOIN IAP_SUBJECT_DETAIL sd ON ss.IAP_SUBJECT_SESSION_KEY = sd.IAP_SUBJECT_SESSION_KEY\nWHERE ss.SESSION_LOCATION LIKE '%http%' OR ss.SESSION_LOCATION LIKE '%zoom%' OR ss.SESSION_LOCATION LIKE '%online%' OR ss.SESSION_LOCATION = 'On line';"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, full name of the department, course level, total number of courses, and total number of degree-granting courses for each school code, department, and course level?",
        "predicted_sql": "SELECT \n    sc.SCHOOL_CODE,\n    sc.SCHOOL_NAME,\n    sd.DEPARTMENT_FULL_NAME,\n    cd.COURSE_LEVEL,\n    COUNT(cd.COURSE) AS total_number_of_courses,\n    SUM(CASE WHEN cd.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS total_number_of_degree_granting_courses\nFROM \n    SIS_COURSE_DESCRIPTION cd\nJOIN \n    SIS_DEPARTMENT sd ON cd.DEPARTMENT = sd.DEPARTMENT_CODE\nJOIN \n    SIS_SUBJECT_CODE sc ON cd.COURSE = sc.SUBJECT_CODE\nGROUP BY \n    sc.SCHOOL_CODE,\n    sd.DEPARTMENT_FULL_NAME,\n    cd.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What are the different schools and departments that offer SIS courses? List their school code, school name, department code, department name, the total number of phone numbers, and the most common course level.",
        "predicted_sql": "SELECT \n    ssc.SCHOOL_CODE,\n    ssc.SCHOOL_NAME,\n    sd.DEPARTMENT_CODE,\n    sad.SIS_ADMIN_DEPARTMENT_NAME AS DEPARTMENT_NAME,\n    COUNT(DISTINCT sad.DEPARTMENT_PHONE_NUMBER) AS TOTAL_PHONE_NUMBERS,\n    (\n        SELECT COURSE_LEVEL \n        FROM SIS_COURSE_DESCRIPTION scd2 \n        WHERE scd2.DEPARTMENT = sd.DEPARTMENT_CODE \n        GROUP BY COURSE_LEVEL \n        ORDER BY COUNT(*) DESC \n        LIMIT 1\n    ) AS MOST_COMMON_COURSE_LEVEL\nFROM SIS_ADMIN_DEPARTMENT sad\nJOIN SIS_DEPARTMENT sd ON sad.SIS_ADMIN_DEPARTMENT_CODE = sd.DEPARTMENT_CODE\nJOIN SIS_COURSE_DESCRIPTION scd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT\nJOIN SIS_SUBJECT_CODE ssc ON scd.COURSE = ssc.SUBJECT_CODE\nGROUP BY \n    ssc.SCHOOL_CODE,\n    ssc.SCHOOL_NAME,\n    sd.DEPARTMENT_CODE,\n    sad.SIS_ADMIN_DEPARTMENT_NAME\nORDER BY \n    ssc.SCHOOL_CODE,\n    sd.DEPARTMENT_CODE;"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, DLC key, the graduate level, total number of SIS subjects, the minimum and maximum course numbers, and the total number of departments offering subjects for each school?",
        "predicted_sql": "SELECT\n    ssc.SCHOOL_CODE,\n    ssc.SCHOOL_NAME,\n    MIN(sd.DLC_KEY) AS DLC_KEY,\n    MIN(scd.GRADUATE_LEVEL) AS GRADUATE_LEVEL,\n    COUNT(DISTINCT ssc.SUBJECT_CODE) AS TOTAL_SIS_SUBJECTS,\n    MIN(ssc.COURSE_NUMBER) AS MIN_COURSE_NUMBER,\n    MAX(ssc.COURSE_NUMBER) AS MAX_COURSE_NUMBER,\n    COUNT(DISTINCT sd.DEPARTMENT_CODE) AS TOTAL_DEPARTMENTS\nFROM SIS_SUBJECT_CODE ssc\nJOIN SIS_COURSE_DESCRIPTION scd ON ssc.SUBJECT_CODE = scd.COURSE\nJOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE\nGROUP BY ssc.SCHOOL_CODE, ssc.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the building component, name of the building, square footage for all rooms, total number of floors, total number of rooms, total number of facility organizations, total number of supervisors, and total number of supervisees for each building component?",
        "predicted_sql": "WITH building_agg AS (\n    SELECT \n        sd.BUILDING_COMPONENT,\n        MAX(b.BUILDING_NAME) as BUILDING_NAME,\n        SUM(sd.ROOM_SQUARE_FOOTAGE) as total_sqft,\n        COUNT(DISTINCT sf.FLOOR) as total_floors,\n        COUNT(DISTINCT sd.BUILDING_ROOM) as total_rooms,\n        COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) as total_orgs\n    FROM SPACE_DETAIL sd\n    LEFT JOIN BUILDINGS b ON sd.BUILDING_COMPONENT = b.BUILDING_KEY\n    LEFT JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY\n    LEFT JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY\n    GROUP BY sd.BUILDING_COMPONENT\n),\nsupervisor_agg AS (\n    SELECT \n        sd.BUILDING_COMPONENT,\n        COUNT(DISTINCT ssu.MIT_ID) as total_supervisors,\n        SUM(ssu.NUM_OF_SUPERVISEES) as total_supervisees\n    FROM SPACE_DETAIL sd\n    LEFT JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY\n    LEFT JOIN SPACE_SUPERVISOR_USAGE ssu ON ssu.DEPT_NAMES LIKE '%' || su.DLC_KEY || '%'\n    GROUP BY sd.BUILDING_COMPONENT\n)\nSELECT \n    ba.BUILDING_COMPONENT as \"building component\",\n    ba.BUILDING_NAME as \"name of the building\",\n    ba.total_sqft as \"square footage for all rooms\",\n    ba.total_floors as \"total number of floors\",\n    ba.total_rooms as \"total number of rooms\",\n    ba.total_orgs as \"total number of facility organizations\",\n    sa.total_supervisors as \"total number of supervisors\",\n    sa.total_supervisees as \"total number of supervisees\"\nFROM building_agg ba\nLEFT JOIN supervisor_agg sa ON ba.BUILDING_COMPONENT = sa.BUILDING_COMPONENT;"
    },
    {
        "db_id": "dw",
        "question": "What is the DLC key, name of the DLC, total number of floors, total square footage, total number of facility organizations, total number of supervisors, total number of supervisees, and total building heights for each DLC?",
        "predicted_sql": "WITH dlc_list AS (\n    SELECT DISTINCT \n        su.DLC_KEY,\n        fo.DLC_NAME\n    FROM SPACE_UNIT su\n    LEFT JOIN FCLT_ORGANIZATION fo ON su.DLC_KEY = fo.DLC_KEY\n),\nspace_agg AS (\n    SELECT \n        su.DLC_KEY,\n        COUNT(DISTINCT sf.FLOOR_KEY) AS total_floors,\n        SUM(sd.ROOM_SQUARE_FOOTAGE) AS total_square_footage,\n        COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS total_facility_organizations\n    FROM SPACE_UNIT su\n    LEFT JOIN SPACE_DETAIL sd ON su.SPACE_UNIT_KEY = sd.SPACE_UNIT_KEY\n    LEFT JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY\n    GROUP BY su.DLC_KEY\n),\nbuilding_heights_agg AS (\n    SELECT \n        su.DLC_KEY,\n        SUM(CAST(fb.BUILDING_HEIGHT AS DECIMAL(10,2))) AS total_building_heights\n    FROM SPACE_UNIT su\n    JOIN SPACE_DETAIL sd ON su.SPACE_UNIT_KEY = sd.SPACE_UNIT_KEY\n    JOIN FCLT_BUILDING fb ON sd.BUILDING_KEY = fb.FCLT_BUILDING_KEY\n    GROUP BY su.DLC_KEY\n),\nsupervisor_agg AS (\n    SELECT \n        su.DLC_KEY,\n        COUNT(DISTINCT ssu.MIT_ID) AS total_supervisors,\n        SUM(ssu.NUM_OF_SUPERVISEES) AS total_supervisees\n    FROM SPACE_UNIT su\n    LEFT JOIN SPACE_SUPERVISOR_USAGE ssu ON FIND_IN_SET(su.DLC_KEY, ssu.DEPT_NAMES) > 0\n    GROUP BY su.DLC_KEY\n)\nSELECT \n    dl.DLC_KEY,\n    dl.DLC_NAME,\n    COALESCE(sa.total_floors, 0) AS total_floors,\n    COALESCE(sa.total_square_footage, 0) AS total_square_footage,\n    COALESCE(sa.total_facility_organizations, 0) AS total_facility_organizations,\n    COALESCE(sua.total_supervisors, 0) AS total_supervisors,\n    COALESCE(sua.total_supervisees, 0) AS total_supervisees,\n    COALESCE(bha.total_building_heights, 0) AS total_building_heights\nFROM dlc_list dl\nLEFT JOIN space_agg sa ON dl.DLC_KEY = sa.DLC_KEY\nLEFT JOIN building_heights_agg bha ON dl.DLC_KEY = bha.DLC_KEY\nLEFT JOIN supervisor_agg sua ON dl.DLC_KEY = sua.DLC_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What is the department name, total number of types of TIP subjects, total number of enrolled students, the minimum and maximum rental new price for each department?",
        "predicted_sql": "SELECT \n    tso.OFFER_DEPT_NAME AS department_name,\n    COUNT(DISTINCT tso.SUBJECT_ID) AS total_tip_subjects,\n    SUM(tso.NUM_ENROLLED_STUDENTS) AS total_enrolled_students,\n    MIN(tm.RENTAL_NEW_PRICE) AS min_rental_new_price,\n    MAX(tm.RENTAL_NEW_PRICE) AS max_rental_new_price\nFROM \n    TIP_SUBJECT_OFFERED tso\nJOIN \n    TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nGROUP BY \n    tso.OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the details of courses offered in the current academic term, including the academic year, term code, hgn code, the total number of types of courses, the average number of units, the department name, the name and email address of the person in charge?",
        "predicted_sql": "SELECT\n    c.ACADEMIC_YEAR,\n    c.TERM_CODE,\n    s.HGN_CODE,\n    COUNT(DISTINCT c.SUBJECT_ID) AS total_course_types,\n    AVG(c.TOTAL_UNITS) AS avg_units,\n    c.DEPARTMENT_NAME,\n    e.FULL_NAME AS person_in_charge_name,\n    e.EMAIL_ADDRESS\nFROM\n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN\n    ACADEMIC_TERMS a ON c.TERM_CODE = a.TERM_CODE\nJOIN\n    SUBJECT_OFFERED s ON c.SUBJECT_ID = s.SUBJECT_ID\nJOIN\n    EMPLOYEE_DIRECTORY e ON s.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nWHERE\n    a.IS_CURRENT_TERM = 'Y'\nGROUP BY\n    c.ACADEMIC_YEAR,\n    c.TERM_CODE,\n    s.HGN_CODE,\n    c.DEPARTMENT_NAME,\n    e.FULL_NAME,\n    e.EMAIL_ADDRESS;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve information about the IAP subjects, including their titles, categories, session titles, session start time, session end time, sponsor names, and total number of sessions.",
        "predicted_sql": "SELECT \n    sd.ACTIVITY_TITLE,\n    sc.IAP_CATEGORY_NAME,\n    ss.SESSION_TITLE,\n    ss.SESSION_START_TIME,\n    ss.SESSION_END_TIME,\n    sp.SPONSOR_NAME,\n    COUNT(*) OVER (PARTITION BY sd.ACTIVITY_TITLE) AS total_number_of_sessions\nFROM IAP_SUBJECT_DETAIL sd\nJOIN IAP_SUBJECT_CATEGORY sc ON sd.IAP_SUBJECT_CATEGORY_KEY = sc.IAP_SUBJECT_CATEGORY_KEY\nJOIN IAP_SUBJECT_SESSION ss ON sd.IAP_SUBJECT_SESSION_KEY = ss.IAP_SUBJECT_SESSION_KEY\nJOIN IAP_SUBJECT_SPONSOR sp ON sd.IAP_SUBJECT_SPONSOR_KEY = sp.IAP_SUBJECT_SPONSOR_KEY"
    },
    {
        "db_id": "dw",
        "question": "Show the department names, the corresponding SIS subject code, subject code descriptions, graduate level, and the total number of courses per department.",
        "predicted_sql": "SELECT \n    d.DEPARTMENT_NAME,\n    sc.SUBJECT_CODE,\n    sc.SUBJECT_CODE_DESC,\n    cd.GRADUATE_LEVEL,\n    COUNT(sc.COURSE_NUMBER) AS total_courses\nFROM SIS_COURSE_DESCRIPTION cd\nJOIN SIS_DEPARTMENT d ON cd.DEPARTMENT = d.DEPARTMENT_CODE\nJOIN SIS_SUBJECT_CODE sc ON sc.COURSE_NUMBER = cd.COURSE\nGROUP BY d.DEPARTMENT_NAME, sc.SUBJECT_CODE, sc.SUBJECT_CODE_DESC, cd.GRADUATE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "For each term, list the term code, the term description, whether the term is current or not, and the total number of types of CIS courses.",
        "predicted_sql": "SELECT \n    a.TERM_CODE,\n    a.TERM_DESCRIPTION,\n    p.IS_CURRENT_TERM,\n    COUNT(DISTINCT c.SUBJECT_ID) AS total_cis_courses\nFROM \n    ACADEMIC_TERMS_ALL a\nLEFT JOIN \n    ACADEMIC_TERM_PARAMETER p ON a.TERM_CODE = p.TERM_CODE\nLEFT JOIN \n    CIS_COURSE_CATALOG c ON a.ACADEMIC_YEAR = c.ACADEMIC_YEAR \n    AND (\n        (a.TERM_CODE LIKE '%FA' AND c.IS_OFFERED_FALL_TERM = 'Y') OR\n        (a.TERM_CODE LIKE '%SP' AND c.IS_OFFERED_SPRING_TERM = 'Y') OR\n        (a.TERM_CODE LIKE '%SU' AND c.IS_OFFERED_SUMMER_TERM = 'Y') OR\n        (a.TERM_CODE LIKE '%JA' AND c.IS_OFFERED_IAP = 'Y')\n    )\nGROUP BY \n    a.TERM_CODE, a.TERM_DESCRIPTION, p.IS_CURRENT_TERM;"
    },
    {
        "db_id": "dw",
        "question": "What is the author, school name, material status, total record counts, and total number of types of courses for each author and school?",
        "predicted_sql": "SELECT \n    tm.AUTHOR,\n    sd.SCHOOL_NAME,\n    tms.TIP_MATERIAL_STATUS AS MATERIAL_STATUS,\n    SUM(td.RECORD_COUNT) AS TOTAL_RECORD_COUNTS,\n    COUNT(DISTINCT td.SUBJECT_ID) AS TOTAL_NUMBER_OF_TYPES_OF_COURSES\nFROM TIP_DETAIL td\nJOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nJOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nJOIN STUDENT_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE\nGROUP BY tm.AUTHOR, sd.SCHOOL_NAME, tms.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is the course number, subject title, material status, the total, min, and max new shelf price, the total, min, and max used shelf price, total number of schools and the total number of materials for each TIP subject and material status?",
        "predicted_sql": "SELECT \n    tso.COURSE_NUMBER,\n    tso.SUBJECT_TITLE,\n    tms.TIP_MATERIAL_STATUS,\n    SUM(tm.NEW_SHELF_PRICE) AS total_new_shelf_price,\n    MIN(tm.NEW_SHELF_PRICE) AS min_new_shelf_price,\n    MAX(tm.NEW_SHELF_PRICE) AS max_new_shelf_price,\n    SUM(tm.USED_SHELF_PRICE) AS total_used_shelf_price,\n    MIN(tm.USED_SHELF_PRICE) AS min_used_shelf_price,\n    MAX(tm.USED_SHELF_PRICE) AS max_used_shelf_price,\n    COUNT(DISTINCT tso.OFFER_SCHOOL_NAME) AS total_schools,\n    COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS total_materials\nFROM TIP_DETAIL td\nJOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nJOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nGROUP BY tso.COURSE_NUMBER, tso.SUBJECT_TITLE, tms.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is material status, the total number of materials, the total number of subjects, the total number of schools, and the most recent publication year for each material status?",
        "predicted_sql": "SELECT \n    tms.TIP_MATERIAL_STATUS AS material_status,\n    COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS total_materials,\n    COUNT(DISTINCT td.SUBJECT_ID) AS total_subjects,\n    COUNT(DISTINCT sd.SCHOOL_NAME) AS total_schools,\n    MAX(tm.YEAR) AS most_recent_publication_year\nFROM TIP_DETAIL td\nJOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nJOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nJOIN STUDENT_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE\nGROUP BY tms.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is the term description, whether the term is current or not, total number of types of TIP subjects offered and materials needed, the minimum and maximum number of enrolled students, the total number of schools offering subjects, and the total number of records for each term code?",
        "predicted_sql": "SELECT \n    ata.TERM_CODE,\n    ata.TERM_DESCRIPTION,\n    ata.IS_CURRENT_TERM,\n    COUNT(DISTINCT tso.SUBJECT_ID) AS total_tip_subjects,\n    COUNT(DISTINCT tm.ISBN) AS total_materials_needed,\n    MIN(tso.NUM_ENROLLED_STUDENTS) AS min_enrolled_students,\n    MAX(tso.NUM_ENROLLED_STUDENTS) AS max_enrolled_students,\n    COUNT(DISTINCT tso.OFFER_SCHOOL_NAME) AS total_schools_offering,\n    SUM(td.RECORD_COUNT) AS total_records\nFROM ACADEMIC_TERMS_ALL ata\nLEFT JOIN TIP_SUBJECT_OFFERED tso ON ata.TERM_CODE = tso.TERM_CODE\nLEFT JOIN TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nLEFT JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nGROUP BY ata.TERM_CODE, ata.TERM_DESCRIPTION, ata.IS_CURRENT_TERM\nORDER BY ata.TERM_CODE;"
    },
    {
        "db_id": "dw",
        "question": "List all buildings with their names, building numbers, building height, street address, city, state, HR department name, assignable square footage, total and average square footage, ordered in descending order of assignable, total, and average square footage.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME,\n    b.BUILDING_NUMBER,\n    fb.BUILDING_HEIGHT,\n    b.BUILDING_STREET_ADDRESS,\n    fba.CITY,\n    fba.STATE,\n    MAX(fo.HR_DEPARTMENT_NAME) AS HR_DEPARTMENT_NAME,\n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE,\n    SUM(CAST(fr.AREA AS DECIMAL(10,2))) AS total_square_footage,\n    AVG(CAST(fr.AREA AS DECIMAL(10,2))) AS average_square_footage\nFROM \n    BUILDINGS b\n    JOIN FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY\n    JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY\n    JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY\n    JOIN FAC_BUILDING_ADDRESS fba ON b.BUILDING_KEY = fba.BUILDING_KEY\nWHERE \n    fba.ADDRESS_PURPOSE = 'STREET'\nGROUP BY \n    b.BUILDING_KEY,\n    b.BUILDING_NAME,\n    b.BUILDING_NUMBER,\n    fb.BUILDING_HEIGHT,\n    b.BUILDING_STREET_ADDRESS,\n    fba.CITY,\n    fba.STATE,\n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE\nORDER BY \n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE DESC,\n    total_square_footage DESC,\n    average_square_footage DESC;"
    },
    {
        "db_id": "dw",
        "question": "For the 2023 Fall term, what are the unique term descriptions, subject titles along with their prerequisites, total number of types of subjects per term code, instructor of this course, and the number of types of courses ever taught by the instructor?",
        "predicted_sql": "SELECT \n    at.TERM_DESCRIPTION,\n    cc.SUBJECT_TITLE,\n    cc.PREREQUISITES,\n    (SELECT COUNT(DISTINCT SUBJECT_ID) FROM COURSE_CATALOG_SUBJECT_OFFERED WHERE TERM_CODE = '2023FA') AS total_subjects_per_term,\n    cc.FALL_INSTRUCTORS AS instructor,\n    (SELECT COUNT(DISTINCT SUBJECT_ID) FROM COURSE_CATALOG_SUBJECT_OFFERED WHERE FALL_INSTRUCTORS = cc.FALL_INSTRUCTORS) AS courses_taught_by_instructor\nFROM COURSE_CATALOG_SUBJECT_OFFERED cc\nJOIN ACADEMIC_TERMS at ON cc.TERM_CODE = at.TERM_CODE\nWHERE cc.TERM_CODE = '2023FA';"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the assignable floor area and building.",
        "predicted_sql": "SELECT \n    r.ROOM_FULL_NAME,\n    b.BUILDING_NAME,\n    f.FLOOR,\n    o.ORGANIZATION_NAME,\n    o.HR_DEPARTMENT_NAME,\n    r.AREA AS room_area,\n    (CAST(r.AREA AS REAL) / CAST(f.ASSIGNABLE_AREA AS REAL)) * 100 AS percentage_over_floor_area,\n    (CAST(r.AREA AS REAL) / CAST(b.ASSIGNABLE_AREA AS REAL)) * 100 AS percentage_over_building_area\nFROM FAC_ROOMS r\nJOIN FAC_BUILDING b ON r.BUILDING_KEY = b.FAC_BUILDING_KEY\nJOIN FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nJOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the floor area and building.",
        "predicted_sql": "SELECT \n    r.ROOM_FULL_NAME,\n    b.BUILDING_NAME,\n    f.FLOOR,\n    o.ORGANIZATION_NAME,\n    o.HR_DEPARTMENT_NAME,\n    r.AREA AS Room_Area,\n    (r.AREA / f.EXT_GROSS_AREA) * 100 AS Floor_Area_Percentage,\n    (r.AREA / b.EXT_GROSS_AREA) * 100 AS Building_Area_Percentage\nFROM \n    FAC_ROOMS r\nJOIN \n    FAC_BUILDING b ON r.BUILDING_KEY = b.FAC_BUILDING_KEY\nJOIN \n    FAC_FLOOR f ON r.BUILDING_KEY = f.BUILDING_KEY AND r.FLOOR_KEY = f.FLOOR_KEY\nJOIN \n    FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What are the academic year, and instructors names for courses offered in the academic year 2022, along with the total number of types of courses per instructor?",
        "predicted_sql": "SELECT \n    ata.ACADEMIC_YEAR,\n    ed.FULL_NAME AS instructor_name,\n    COUNT(DISTINCT so.COURSE_NUMBER) AS total_course_types\nFROM SUBJECT_OFFERED so\nJOIN ACADEMIC_TERMS_ALL ata ON so.TERM_CODE = ata.TERM_CODE\nJOIN EMPLOYEE_DIRECTORY ed ON so.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID\nWHERE ata.ACADEMIC_YEAR = '2022'\nGROUP BY ata.ACADEMIC_YEAR, ed.FULL_NAME\nORDER BY total_course_types DESC;"
    },
    {
        "db_id": "dw",
        "question": "What are the building names, department names, organizations, their highest and lowest floor number, along with the total number of rooms per each building key?",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME,\n    GROUP_CONCAT(DISTINCT o.HR_DEPARTMENT_NAME) AS department_names,\n    GROUP_CONCAT(DISTINCT o.ORGANIZATION) AS organizations,\n    MAX(CAST(f.LEVEL_ID AS UNSIGNED)) AS highest_floor,\n    MIN(CAST(f.LEVEL_ID AS UNSIGNED)) AS lowest_floor,\n    COUNT(DISTINCT r.FAC_ROOM_KEY) AS total_rooms\nFROM FAC_BUILDING b\nJOIN FAC_ROOMS r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY\nJOIN FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nJOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\nGROUP BY b.FAC_BUILDING_KEY, b.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Provide the complete information for students with the first name Kevin, including their full names, email addresses, department names, department phone numbers, school names, and the total student count per department and school. If a student is associated with more than one department, list a separate row for each department.",
        "predicted_sql": "SELECT \n    MSD.FULL_NAME,\n    MSD.EMAIL_ADDRESS,\n    SD.DEPARTMENT_NAME,\n    SAD.DEPARTMENT_PHONE_NUMBER,\n    SD.SCHOOL_NAME,\n    C.student_count AS total_student_count\nFROM MIT_STUDENT_DIRECTORY MSD\nJOIN SIS_DEPARTMENT SD ON MSD.DEPARTMENT = SD.DEPARTMENT_CODE\nJOIN SIS_ADMIN_DEPARTMENT SAD ON SAD.SIS_ADMIN_DEPARTMENT_CODE = SD.DEPARTMENT_CODE\nJOIN (\n    SELECT SD.DEPARTMENT_CODE, SD.SCHOOL_CODE, COUNT(DISTINCT MSD.EMAIL_ADDRESS) AS student_count\n    FROM MIT_STUDENT_DIRECTORY MSD\n    JOIN SIS_DEPARTMENT SD ON MSD.DEPARTMENT = SD.DEPARTMENT_CODE\n    WHERE MSD.FIRST_NAME = 'Kevin'\n    GROUP BY SD.DEPARTMENT_CODE, SD.SCHOOL_CODE\n) C ON SD.DEPARTMENT_CODE = C.DEPARTMENT_CODE AND SD.SCHOOL_CODE = C.SCHOOL_CODE\nWHERE MSD.FIRST_NAME = 'Kevin';"
    },
    {
        "db_id": "dw",
        "question": "What are the unique titles of subjects offered in the fall term along with their instructor names, instructor emails, and the total number of types of subjects per instructor?",
        "predicted_sql": "SELECT DISTINCT \n    c.SUBJECT_TITLE,\n    e.FULL_NAME,\n    e.EMAIL_ADDRESS,\n    cnt.total_subject_types\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\n    JOIN ACADEMIC_TERMS_ALL a ON c.TERM_CODE = a.TERM_CODE\n    JOIN EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\n    JOIN (\n        SELECT \n            e.MIT_ID,\n            COUNT(DISTINCT c.SUBJECT_TITLE) AS total_subject_types\n        FROM \n            COURSE_CATALOG_SUBJECT_OFFERED c\n            JOIN ACADEMIC_TERMS_ALL a ON c.TERM_CODE = a.TERM_CODE\n            JOIN EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\n        WHERE \n            a.TERM_CODE LIKE '%FA'\n        GROUP BY \n            e.MIT_ID\n    ) cnt ON e.MIT_ID = cnt.MIT_ID\nWHERE \n    a.TERM_CODE LIKE '%FA';"
    },
    {
        "db_id": "dw",
        "question": "List the building names, names of HR departments occupying them, the total gross square footage, the total and average assignable square footage, and the built year per building key.",
        "predicted_sql": "SELECT \n    B.BUILDING_NAME,\n    GROUP_CONCAT(DISTINCT O.HR_DEPARTMENT_NAME) AS HR_Departments,\n    B.BLDG_GROSS_SQUARE_FOOTAGE AS Total_Gross_Square_Footage,\n    B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE AS Total_Assignable_Square_Footage,\n    B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE / NULLIF(CAST(FB.NUM_OF_ROOMS AS UNSIGNED), 0) AS Average_Assignable_Square_Footage,\n    YEAR(STR_TO_DATE(FB.DATE_BUILT, '%m/%d/%Y')) AS Built_Year\nFROM \n    BUILDINGS B\nJOIN \n    FAC_BUILDING FB ON B.BUILDING_KEY = FB.FAC_BUILDING_KEY\nJOIN \n    FAC_ROOMS FR ON B.BUILDING_KEY = FR.BUILDING_KEY\nJOIN \n    FAC_ORGANIZATION O ON FR.ORGANIZATION_KEY = O.ORGANIZATION_KEY\nGROUP BY \n    B.BUILDING_KEY, \n    B.BUILDING_NAME, \n    B.BLDG_GROSS_SQUARE_FOOTAGE, \n    B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE, \n    FB.NUM_OF_ROOMS, \n    FB.DATE_BUILT;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve the titles of subjects offered in the summer term along with their descriptions, responsible faculty names, email address, building name, room name, floor level, building street address, and the total number of types of courses per departmnet.",
        "predicted_sql": "SELECT \n    C.SUBJECT_TITLE,\n    C.SUBJECT_DESCRIPTION,\n    C.RESPONSIBLE_FACULTY_NAME,\n    E.EMAIL_ADDRESS,\n    B.BUILDING_NAME,\n    FR.ROOM_FULL_NAME,\n    FF.LEVEL_ID,\n    FBA.STREET_NUMBER || ' ' || FBA.STREET_NAME || ' ' || FBA.STREET_SUFFIX || ', ' || FBA.CITY || ', ' || FBA.STATE || ' ' || FBA.POSTAL_CODE AS BUILDING_STREET_ADDRESS,\n    COUNT(DISTINCT C.SUBJECT_ID) OVER (PARTITION BY C.DEPARTMENT_CODE) AS TOTAL_COURSE_TYPES_PER_DEPARTMENT\nFROM COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN ACADEMIC_TERMS A ON C.TERM_CODE = A.TERM_CODE\nJOIN EMPLOYEE_DIRECTORY E ON C.RESPONSIBLE_FACULTY_MIT_ID = E.MIT_ID\nJOIN FAC_ROOMS FR ON C.MEET_PLACE = FR.FAC_ROOM_KEY\nJOIN FAC_FLOOR FF ON FR.FLOOR_KEY = FF.FLOOR_KEY\nJOIN BUILDINGS B ON FR.BUILDING_KEY = B.BUILDING_KEY\nJOIN FAC_BUILDING_ADDRESS FBA ON FR.BUILDING_KEY = FBA.BUILDING_KEY AND FBA.ADDRESS_PURPOSE = 'STREET'\nWHERE A.TERM_CODE LIKE '%SU%';"
    },
    {
        "db_id": "dw",
        "question": "For each term code, list the term description, attribute desciption, department name, school name, and the number of subjects in the area of humanities, arts and social sciences.",
        "predicted_sql": "SELECT \n    ACADEMIC_TERMS_ALL.TERM_CODE,\n    ACADEMIC_TERMS_ALL.TERM_DESCRIPTION,\n    COURSE_CATALOG_SUBJECT_OFFERED.HASS_ATTRIBUTE_DESC,\n    SIS_DEPARTMENT.DEPARTMENT_NAME,\n    SIS_DEPARTMENT.SCHOOL_NAME,\n    COUNT(DISTINCT COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID) AS NUMBER_OF_SUBJECTS\nFROM ACADEMIC_TERMS_ALL\nJOIN COURSE_CATALOG_SUBJECT_OFFERED ON ACADEMIC_TERMS_ALL.TERM_CODE = COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE\nJOIN SIS_DEPARTMENT ON COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_CODE = SIS_DEPARTMENT.DEPARTMENT_CODE\nJOIN CIS_HASS_ATTRIBUTE ON COURSE_CATALOG_SUBJECT_OFFERED.HASS_ATTRIBUTE = CIS_HASS_ATTRIBUTE.HASS_ATTRIBUTE\nWHERE CIS_HASS_ATTRIBUTE.CIS_ATTRIBUTE_GROUP = 'H'\nGROUP BY \n    ACADEMIC_TERMS_ALL.TERM_CODE,\n    ACADEMIC_TERMS_ALL.TERM_DESCRIPTION,\n    COURSE_CATALOG_SUBJECT_OFFERED.HASS_ATTRIBUTE_DESC,\n    SIS_DEPARTMENT.DEPARTMENT_NAME,\n    SIS_DEPARTMENT.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List building names, their height, street address, city, state, postal code, their gross and assignable square footage, the smallest and largest floor level and the total area of all rooms for each building key.",
        "predicted_sql": "SELECT \n    FB.BUILDING_NAME,\n    FB.BUILDING_HEIGHT,\n    B.BUILDING_STREET_ADDRESS,\n    FBA.CITY,\n    FBA.STATE,\n    FBA.POSTAL_CODE,\n    FB.EXT_GROSS_AREA,\n    FB.ASSIGNABLE_AREA,\n    MIN(CAST(FF.LEVEL_ID AS UNSIGNED)) AS smallest_floor_level,\n    MAX(CAST(FF.LEVEL_ID AS UNSIGNED)) AS largest_floor_level,\n    SUM(CAST(FR.AREA AS DECIMAL(10,2))) AS total_area_of_rooms\nFROM FAC_BUILDING FB\nLEFT JOIN BUILDINGS B ON FB.FAC_BUILDING_KEY = B.BUILDING_KEY\nLEFT JOIN FAC_BUILDING_ADDRESS FBA ON FB.FAC_BUILDING_KEY = FBA.BUILDING_KEY AND FBA.ADDRESS_PURPOSE = 'STREET'\nLEFT JOIN FAC_FLOOR FF ON FB.FAC_BUILDING_KEY = FF.BUILDING_KEY\nLEFT JOIN FAC_ROOMS FR ON FF.FLOOR_KEY = FR.FLOOR_KEY\nGROUP BY FB.FAC_BUILDING_KEY, FB.BUILDING_NAME, FB.BUILDING_HEIGHT, B.BUILDING_STREET_ADDRESS, FBA.CITY, FBA.STATE, FBA.POSTAL_CODE, FB.EXT_GROSS_AREA, FB.ASSIGNABLE_AREA;"
    },
    {
        "db_id": "dw",
        "question": "What is the category title, version, department name, school name, total number of courses for each course level, and the total number of degree-granting courses for each CIP category code?",
        "predicted_sql": "SELECT \n    cip.CATEGORY_CODE,\n    cip.CATEGORY_TITLE,\n    cip.VERSION,\n    sd.DEPARTMENT_NAME,\n    sd.SCHOOL_NAME,\n    scd.COURSE_LEVEL,\n    COUNT(*) AS total_courses,\n    SUM(CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS degree_granting_courses\nFROM \n    SIS_COURSE_DESCRIPTION scd\nJOIN \n    CIP cip ON scd.CIP_PROGRAM_CODE = cip.PROGRAM_CODE\nJOIN \n    SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE\nGROUP BY \n    cip.CATEGORY_CODE,\n    cip.CATEGORY_TITLE,\n    cip.VERSION,\n    sd.DEPARTMENT_NAME,\n    sd.SCHOOL_NAME,\n    scd.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library materials, the minimum and maximum publication years, and the total number of materials status for each course name?",
        "predicted_sql": "SELECT \n    lci.COURSE_NAME,\n    COUNT(DISTINCT lrc.LIBRARY_RESERVE_CATALOG_KEY) AS total_library_materials,\n    MIN(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS min_publication_year,\n    MAX(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS max_publication_year,\n    COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS total_materials_status_count\nFROM LIBRARY_RESERVE_MATRL_DETAIL lrmd\nJOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY lci.COURSE_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library reserve materials, the minimum and maximum publication years, and the total number of enrolled students for each course instructor?",
        "predicted_sql": "SELECT \n  lci.INSTRUCTOR_NAME,\n  COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS total_materials,\n  MIN(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS min_publication_year,\n  MAX(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS max_publication_year,\n  SUM(lso.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\nFROM \n  LIBRARY_COURSE_INSTRUCTOR lci\n  JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\n  JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\n  JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nGROUP BY \n  lci.INSTRUCTOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the material status, term description, total number of courses and materials, occurences in departments and school, and the total number of instructors for each library material status code and term code?",
        "predicted_sql": "SELECT \n    lms.LIBRARY_MATERIAL_STATUS_CODE,\n    ata.TERM_DESCRIPTION,\n    COUNT(DISTINCT lso.COURSE_NUMBER) AS total_courses,\n    COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS total_materials,\n    COUNT(DISTINCT lso.OFFER_DEPT_CODE) AS occurrences_departments,\n    COUNT(DISTINCT lso.OFFER_SCHOOL_NAME) AS occurrences_school,\n    COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS total_instructors\nFROM \n    LIBRARY_MATERIAL_STATUS lms\n    JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lms.LIBRARY_MATERIAL_STATUS_KEY = lrmd.LIBRARY_MATERIAL_STATUS_KEY\n    JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\n    JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY\n    JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\n    JOIN ACADEMIC_TERMS_ALL ata ON lso.TERM_CODE = ata.TERM_CODE\nGROUP BY \n    lms.LIBRARY_MATERIAL_STATUS_CODE,\n    ata.TERM_CODE,\n    ata.TERM_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "For building 36, list all space units, their floor and building name, building street address, their space usage, and the number of organizations and space units on the same building and floor.",
        "predicted_sql": "SELECT \n    su.SPACE_UNIT,\n    sf.FLOOR,\n    b.BUILDING_NAME,\n    CONCAT_WS(' ', fba.STREET_NUMBER, fba.STREET_NAME, fba.STREET_SUFFIX) AS building_street_address,\n    ssu.SPACE_USAGE,\n    ct.org_count,\n    ct.space_unit_count\nFROM \n    SPACE_DETAIL sd\nJOIN \n    BUILDINGS b ON sd.BUILDING_KEY = b.BUILDING_KEY\nJOIN \n    SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY\nJOIN \n    SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY\nJOIN \n    SPACE_USAGE ssu ON sd.SPACE_USAGE_KEY = ssu.SPACE_USAGE_KEY\nLEFT JOIN \n    FCLT_BUILDING_ADDRESS fba ON b.BUILDING_KEY = fba.FCLT_BUILDING_KEY AND fba.ADDRESS_PURPOSE = 'STREET'\nJOIN \n    (\n        SELECT \n            sd_sub.BUILDING_KEY,\n            sd_sub.FLOOR_KEY,\n            COUNT(DISTINCT fo.FCLT_ORGANIZATION_KEY) AS org_count,\n            COUNT(DISTINCT sd_sub.SPACE_UNIT_KEY) AS space_unit_count\n        FROM \n            SPACE_DETAIL sd_sub\n        JOIN \n            SPACE_UNIT su_sub ON sd_sub.SPACE_UNIT_KEY = su_sub.SPACE_UNIT_KEY\n        JOIN \n            FCLT_ORGANIZATION fo ON su_sub.FCLT_ORGANIZATION_KEY = fo.FCLT_ORGANIZATION_KEY\n        GROUP BY \n            sd_sub.BUILDING_KEY, sd_sub.FLOOR_KEY\n    ) ct ON sd.BUILDING_KEY = ct.BUILDING_KEY AND sd.FLOOR_KEY = ct.FLOOR_KEY\nWHERE \n    b.BUILDING_NUMBER = '36'\nORDER BY \n    su.SPACE_UNIT, sf.FLOOR;"
    },
    {
        "db_id": "dw",
        "question": "For each distinct mailing list containing more than 1000 people and with a name starting with A (case insensitive), provide its name, whether it is a mailing list, whether it is a moira group, whether it is a NFS group, the owner of the mailing list, and the number of people in the list.",
        "predicted_sql": "SELECT \n  ml.MOIRA_LIST_NAME,\n  ml.IS_MOIRA_MAILING_LIST,\n  ml.IS_MOIRA_GROUP,\n  ml.IS_NFS_GROUP,\n  MIN(mo.OWNER) AS OWNER,\n  COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS number_of_people\nFROM \n  MOIRA_LIST ml\nJOIN \n  MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n  MOIRA_LIST_OWNER mo ON mld.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY\nWHERE \n  LOWER(ml.MOIRA_LIST_NAME) LIKE 'a%'\nGROUP BY \n  ml.MOIRA_LIST_KEY,\n  ml.MOIRA_LIST_NAME,\n  ml.IS_MOIRA_MAILING_LIST,\n  ml.IS_MOIRA_GROUP,\n  ml.IS_NFS_GROUP\nHAVING \n  COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) > 1000;"
    },
    {
        "db_id": "dw",
        "question": "List the mailing lists with the largest number of members and the least number of members, including their names, owners, public status, hidden status, and number of members in the list. If a mailing list has multiple owners, create a separate entry for each owner. Similarly, if multiple lists share the minimum or maximum member count, include all those lists.",
        "predicted_sql": "WITH list_member_counts AS (\n    SELECT \n        ml.MOIRA_LIST_KEY,\n        COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS num_members\n    FROM MOIRA_LIST ml\n    LEFT JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n    WHERE ml.IS_MOIRA_MAILING_LIST = 'Y'\n    GROUP BY ml.MOIRA_LIST_KEY\n),\nmin_max_counts AS (\n    SELECT \n        MIN(num_members) AS min_count,\n        MAX(num_members) AS max_count\n    FROM list_member_counts\n),\nlist_owners AS (\n    SELECT DISTINCT \n        ml.MOIRA_LIST_KEY,\n        mlo.OWNER\n    FROM MOIRA_LIST ml\n    LEFT JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n    LEFT JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY\n    WHERE ml.IS_MOIRA_MAILING_LIST = 'Y'\n)\nSELECT \n    ml.MOIRA_LIST_NAME AS name,\n    lo.OWNER AS owner,\n    ml.IS_PUBLIC AS public_status,\n    ml.IS_HIDDEN AS hidden_status,\n    lmc.num_members AS number_of_members\nFROM list_member_counts lmc\nINNER JOIN min_max_counts mmc ON lmc.num_members = mmc.min_count OR lmc.num_members = mmc.max_count\nINNER JOIN MOIRA_LIST ml ON lmc.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nLEFT JOIN list_owners lo ON lmc.MOIRA_LIST_KEY = lo.MOIRA_LIST_KEY\nORDER BY lmc.num_members DESC, ml.MOIRA_LIST_NAME, lo.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with C (case insensitive) and containing faculty who teach courses in the summer in financial aid years after 2001, provide the name of the list, the number of people in the list, and the number of faculty in the list.",
        "predicted_sql": "WITH faculty_set AS (\n    SELECT DISTINCT e.MIT_ID\n    FROM EMPLOYEE_DIRECTORY e\n    JOIN COURSE_CATALOG_SUBJECT_OFFERED c ON e.MIT_ID = c.RESPONSIBLE_FACULTY_MIT_ID\n    JOIN ACADEMIC_TERMS a ON c.TERM_CODE = a.TERM_CODE\n    WHERE c.IS_OFFERED_SUMMER_TERM = 'Y'\n    AND CAST(a.FINANCIAL_AID_YEAR AS UNSIGNED) > 2001\n)\nSELECT \n    ml.MOIRA_LIST_NAME AS list_name,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER_MIT_ID) AS number_of_people,\n    COUNT(DISTINCT CASE WHEN mld.MOIRA_LIST_MEMBER_MIT_ID IN (SELECT MIT_ID FROM faculty_set) THEN mld.MOIRA_LIST_MEMBER_MIT_ID END) AS number_of_faculty\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nWHERE LOWER(ml.MOIRA_LIST_NAME) LIKE 'c%'\nGROUP BY ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME\nHAVING number_of_faculty > 0;"
    },
    {
        "db_id": "dw",
        "question": "Regarding the mailing list about duo users, provide the number of students in this list, and the number of departments and schools associated with these students.",
        "predicted_sql": "SELECT \n    COUNT(DISTINCT SE_PERSON.MIT_ID) AS student_count,\n    COUNT(DISTINCT SIS_DEPARTMENT.DEPARTMENT_CODE) AS department_count,\n    COUNT(DISTINCT SIS_DEPARTMENT.SCHOOL_CODE) AS school_count\nFROM MOIRA_LIST\nJOIN MOIRA_LIST_DETAIL ON MOIRA_LIST.MOIRA_LIST_KEY = MOIRA_LIST_DETAIL.MOIRA_LIST_KEY\nJOIN SE_PERSON ON MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER_MIT_ID = SE_PERSON.MIT_ID\nJOIN MIT_STUDENT_DIRECTORY ON SE_PERSON.FULL_NAME = MIT_STUDENT_DIRECTORY.FULL_NAME\nJOIN SIS_DEPARTMENT ON MIT_STUDENT_DIRECTORY.DEPARTMENT = SIS_DEPARTMENT.DEPARTMENT_CODE\nWHERE MOIRA_LIST.MOIRA_LIST_NAME LIKE '%duo users%'\n    AND MOIRA_LIST.IS_MOIRA_MAILING_LIST = 'Y'\n    AND SE_PERSON.IS_ACTIVE = 'Y'\n    AND SE_PERSON.EMPLOYEE_TYPE = 'Student';"
    },
    {
        "db_id": "dw",
        "question": "For faculty who are responsible for courses in 2023 fall term, list the name of mailing lists with ten members that they subscribe to, the number of faculty in these lists, and the number of courses associated with those faculty.",
        "predicted_sql": "WITH ListsWithTenMembers AS (\n    SELECT MOIRA_LIST_KEY\n    FROM MOIRA_LIST_DETAIL\n    GROUP BY MOIRA_LIST_KEY\n    HAVING COUNT(MOIRA_LIST_MEMBER) = 10\n),\nRelevantFaculty AS (\n    SELECT DISTINCT c.RESPONSIBLE_FACULTY_MIT_ID, e.KRB_NAME, e.MIT_ID\n    FROM COURSE_CATALOG_SUBJECT_OFFERED c\n    JOIN EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\n    WHERE c.TERM_CODE = '2023FA'\n)\nSELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(DISTINCT rf.MIT_ID) AS number_of_faculty,\n    COUNT(DISTINCT c.SUBJECT_ID) AS number_of_courses\nFROM ListsWithTenMembers lwtm\nJOIN MOIRA_LIST ml ON lwtm.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY AND ml.IS_MOIRA_MAILING_LIST = 'Y'\nJOIN MOIRA_LIST_DETAIL mld ON lwtm.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN RelevantFaculty rf ON mld.MOIRA_LIST_MEMBER = rf.KRB_NAME\nJOIN COURSE_CATALOG_SUBJECT_OFFERED c ON rf.MIT_ID = c.RESPONSIBLE_FACULTY_MIT_ID AND c.TERM_CODE = '2023FA'\nGROUP BY ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each course instructor in the 'keeper-zephyr' mailing list, provide the name of mailing lists they subscribe to, instructor name, earliest and latest publication years, and total number of enrolled students.",
        "predicted_sql": "WITH instructors_in_kz AS (\n    SELECT sp.MIT_ID, lci.INSTRUCTOR_NAME\n    FROM MOIRA_LIST ml\n    JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n    JOIN SE_PERSON sp ON mld.MOIRA_LIST_MEMBER_MIT_ID = sp.MIT_ID\n    JOIN LIBRARY_COURSE_INSTRUCTOR lci ON sp.FULL_NAME = lci.INSTRUCTOR_NAME\n    WHERE ml.MOIRA_LIST_NAME = 'keeper-zephyr'\n),\nmailing_lists AS (\n    SELECT i.MIT_ID, GROUP_CONCAT(DISTINCT ml.MOIRA_LIST_NAME) AS list_names\n    FROM instructors_in_kz i\n    JOIN MOIRA_LIST_DETAIL mld ON i.MIT_ID = mld.MOIRA_LIST_MEMBER_MIT_ID\n    JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\n    GROUP BY i.MIT_ID\n),\npub_years AS (\n    SELECT i.MIT_ID, \n           MIN(CAST(lrc.CATALOG_YEAR AS INTEGER)) AS earliest_year,\n           MAX(CAST(lrc.CATALOG_YEAR AS INTEGER)) AS latest_year\n    FROM instructors_in_kz i\n    JOIN LIBRARY_COURSE_INSTRUCTOR lci ON i.INSTRUCTOR_NAME = lci.INSTRUCTOR_NAME\n    JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\n    JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\n    WHERE lrc.CATALOG_YEAR IS NOT NULL AND lrc.CATALOG_YEAR != ''\n    GROUP BY i.MIT_ID\n),\nenrolled_students AS (\n    SELECT i.MIT_ID, SUM(lso.NUM_ENROLLED_STUDENTS) AS total_students\n    FROM instructors_in_kz i\n    JOIN LIBRARY_COURSE_INSTRUCTOR lci ON i.INSTRUCTOR_NAME = lci.INSTRUCTOR_NAME\n    JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\n    JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\n    GROUP BY i.MIT_ID\n)\nSELECT i.INSTRUCTOR_NAME, \n       ml.list_names AS mailing_lists,\n       py.earliest_year,\n       py.latest_year,\n       es.total_students\nFROM instructors_in_kz i\nLEFT JOIN mailing_lists ml ON i.MIT_ID = ml.MIT_ID\nLEFT JOIN pub_years py ON i.MIT_ID = py.MIT_ID\nLEFT JOIN enrolled_students es ON i.MIT_ID = es.MIT_ID;"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list with a name beginning with R (case insensitive), and that Professor Ayden Hopkins is subscribed to, list its name, description, owner, number of people in the list, and number of tenured faculty in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME AS name,\n    ml.MOIRA_LIST_DESCRIPTION AS description,\n    mlo.OWNER AS owner,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS total_people,\n    COUNT(DISTINCT CASE WHEN sp.PAYROLL_RANK LIKE '%Tenured%' OR sp.PAYROLL_RANK LIKE '%Professor%' THEN mld.MOIRA_LIST_MEMBER END) AS tenured_faculty_count\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY\nLEFT JOIN SE_PERSON sp ON mld.MOIRA_LIST_MEMBER_MIT_ID = sp.MIT_ID\nWHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'R%'\n    AND ml.IS_MOIRA_MAILING_LIST = 'Y'\n    AND ml.MOIRA_LIST_KEY IN (\n        SELECT DISTINCT mld2.MOIRA_LIST_KEY\n        FROM MOIRA_LIST_DETAIL mld2\n        JOIN SE_PERSON sp2 ON mld2.MOIRA_LIST_MEMBER_MIT_ID = sp2.MIT_ID\n        WHERE sp2.FULL_NAME = 'Hopkins, Ayden'\n    )\nGROUP BY ml.MOIRA_LIST_NAME, ml.MOIRA_LIST_DESCRIPTION, mlo.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For the email list with name 'date-destiny', list the name of the list, department name, the number of students from the Management department, and the percentage of students who are from the Management department, rounded to two decimal places.",
        "predicted_sql": "SELECT \n  ml.MOIRA_LIST_NAME,\n  'Management' AS department_name,\n  COUNT(DISTINCT CASE WHEN sad.SIS_ADMIN_DEPARTMENT_NAME = 'Management' THEN mld.MOIRA_LIST_MEMBER END) AS number_of_management_students,\n  ROUND(COUNT(DISTINCT CASE WHEN sad.SIS_ADMIN_DEPARTMENT_NAME = 'Management' THEN mld.MOIRA_LIST_MEMBER END) * 100.0 / COUNT(DISTINCT mld.MOIRA_LIST_MEMBER), 2) AS percentage\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nLEFT JOIN SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nLEFT JOIN MIT_STUDENT_DIRECTORY msd ON sp.FULL_NAME = msd.FULL_NAME\nLEFT JOIN SIS_ADMIN_DEPARTMENT sad ON msd.DEPARTMENT = sad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE ml.MOIRA_LIST_NAME = 'date-destiny'\nGROUP BY ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For the building with the most floors, list the building name and the names of the mailing lists staring with a (case insensitive) that the building employees with kerberos starting with c (case insensitive) subscribe to.",
        "predicted_sql": "WITH BuildingWithMostFloors AS (\n    SELECT BUILDING_KEY\n    FROM FAC_FLOOR\n    GROUP BY BUILDING_KEY\n    ORDER BY COUNT(DISTINCT LEVEL_ID) DESC\n    LIMIT 1\n)\nSELECT DISTINCT fb.BUILDING_NAME, ml.MOIRA_LIST_NAME\nFROM BuildingWithMostFloors bwmf\nJOIN FAC_BUILDING fb ON bwmf.BUILDING_KEY = fb.FAC_BUILDING_KEY\nJOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY\nJOIN EMPLOYEE_DIRECTORY ed ON fr.FAC_ROOM_KEY = ed.OFFICE_LOCATION\nJOIN MOIRA_LIST_DETAIL mld ON ed.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nWHERE LOWER(ed.KRB_NAME) LIKE 'c%'\n  AND LOWER(ml.MOIRA_LIST_NAME) LIKE 'a%'\n  AND ml.IS_MOIRA_MAILING_LIST = 'Y';"
    },
    {
        "db_id": "dw",
        "question": "For the email lists subscribed by faculty members with last names begin with Y, list the names of the lists, the total number of subjects managed by faculty in those mailing lists, and the number of such faculty in the lists.",
        "predicted_sql": "SELECT ml.MOIRA_LIST_NAME,\n       COUNT(DISTINCT cso.SUBJECT_ID) AS total_subjects,\n       COUNT(DISTINCT ed.MIT_ID) AS faculty_count\nFROM EMPLOYEE_DIRECTORY ed\nJOIN MOIRA_LIST_DETAIL mld ON ed.MIT_ID = mld.MOIRA_LIST_MEMBER_MIT_ID\nJOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nLEFT JOIN COURSE_CATALOG_SUBJECT_OFFERED cso ON ed.MIT_ID = cso.RESPONSIBLE_FACULTY_MIT_ID\nWHERE ed.LAST_NAME LIKE 'Y%'\nGROUP BY ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with H who are subscribed to mailing list 'beacon-date-date', list the names of the students, the phone numbers of departments they belong to, and the size of the mailing list 'beacon-date-date' that they are subscribed to.",
        "predicted_sql": "SELECT \n    msd.FULL_NAME AS student_name,\n    sad.DEPARTMENT_PHONE_NUMBER AS department_phone,\n    (SELECT COUNT(DISTINCT mld_inner.MOIRA_LIST_MEMBER) \n     FROM MOIRA_LIST_DETAIL mld_inner \n     JOIN MOIRA_LIST ml_inner ON mld_inner.MOIRA_LIST_KEY = ml_inner.MOIRA_LIST_KEY \n     WHERE ml_inner.MOIRA_LIST_NAME = 'beacon-date-date') AS mailing_list_size\nFROM MIT_STUDENT_DIRECTORY msd\nJOIN SE_PERSON sp ON msd.FULL_NAME = sp.FULL_NAME\nJOIN MOIRA_LIST_DETAIL mld ON sp.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nJOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nJOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE msd.LAST_NAME LIKE 'H%'\n  AND ml.MOIRA_LIST_NAME = 'beacon-date-date';"
    },
    {
        "db_id": "dw",
        "question": "Give the count of mailing lists with names starting with B that include members from the Electrical Engineering and Computer Science department, along with the name of the list starting with B that have the highest number of members from that department and the corresponding member count.",
        "predicted_sql": "Generated SQL: \nWITH QualifiedLists AS (\n  SELECT DISTINCT ML.MOIRA_LIST_KEY\n  FROM MOIRA_LIST ML\n  JOIN MOIRA_LIST_DETAIL MLD ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\n  JOIN SE_PERSON SP ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME\n  WHERE ML.MOIRA_LIST_NAME LIKE 'B%'\n    AND ML.IS_MOIRA_MAILING_LIST = 'Y'\n    AND SP.ORGANIZATION = 'Electrical Engineering and Computer Science'\n),\nMemberCounts AS (\n  SELECT ML.MOIRA_LIST_KEY, ML.MOIRA_LIST_NAME, COUNT(DISTINCT SP.MIT_ID) as member_count\n  FROM MOIRA_LIST ML\n  JOIN MOIRA_LIST_DETAIL MLD ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\n  JOIN SE_PERSON SP ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME\n  WHERE ML.MOIRA_LIST_NAME LIKE 'B%'\n    AND ML.IS_MOIRA_MAILING_LIST = 'Y'\n    AND SP.ORGANIZATION = 'Electrical Engineering and Computer Science'\n  GROUP BY ML.MOIRA_LIST_KEY, ML.MOIRA_LIST_NAME\n)\nSELECT \n  (SELECT COUNT(*) FROM QualifiedLists) as list_count,\n  (SELECT MOIRA_LIST_NAME FROM MemberCounts ORDER BY member_count DESC LIMIT 1) as top_list_name,\n  (SELECT member_count FROM MemberCounts ORDER BY member_count DESC LIMIT 1) as top_member_count;"
    },
    {
        "db_id": "dw",
        "question": "For the 'kangaroo-inspire-yearn' email list, for each department present in the list, list the department name, the number of students in that department, and its percentage relative to the students in the mailing list.",
        "predicted_sql": "SELECT \n    sad.SIS_ADMIN_DEPARTMENT_NAME AS department_name,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS student_count,\n    ROUND(\n        COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) * 100.0 / \n        (SELECT COUNT(DISTINCT mld_inner.MOIRA_LIST_MEMBER)\n         FROM MOIRA_LIST ml_inner\n         JOIN MOIRA_LIST_DETAIL mld_inner ON ml_inner.MOIRA_LIST_KEY = mld_inner.MOIRA_LIST_KEY\n         WHERE ml_inner.MOIRA_LIST_NAME = 'kangaroo-inspire-yearn'),\n        2\n    ) AS percentage\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN MIT_STUDENT_DIRECTORY msd ON sp.FULL_NAME = msd.FULL_NAME\nJOIN SIS_ADMIN_DEPARTMENT sad ON msd.DEPARTMENT = sad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE ml.MOIRA_LIST_NAME = 'kangaroo-inspire-yearn'\nGROUP BY sad.SIS_ADMIN_DEPARTMENT_CODE, sad.SIS_ADMIN_DEPARTMENT_NAME\nORDER BY student_count DESC;"
    },
    {
        "db_id": "dw",
        "question": "Among the mailing lists subscribed by people with physical offices in building 24, provide the name of the most subscribed mailing list and the total number of subscribers.",
        "predicted_sql": "SELECT \n    ML.MOIRA_LIST_NAME,\n    COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER) AS subscriber_count\nFROM EMPLOYEE_DIRECTORY ED\nJOIN MOIRA_LIST_DETAIL MLD ON ED.KRB_NAME = MLD.MOIRA_LIST_MEMBER\nJOIN MOIRA_LIST ML ON MLD.MOIRA_LIST_KEY = ML.MOIRA_LIST_KEY\nWHERE ED.OFFICE_LOCATION LIKE '24%'\n    AND ML.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY ML.MOIRA_LIST_KEY, ML.MOIRA_LIST_NAME\nORDER BY subscriber_count DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For email lists subscribed by either support staff or faculty, list its name, the number of subscribers that are support staff, the number of subscribers that are faculty, as well as its active status.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(DISTINCT CASE WHEN sp.EMPLOYEE_TYPE = 'Support Staff' THEN sp.MIT_ID END) AS support_staff_count,\n    COUNT(DISTINCT CASE WHEN sp.EMPLOYEE_TYPE = 'Faculty' THEN sp.MIT_ID END) AS faculty_count,\n    ml.IS_ACTIVE\nFROM \n    MOIRA_LIST ml\nINNER JOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nINNER JOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER_MIT_ID = sp.MIT_ID\nWHERE \n    sp.EMPLOYEE_TYPE IN ('Support Staff', 'Faculty')\n    AND ml.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY \n    ml.MOIRA_LIST_NAME, ml.IS_ACTIVE\nHAVING \n    support_staff_count > 0 OR faculty_count > 0\nORDER BY \n    ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For the 'ocean-apple' mailing list, identify the department with the highest student count. Provide the department name, phone number, and the total number of students subscribed to the mailing list from that department. If multiple departments have the same highest count, list each one separately.",
        "predicted_sql": "SELECT \n    sad.SIS_ADMIN_DEPARTMENT_NAME AS department_name,\n    CONCAT(sad.DEPARTMENT_PHONE_AREA_CODE, sad.DEPARTMENT_PHONE_NUMBER) AS phone_number,\n    COUNT(DISTINCT msd.FULL_NAME) AS student_count\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN MIT_STUDENT_DIRECTORY msd ON sp.FULL_NAME = msd.FULL_NAME\nJOIN SIS_ADMIN_DEPARTMENT sad ON msd.DEPARTMENT = sad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE ml.MOIRA_LIST_NAME = 'ocean-apple'\nGROUP BY sad.SIS_ADMIN_DEPARTMENT_CODE, sad.SIS_ADMIN_DEPARTMENT_NAME, phone_number\nHAVING student_count = (\n    SELECT MAX(sub_count) \n    FROM (\n        SELECT COUNT(DISTINCT msd2.FULL_NAME) AS sub_count\n        FROM MOIRA_LIST ml2\n        JOIN MOIRA_LIST_DETAIL mld2 ON ml2.MOIRA_LIST_KEY = mld2.MOIRA_LIST_KEY\n        JOIN SE_PERSON sp2 ON mld2.MOIRA_LIST_MEMBER = sp2.KRB_NAME\n        JOIN MIT_STUDENT_DIRECTORY msd2 ON sp2.FULL_NAME = msd2.FULL_NAME\n        WHERE ml2.MOIRA_LIST_NAME = 'ocean-apple'\n        GROUP BY msd2.DEPARTMENT\n    ) counts\n);"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list, list its owner, owner type, the member visibility ('Public Members' if public, and 'Hidden Members' otherwise), and the number of members of this type of visibility. For each owner and owner type, include a grand total for all members in the format of (owner, owner type, null, total members).",
        "predicted_sql": "SELECT \n    ml_owner.OWNER,\n    ml_owner.OWNER_TYPE,\n    CASE WHEN ml.IS_PUBLIC = 'Y' THEN 'Public Members' ELSE 'Hidden Members' END AS member_visibility,\n    COUNT(*) AS number_of_members\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN MOIRA_LIST_OWNER ml_owner ON mld.MOIRA_LIST_OWNER_KEY = ml_owner.MOIRA_LIST_OWNER_KEY\nWHERE ml.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY ml.MOIRA_LIST_KEY, ml_owner.OWNER, ml_owner.OWNER_TYPE, ml.IS_PUBLIC\nUNION ALL\nSELECT \n    ml_owner.OWNER,\n    ml_owner.OWNER_TYPE,\n    NULL AS member_visibility,\n    COUNT(*) AS number_of_members\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN MOIRA_LIST_OWNER ml_owner ON mld.MOIRA_LIST_OWNER_KEY = ml_owner.MOIRA_LIST_OWNER_KEY\nWHERE ml.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY ml_owner.OWNER, ml_owner.OWNER_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "Group biology courses by cluster type and course level. For each group, list the name of the department, the course title, cluster type, total enrollments, average enrollment within its cluster, course level, number of unique course materials, average new and used prices for TIP materials, total material record count for TIP materials, number of unique library titles, and number of unique library ISBNs.",
        "predicted_sql": "SELECT \n    e.department_name,\n    e.course_title,\n    e.CLUSTER_TYPE,\n    e.total_enrollments,\n    e.avg_enrollment,\n    e.COURSE_LEVEL,\n    COALESCE(t.unique_course_materials, 0) AS unique_course_materials,\n    COALESCE(t.avg_new_price, 0) AS avg_new_price,\n    COALESCE(t.avg_used_price, 0) AS avg_used_price,\n    COALESCE(t.total_record_count, 0) AS total_record_count,\n    COALESCE(t.unique_library_titles, 0) AS unique_library_titles,\n    COALESCE(t.unique_library_isbns, 0) AS unique_library_isbns\nFROM (\n    SELECT \n        SOS.CLUSTER_TYPE,\n        SCD.COURSE_LEVEL,\n        SUM(SOS.NUM_ENROLLED_STUDENTS) AS total_enrollments,\n        AVG(SOS.NUM_ENROLLED_STUDENTS) AS avg_enrollment,\n        GROUP_CONCAT(DISTINCT SOS.OFFER_DEPT_NAME) AS department_name,\n        GROUP_CONCAT(DISTINCT SOS.SUBJECT_TITLE) AS course_title\n    FROM SUBJECT_OFFERED_SUMMARY SOS\n    JOIN SIS_COURSE_DESCRIPTION SCD ON SOS.COURSE_NUMBER = SCD.COURSE\n    WHERE SOS.OFFER_DEPT_NAME LIKE '%Biology%'\n    GROUP BY SOS.CLUSTER_TYPE, SCD.COURSE_LEVEL\n) e\nLEFT JOIN (\n    SELECT \n        bc.CLUSTER_TYPE,\n        bc.COURSE_LEVEL,\n        COUNT(DISTINCT tm.TITLE) AS unique_course_materials,\n        AVG(tm.NEW_SHELF_PRICE) AS avg_new_price,\n        AVG(tm.USED_SHELF_PRICE) AS avg_used_price,\n        SUM(td.RECORD_COUNT) AS total_record_count,\n        COUNT(DISTINCT lrc.CATALOG_TITLE) AS unique_library_titles,\n        COUNT(DISTINCT lrc.CATALOG_ISBN) AS unique_library_isbns\n    FROM (\n        SELECT DISTINCT SOS.CLUSTER_TYPE, SCD.COURSE_LEVEL, SOS.SUBJECT_ID, SOS.TERM_CODE\n        FROM SUBJECT_OFFERED_SUMMARY SOS\n        JOIN SIS_COURSE_DESCRIPTION SCD ON SOS.COURSE_NUMBER = SCD.COURSE\n        WHERE SOS.OFFER_DEPT_NAME LIKE '%Biology%'\n    ) bc\n    LEFT JOIN TIP_DETAIL td ON bc.SUBJECT_ID = td.SUBJECT_ID AND bc.TERM_CODE = td.TERM_CODE\n    LEFT JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\n    LEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON td.ISBN = lrc.CATALOG_ISBN\n    GROUP BY bc.CLUSTER_TYPE, bc.COURSE_LEVEL\n) t ON e.CLUSTER_TYPE = t.CLUSTER_TYPE AND e.COURSE_LEVEL = t.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered this year in either the Fall or Spring term, list its department name, school name, subject ID, subject title, course level, total units, the term it is offered ('Spring' for Spring term and 'Fall' for Fall term), term description, the number of distinct instructors teaching in the Fall, and the number of distinct instructors teaching in the Spring.",
        "predicted_sql": "SELECT \n    C.DEPARTMENT_NAME AS department_name,\n    D.SCHOOL_NAME AS school_name,\n    C.SUBJECT_ID AS subject_id,\n    C.SUBJECT_TITLE AS subject_title,\n    S.COURSE_LEVEL AS course_level,\n    C.TOTAL_UNITS AS total_units,\n    CASE \n        WHEN C.TERM_CODE LIKE '%FA' THEN 'Fall' \n        WHEN C.TERM_CODE LIKE '%SP' THEN 'Spring' \n    END AS term_offered,\n    A.TERM_DESCRIPTION AS term_description,\n    CASE \n        WHEN C.FALL_INSTRUCTORS IS NULL OR C.FALL_INSTRUCTORS = '' THEN 0 \n        ELSE LENGTH(C.FALL_INSTRUCTORS) - LENGTH(REPLACE(C.FALL_INSTRUCTORS, ',', '')) + 1 \n    END AS fall_instructor_count,\n    CASE \n        WHEN C.SPRING_INSTRUCTORS IS NULL OR C.SPRING_INSTRUCTORS = '' THEN 0 \n        ELSE LENGTH(C.SPRING_INSTRUCTORS) - LENGTH(REPLACE(C.SPRING_INSTRUCTORS, ',', '')) + 1 \n    END AS spring_instructor_count\nFROM COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN ACADEMIC_TERMS A ON C.TERM_CODE = A.TERM_CODE\nJOIN SIS_DEPARTMENT D ON C.DEPARTMENT_CODE = D.DEPARTMENT_CODE\nJOIN SIS_COURSE_DESCRIPTION S ON S.COURSE = C.SUBJECT_CODE\nWHERE C.IS_OFFERED_THIS_YEAR = 'Y'\nAND (C.TERM_CODE LIKE '%FA' OR C.TERM_CODE LIKE '%SP');"
    },
    {
        "db_id": "dw",
        "question": "For Political Science courses with HASS attributes, for each attribute, list the name and description of the attribute, the number of unique subjects, average units, the total enrollment, the number of departments that grant degrees, and the subject code description.",
        "predicted_sql": "SELECT \n    c.HASS_ATTRIBUTE AS attribute_name,\n    c.HASS_ATTRIBUTE_DESC AS attribute_description,\n    COUNT(DISTINCT c.SUBJECT_ID) AS number_of_unique_subjects,\n    AVG(CAST(c.TOTAL_UNITS AS DECIMAL)) AS average_units,\n    SUM(s.NUM_ENROLLED_STUDENTS) AS total_enrollment,\n    COUNT(DISTINCT CASE WHEN d.IS_DEGREE_GRANTING = 'Y' THEN d.DEPARTMENT_CODE ELSE NULL END) AS number_of_degree_granting_departments,\n    MIN(sc.SUBJECT_CODE_DESC) AS subject_code_description\nFROM CIS_COURSE_CATALOG c\nJOIN SIS_SUBJECT_CODE sc ON c.SUBJECT_CODE = sc.SUBJECT_CODE\nJOIN SIS_DEPARTMENT d ON sc.DEPARTMENT_CODE = d.DEPARTMENT_CODE\nJOIN SUBJECT_OFFERED_SUMMARY s ON c.SUBJECT_ID = s.SUBJECT_ID\nWHERE d.DEPARTMENT_NAME = 'Political Science'\nAND c.HASS_ATTRIBUTE IS NOT NULL\nGROUP BY c.HASS_ATTRIBUTE, c.HASS_ATTRIBUTE_DESC;"
    },
    {
        "db_id": "dw",
        "question": "Group subjects by cluster type, department offering the subject, and the school name. For each group, list the cluster type, name of the department, school name, whether the department grants degrees, total number of subjects, total enrollment, and average enrollment. Exclude clusters or schools with no student data.",
        "predicted_sql": "SELECT \n    sos.CLUSTER_TYPE,\n    sos.OFFER_DEPT_NAME,\n    sd.SCHOOL_NAME,\n    sd.IS_DEGREE_GRANTING,\n    COUNT(DISTINCT sos.SUBJECT_ID) AS total_subjects,\n    SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollment,\n    AVG(sos.NUM_ENROLLED_STUDENTS) AS average_enrollment\nFROM \n    SUBJECT_OFFERED_SUMMARY sos\nJOIN \n    SIS_COURSE_DESCRIPTION scd ON sos.COURSE_NUMBER = scd.COURSE\nJOIN \n    SIS_DEPARTMENT sd ON sos.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE\nWHERE \n    sos.NUM_ENROLLED_STUDENTS IS NOT NULL \n    AND sos.NUM_ENROLLED_STUDENTS > 0\nGROUP BY \n    sos.CLUSTER_TYPE, \n    sos.OFFER_DEPT_NAME, \n    sd.SCHOOL_NAME, \n    sd.IS_DEGREE_GRANTING\nHAVING \n    SUM(sos.NUM_ENROLLED_STUDENTS) > 0;"
    },
    {
        "db_id": "dw",
        "question": "Group classes that take place in buildings at MIT by the building name and course level. For each group, provide the name of the building, the course level ('Graduate' or 'Undergraduate'), the total number of unique courses of such level, and total instructors for these courses. Include subtotals for each building and course level and a grand total across all buildings and course levels.",
        "predicted_sql": "SELECT \n    IFNULL(FAC_BUILDING.BUILDING_NAME, 'Total') AS building_name,\n    IFNULL(\n        CASE \n            WHEN SIS_COURSE_DESCRIPTION.COURSE_LEVEL = 'G' THEN 'Graduate'\n            WHEN SIS_COURSE_DESCRIPTION.COURSE_LEVEL = 'U' THEN 'Undergraduate'\n            ELSE 'Other' \n        END, 'Total'\n    ) AS course_level,\n    COUNT(DISTINCT SUBJECT_OFFERED.SUBJECT_ID) AS total_unique_courses,\n    COUNT(DISTINCT SUBJECT_OFFERED.RESPONSIBLE_FACULTY_NAME) AS total_instructors\nFROM SUBJECT_OFFERED\nINNER JOIN FAC_BUILDING ON SUBJECT_OFFERED.MEET_PLACE = FAC_BUILDING.FAC_BUILDING_KEY\nINNER JOIN SIS_COURSE_DESCRIPTION ON SUBJECT_OFFERED.COURSE_NUMBER = SIS_COURSE_DESCRIPTION.COURSE\nWHERE FAC_BUILDING.SITE = 'MIT'\nGROUP BY \n    FAC_BUILDING.BUILDING_NAME,\n    CASE \n        WHEN SIS_COURSE_DESCRIPTION.COURSE_LEVEL = 'G' THEN 'Graduate'\n        WHEN SIS_COURSE_DESCRIPTION.COURSE_LEVEL = 'U' THEN 'Undergraduate'\n        ELSE 'Other' \n    END\nWITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each course, provide the room number of course location, building name, building number, building city, building state, area, organization name, room usage, term code, course level, the total number of subjects, unique meeting times, and total units. Do not include meet place or meet times with NULL values.",
        "predicted_sql": "SELECT \n    FR.ROOM AS room_number,\n    FB.BUILDING_NAME,\n    FB.BUILDING_NUMBER,\n    FBA.CITY AS building_city,\n    FBA.STATE AS building_state,\n    FR.AREA,\n    FR.ORGANIZATION_NAME,\n    FMU.MAJOR_USE AS room_usage,\n    C.TERM_CODE,\n    SCD.COURSE_LEVEL,\n    COUNT(DISTINCT C.SUBJECT_ID) AS total_subjects,\n    COUNT(DISTINCT C.MEET_TIME) AS unique_meeting_times,\n    SUM(C.TOTAL_UNITS) AS total_units\nFROM COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN FAC_ROOMS FR ON C.MEET_PLACE = FR.FAC_ROOM_KEY\nJOIN FAC_BUILDING FB ON FR.BUILDING_KEY = FB.FAC_BUILDING_KEY\nJOIN FAC_MAJOR_USE FMU ON FR.MAJOR_USE_KEY = FMU.MAJOR_USE_KEY\nJOIN FAC_BUILDING_ADDRESS FBA ON FB.FAC_BUILDING_KEY = FBA.BUILDING_KEY\nJOIN SIS_COURSE_DESCRIPTION SCD ON C.SUBJECT_ID = SCD.COURSE\nWHERE C.MEET_PLACE IS NOT NULL \n  AND C.MEET_TIME IS NOT NULL\nGROUP BY \n    FR.ROOM,\n    FB.BUILDING_NAME,\n    FB.BUILDING_NUMBER,\n    FBA.CITY,\n    FBA.STATE,\n    FR.AREA,\n    FR.ORGANIZATION_NAME,\n    FMU.MAJOR_USE,\n    C.TERM_CODE,\n    SCD.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "Consider only books cataloged on or after 2000. For each library material status and department, list the material status, department name, number of associated catalog items, and the total number of enrolled students in courses using those materials. Include subtotals for each material status and a grand total across all status (the corresponding status field is 'Grand Total').",
        "predicted_sql": "SELECT \n    COALESCE(lms.LIBRARY_MATERIAL_STATUS, 'Grand Total') AS material_status,\n    ssc.DEPARTMENT_NAME,\n    COUNT(DISTINCT lrc.LIBRARY_RESERVE_CATALOG_KEY) AS catalog_item_count,\n    SUM(DISTINCT lso.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\nFROM \n    LIBRARY_RESERVE_CATALOG lrc\nINNER JOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd \n    ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY\nINNER JOIN \n    LIBRARY_MATERIAL_STATUS lms \n    ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nINNER JOIN \n    LIBRARY_SUBJECT_OFFERED lso \n    ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nINNER JOIN \n    SIS_SUBJECT_CODE ssc \n    ON lso.COURSE_NUMBER = ssc.COURSE_NUMBER\nWHERE \n    CAST(lrc.CATALOG_YEAR AS UNSIGNED) >= 2000\nGROUP BY \n    lms.LIBRARY_MATERIAL_STATUS, ssc.DEPARTMENT_NAME \nWITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each department in the library system, list the name of the department, total number of courses using library materials, the number of catalog items associated with those courses, and the average enrollment per course. Include a grand total across all departments (the corresponding department field should be 'Grand Total').",
        "predicted_sql": "WITH department_stats AS (\n    SELECT \n        i.DEPARTMENT,\n        COUNT(DISTINCT i.LIBRARY_COURSE_INSTRUCTOR_KEY) AS total_courses,\n        COUNT(DISTINCT r.LIBRARY_RESERVE_CATALOG_KEY) AS total_catalog_items,\n        AVG(s.NUM_ENROLLED_STUDENTS) AS avg_enrollment\n    FROM LIBRARY_COURSE_INSTRUCTOR i\n    JOIN LIBRARY_RESERVE_MATRL_DETAIL m \n        ON i.LIBRARY_COURSE_INSTRUCTOR_KEY = m.LIBRARY_COURSE_INSTRUCTOR_KEY\n    JOIN LIBRARY_RESERVE_CATALOG r \n        ON m.LIBRARY_RESERVE_CATALOG_KEY = r.LIBRARY_RESERVE_CATALOG_KEY\n    JOIN LIBRARY_SUBJECT_OFFERED s \n        ON m.LIBRARY_SUBJECT_OFFERED_KEY = s.LIBRARY_SUBJECT_OFFERED_KEY\n    GROUP BY i.DEPARTMENT\n)\nSELECT \n    DEPARTMENT AS department_name,\n    total_courses,\n    total_catalog_items,\n    ROUND(avg_enrollment, 2) AS average_enrollment_per_course\nFROM department_stats\n\nUNION ALL\n\nSELECT \n    'Grand Total',\n    SUM(total_courses),\n    SUM(total_catalog_items),\n    ROUND(AVG(avg_enrollment), 2)\nFROM department_stats\n\nORDER BY department_name = 'Grand Total', department_name;"
    },
    {
        "db_id": "dw",
        "question": "For each department and school offering courses with materials, list the department name, school name, number of unique course materials, number of courses, average new and used shelf prices of materials, total material records, and number of distinct material statuses. Include a grand total across all schools and departments (the corresponding school and department fields should be null).",
        "predicted_sql": "SELECT \n    SIS_DEPARTMENT.SCHOOL_NAME,\n    TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME AS DEPARTMENT_NAME,\n    COUNT(DISTINCT TIP_MATERIAL.TIP_MATERIAL_KEY) AS UNIQUE_MATERIALS,\n    COUNT(DISTINCT TIP_SUBJECT_OFFERED.SUBJECT_ID) AS NUMBER_OF_COURSES,\n    AVG(TIP_MATERIAL.NEW_SHELF_PRICE) AS AVG_NEW_PRICE,\n    AVG(TIP_MATERIAL.USED_SHELF_PRICE) AS AVG_USED_PRICE,\n    SUM(TIP_DETAIL.RECORD_COUNT) AS TOTAL_RECORDS,\n    COUNT(DISTINCT TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS) AS DISTINCT_STATUSES\nFROM TIP_DETAIL\nJOIN TIP_MATERIAL ON TIP_DETAIL.TIP_MATERIAL_KEY = TIP_MATERIAL.TIP_MATERIAL_KEY\nJOIN TIP_SUBJECT_OFFERED ON TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY = TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY\nJOIN TIP_MATERIAL_STATUS ON TIP_DETAIL.TIP_MATERIAL_STATUS_KEY = TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY\nJOIN SIS_DEPARTMENT ON TIP_SUBJECT_OFFERED.OFFER_DEPT_CODE = SIS_DEPARTMENT.DEPARTMENT_CODE\nWHERE TIP_SUBJECT_OFFERED.IS_NO_COURSE_MATERIAL = 'N'\nGROUP BY SIS_DEPARTMENT.SCHOOL_NAME, TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME WITH ROLLUP\nORDER BY SIS_DEPARTMENT.SCHOOL_NAME, TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each TIP material status, list the total number of unique materials associated with the status, the total number of records associated with the status, and the total student enrollment associated with the status. Any material status with null values should be displayed as 'No material status'. Additionally, include a grand total across all material status (the material status for this row should be displayed as 'Grand Total').",
        "predicted_sql": "SELECT\n    COALESCE(tms.TIP_MATERIAL_STATUS, 'No material status') AS material_status,\n    COUNT(DISTINCT tm.TITLE) AS unique_materials_count,\n    SUM(td.RECORD_COUNT) AS total_records,\n    SUM(tso.NUM_ENROLLED_STUDENTS) AS total_student_enrollment\nFROM TIP_DETAIL td\nLEFT JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nLEFT JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nGROUP BY tms.TIP_MATERIAL_STATUS\n\nUNION ALL\n\nSELECT\n    'Grand Total' AS material_status,\n    COUNT(DISTINCT tm.TITLE) AS unique_materials_count,\n    SUM(td.RECORD_COUNT) AS total_records,\n    SUM(tso.NUM_ENROLLED_STUDENTS) AS total_student_enrollment\nFROM TIP_DETAIL td\nLEFT JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nLEFT JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY;"
    },
    {
        "db_id": "dw",
        "question": "For each room, list its associated building name, floor number, room number, ownership type, organization name, number of rooms, area, and percentage of area relative to the building. Include subtotals across floors, subtotals across all floors for each building, and a grand total across all buildings. For the subtotal for each building and the grand total, the percentage of area should be relative to area of all buildings. All numeric values should be rounded to integers and formatted using commas as thousands separators except the relative percentages which should be rounded to two decimal places.",
        "predicted_sql": "WITH base_data AS (\n    SELECT \n        b.BUILDING_NAME_LONG,\n        b.OWNERSHIP_TYPE,\n        f.FLOOR,\n        r.BUILDING_ROOM,\n        o.ORGANIZATION_NAME,\n        r.AREA,\n        r.FCLT_ROOM_KEY,\n        b.FCLT_BUILDING_KEY\n    FROM FCLT_ROOMS r\n    JOIN FCLT_FLOOR f ON r.FCLT_FLOOR_KEY = f.FCLT_FLOOR_KEY\n    JOIN FCLT_BUILDING b ON f.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\n    JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY\n),\naggregated AS (\n    SELECT \n        BUILDING_NAME_LONG,\n        FLOOR,\n        BUILDING_ROOM,\n        OWNERSHIP_TYPE,\n        ORGANIZATION_NAME,\n        COUNT(FCLT_ROOM_KEY) AS num_of_rooms,\n        SUM(AREA) AS area,\n        FCLT_BUILDING_KEY,\n        SUM(SUM(AREA)) OVER (PARTITION BY FCLT_BUILDING_KEY) AS building_total_area,\n        SUM(SUM(AREA)) OVER () AS grand_total_area\n    FROM base_data\n    GROUP BY GROUPING SETS (\n        (BUILDING_NAME_LONG, FLOOR, BUILDING_ROOM, OWNERSHIP_TYPE, ORGANIZATION_NAME, FCLT_BUILDING_KEY),\n        (BUILDING_NAME_LONG, FLOOR, FCLT_BUILDING_KEY),\n        (BUILDING_NAME_LONG, FCLT_BUILDING_KEY),\n        ()\n    )\n)\nSELECT \n    CASE \n        WHEN BUILDING_NAME_LONG IS NULL THEN 'Grand Total'\n        ELSE BUILDING_NAME_LONG \n    END AS building_name,\n    CASE \n        WHEN FLOOR IS NULL AND BUILDING_ROOM IS NULL AND BUILDING_NAME_LONG IS NOT NULL THEN 'Building Subtotal'\n        WHEN BUILDING_ROOM IS NULL AND FLOOR IS NOT NULL THEN CONCAT('Floor ', FLOOR, ' Subtotal')\n        ELSE FLOOR \n    END AS floor_number,\n    CASE \n        WHEN BUILDING_ROOM IS NULL THEN NULL \n        ELSE BUILDING_ROOM \n    END AS room_number,\n    CASE \n        WHEN BUILDING_ROOM IS NULL THEN NULL \n        ELSE OWNERSHIP_TYPE \n    END AS ownership_type,\n    CASE \n        WHEN BUILDING_ROOM IS NULL THEN NULL \n        ELSE ORGANIZATION_NAME \n    END AS organization_name,\n    FORMAT(ROUND(num_of_rooms), 0) AS num_of_rooms,\n    FORMAT(ROUND(area), 0) AS area,\n    CASE \n        WHEN BUILDING_ROOM IS NOT NULL THEN \n            ROUND((area / building_total_area) * 100, 2)\n        WHEN FLOOR IS NOT NULL AND BUILDING_ROOM IS NULL THEN \n            ROUND((area / building_total_area) * 100, 2)\n        WHEN BUILDING_NAME_LONG IS NOT NULL AND FLOOR IS NULL AND BUILDING_ROOM IS NULL THEN \n            ROUND((area / grand_total_area) * 100, 2)\n        ELSE \n            ROUND((area / grand_total_area) * 100, 2)\n    END AS percentage\nFROM aggregated\nORDER BY \n    CASE WHEN BUILDING_NAME_LONG IS NULL THEN 1 ELSE 0 END,\n    BUILDING_NAME_LONG,\n    CASE WHEN FLOOR IS NULL THEN 1 ELSE 0 END,\n    FLOOR,\n    CASE WHEN BUILDING_ROOM IS NULL THEN 1 ELSE 0 END,\n    BUILDING_ROOM;"
    },
    {
        "db_id": "dw",
        "question": "For each financial aid year and academic year, list the number of fiscal periods, quarters, the start term date, the end term date, and number of distinct department-level term parameters.",
        "predicted_sql": "SELECT \n    AT.FINANCIAL_AID_YEAR,\n    AT.ACADEMIC_YEAR,\n    COUNT(DISTINCT TM.FISCAL_PERIOD) AS number_of_fiscal_periods,\n    COUNT(DISTINCT TQ.FY_QUARTER_CODE) AS number_of_quarters,\n    MIN(TD.START_DATE) AS start_term_date,\n    MAX(TD.END_DATE) AS end_term_date,\n    COUNT(DISTINCT ATP.TERM_PARAMETER) AS number_of_distinct_term_parameters\nFROM ACADEMIC_TERMS AT\nJOIN TIME_DAY TD ON AT.TERM_START_DATE = TD.CALENDAR_DATE\nJOIN TIME_MONTH TM ON TD.FISCAL_PERIOD = TM.FISCAL_PERIOD\nJOIN TIME_QUARTER TQ ON TM.FISCAL_YEAR = TQ.FISCAL_YEAR\nJOIN ACADEMIC_TERM_PARAMETER ATP ON AT.TERM_CODE = ATP.TERM_CODE\nGROUP BY AT.FINANCIAL_AID_YEAR, AT.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "Group buildings by campus sectors. For each group, list the campus sector, name of the building, city and state where the building is located, total number of floors, total assignable area, total number of rooms, total number of organizations, ownership type, and a rank column indicating the order (1-indexed) of this row within each sector based on the descending order of assignable area. Include subtotals for each sector and a grand total across all sectors. The subtotal and grand total only need to computed over the total number of floors and assignable area.",
        "predicted_sql": "WITH BuildingData AS (\n    SELECT \n        B.CAMPUS_SECTOR,\n        B.FCLT_BUILDING_KEY,\n        B.BUILDING_NAME_LONG,\n        MIN(A.CITY) AS CITY,\n        MIN(A.STATE) AS STATE,\n        COUNT(DISTINCT F.FLOOR) AS FLOORS_PER_BUILDING,\n        B.ASSIGNABLE_AREA,\n        COUNT(DISTINCT R.FCLT_ROOM_KEY) AS ROOMS_PER_BUILDING,\n        COUNT(DISTINCT O.FCLT_ORGANIZATION_KEY) AS ORGS_PER_BUILDING,\n        B.OWNERSHIP_TYPE\n    FROM FCLT_BUILDING B\n    LEFT JOIN FCLT_FLOOR F ON B.FCLT_BUILDING_KEY = F.FCLT_BUILDING_KEY\n    LEFT JOIN FCLT_BUILDING_ADDRESS A ON B.FCLT_BUILDING_KEY = A.FCLT_BUILDING_KEY\n    LEFT JOIN FCLT_ROOMS R ON B.FCLT_BUILDING_KEY = R.FCLT_BUILDING_KEY\n    LEFT JOIN FCLT_ORGANIZATION O ON R.FCLT_ORGANIZATION_KEY = O.FCLT_ORGANIZATION_KEY\n    GROUP BY B.FCLT_BUILDING_KEY, B.CAMPUS_SECTOR, B.BUILDING_NAME_LONG, B.ASSIGNABLE_AREA, B.OWNERSHIP_TYPE\n)\nSELECT \n    CASE \n        WHEN GROUPING(BuildingData.CAMPUS_SECTOR) = 1 THEN 'Grand Total'\n        ELSE BuildingData.CAMPUS_SECTOR \n    END AS CAMPUS_SECTOR,\n    CASE \n        WHEN GROUPING(BuildingData.FCLT_BUILDING_KEY) = 1 THEN \n            CASE \n                WHEN GROUPING(BuildingData.CAMPUS_SECTOR) = 1 THEN 'Grand Total'\n                ELSE 'Subtotal' \n            END\n        ELSE BuildingData.BUILDING_NAME_LONG \n    END AS BUILDING_NAME_LONG,\n    CASE WHEN GROUPING(BuildingData.FCLT_BUILDING_KEY) = 1 THEN NULL ELSE BuildingData.CITY END AS CITY,\n    CASE WHEN GROUPING(BuildingData.FCLT_BUILDING_KEY) = 1 THEN NULL ELSE BuildingData.STATE END AS STATE,\n    SUM(BuildingData.FLOORS_PER_BUILDING) AS TOTAL_FLOORS,\n    SUM(BuildingData.ASSIGNABLE_AREA) AS TOTAL_ASSIGNABLE_AREA,\n    CASE WHEN GROUPING(BuildingData.FCLT_BUILDING_KEY) = 1 THEN NULL ELSE SUM(BuildingData.ROOMS_PER_BUILDING) END AS TOTAL_ROOMS,\n    CASE WHEN GROUPING(BuildingData.FCLT_BUILDING_KEY) = 1 THEN NULL ELSE SUM(BuildingData.ORGS_PER_BUILDING) END AS TOTAL_ORGANIZATIONS,\n    CASE WHEN GROUPING(BuildingData.FCLT_BUILDING_KEY) = 1 THEN NULL ELSE MIN(BuildingData.OWNERSHIP_TYPE) END AS OWNERSHIP_TYPE,\n    CASE \n        WHEN GROUPING(BuildingData.FCLT_BUILDING_KEY) = 0 THEN \n            ROW_NUMBER() OVER (PARTITION BY BuildingData.CAMPUS_SECTOR ORDER BY BuildingData.ASSIGNABLE_AREA DESC)\n        ELSE NULL \n    END AS RANK\nFROM BuildingData\nGROUP BY BuildingData.CAMPUS_SECTOR, BuildingData.FCLT_BUILDING_KEY\nWITH ROLLUP"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the name of the department, the title of the TIP material associated with the department, author, ISBN, library term code, and whether it is available in the library reserves ('Available in Library' if yes and 'Not Available in Library' otherwise), the total number of instructors per library book for the department, the total number of materials available in the library for the department, and the total number of available materials across all departments.",
        "predicted_sql": "SELECT \n    tso.OFFER_DEPT_NAME AS department_name,\n    tm.TITLE AS tip_material_title,\n    tm.AUTHOR AS author,\n    tm.ISBN AS isbn,\n    lrmd.TERM_CODE AS library_term_code,\n    CASE \n        WHEN lrc.CATALOG_ISBN IS NOT NULL THEN 'Available in Library'\n        ELSE 'Not Available in Library'\n    END AS library_availability,\n    (SELECT COUNT(DISTINCT lrmd2.LIBRARY_COURSE_INSTRUCTOR_KEY) \n     FROM LIBRARY_RESERVE_MATRL_DETAIL lrmd2 \n     WHERE lrmd2.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY) AS instructors_per_book,\n    (SELECT COUNT(DISTINCT lrc2.CATALOG_ISBN) \n     FROM LIBRARY_RESERVE_CATALOG lrc2 \n     INNER JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd3 ON lrmd3.LIBRARY_RESERVE_CATALOG_KEY = lrc2.LIBRARY_RESERVE_CATALOG_KEY\n     INNER JOIN LIBRARY_SUBJECT_OFFERED lso2 ON lso2.LIBRARY_SUBJECT_OFFERED_KEY = lrmd3.LIBRARY_SUBJECT_OFFERED_KEY\n     WHERE lso2.OFFER_DEPT_NAME = tso.OFFER_DEPT_NAME) AS materials_available_in_dept,\n    (SELECT COUNT(DISTINCT lrc3.CATALOG_ISBN) \n     FROM LIBRARY_RESERVE_CATALOG lrc3) AS total_available_materials\nFROM TIP_MATERIAL tm\nINNER JOIN TIP_DETAIL td ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY\nINNER JOIN TIP_SUBJECT_OFFERED tso ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nLEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON lrc.CATALOG_ISBN = tm.ISBN\nLEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nLEFT JOIN LIBRARY_SUBJECT_OFFERED lso ON lso.LIBRARY_SUBJECT_OFFERED_KEY = lrmd.LIBRARY_SUBJECT_OFFERED_KEY\nWHERE tso.IS_NO_COURSE_MATERIAL = 'N'\nGROUP BY tso.OFFER_DEPT_NAME, tm.TITLE, tm.AUTHOR, tm.ISBN, lrmd.TERM_CODE, lrc.CATALOG_ISBN;"
    },
    {
        "db_id": "dw",
        "question": "For each department and material status, list the name of the department, the material status, the number of TIP materials associated with this department and status, the number of library materials associated with this department and status, the total number of TIP and library materials associated with this department and status. Include a subtotal for each department and a grand total across all departments.",
        "predicted_sql": "WITH tip_counts AS (\n    SELECT \n        tso.OFFER_DEPT_NAME AS department_name,\n        tms.TIP_MATERIAL_STATUS AS material_status,\n        COUNT(td.TIP_MATERIAL_KEY) AS tip_count\n    FROM TIP_DETAIL td\n    JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\n    JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\n    GROUP BY tso.OFFER_DEPT_NAME, tms.TIP_MATERIAL_STATUS\n),\nlibrary_counts AS (\n    SELECT \n        lso.OFFER_DEPT_NAME AS department_name,\n        lms.LIBRARY_MATERIAL_STATUS AS material_status,\n        COUNT(lrd.LIBRARY_RESERVE_CATALOG_KEY) AS library_count\n    FROM LIBRARY_RESERVE_MATRL_DETAIL lrd\n    JOIN LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\n    JOIN LIBRARY_MATERIAL_STATUS lms ON lrd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\n    GROUP BY lso.OFFER_DEPT_NAME, lms.LIBRARY_MATERIAL_STATUS\n),\ncombined AS (\n    SELECT \n        COALESCE(t.department_name, l.department_name) AS department_name,\n        COALESCE(t.material_status, l.material_status) AS material_status,\n        COALESCE(t.tip_count, 0) AS tip_count,\n        COALESCE(l.library_count, 0) AS library_count,\n        COALESCE(t.tip_count, 0) + COALESCE(l.library_count, 0) AS total_count\n    FROM tip_counts t\n    FULL OUTER JOIN library_counts l \n        ON t.department_name = l.department_name \n        AND t.material_status = l.material_status\n)\nSELECT \n    department_name,\n    material_status,\n    tip_count,\n    library_count,\n    total_count\nFROM combined\nUNION ALL\nSELECT \n    department_name,\n    'Subtotal' AS material_status,\n    SUM(tip_count) AS tip_count,\n    SUM(library_count) AS library_count,\n    SUM(total_count) AS total_count\nFROM combined\nGROUP BY department_name\nUNION ALL\nSELECT \n    'Grand Total' AS department_name,\n    '' AS material_status,\n    SUM(tip_count) AS tip_count,\n    SUM(library_count) AS library_count,\n    SUM(total_count) AS total_count\nFROM combined\nORDER BY \n    CASE WHEN department_name = 'Grand Total' THEN 2 ELSE 1 END,\n    department_name,\n    CASE WHEN material_status = 'Subtotal' THEN 2 ELSE 1 END,\n    material_status;"
    },
    {
        "db_id": "dw",
        "question": "For each building that is not a subdivision, list the building number, full name, street address, building type, occupancy date, ownership type, and site location. You should also include three rows at the end showing the number of owned, leased, all buildings at MIT that are not subdivisions, in the format of (null, #building Buildings, null, null, null, null, null).",
        "predicted_sql": "SELECT \n  FB.BUILDING_NUMBER,\n  FB.BUILDING_NAME_LONG,\n  B.BUILDING_STREET_ADDRESS,\n  FB.BUILDING_TYPE,\n  FB.DATE_OCCUPIED,\n  FB.OWNERSHIP_TYPE,\n  FB.SITE\nFROM FAC_BUILDING FB\nJOIN BUILDINGS B ON FB.FAC_BUILDING_KEY = B.BUILDING_KEY\nWHERE FB.PARENT_BUILDING_NUMBER IS NULL\nUNION ALL\nSELECT \n  NULL,\n  CAST(COUNT(*) AS VARCHAR) || ' Owned Buildings',\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL\nFROM FAC_BUILDING FB\nJOIN BUILDINGS B ON FB.FAC_BUILDING_KEY = B.BUILDING_KEY\nWHERE FB.PARENT_BUILDING_NUMBER IS NULL AND FB.SITE = 'MIT' AND FB.OWNERSHIP_TYPE = 'OWNED'\nUNION ALL\nSELECT \n  NULL,\n  CAST(COUNT(*) AS VARCHAR) || ' Leased Buildings',\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL\nFROM FAC_BUILDING FB\nJOIN BUILDINGS B ON FB.FAC_BUILDING_KEY = B.BUILDING_KEY\nWHERE FB.PARENT_BUILDING_NUMBER IS NULL AND FB.SITE = 'MIT' AND FB.OWNERSHIP_TYPE = 'LEASED'\nUNION ALL\nSELECT \n  NULL,\n  CAST(COUNT(*) AS VARCHAR) || ' Buildings',\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL\nFROM FAC_BUILDING FB\nJOIN BUILDINGS B ON FB.FAC_BUILDING_KEY = B.BUILDING_KEY\nWHERE FB.PARENT_BUILDING_NUMBER IS NULL AND FB.SITE = 'MIT'\nORDER BY (BUILDING_NUMBER IS NULL), BUILDING_NUMBER;"
    },
    {
        "db_id": "dw",
        "question": "For each owned building that is not a subdivision, list the construction start year, the building number, and the year of initial occupancy. Display the construction start year only if it differs from the previous row. If the year of initial occupancy or construction start year is unknown, display 'UNKNOWN'. You should also include a row at the end showing the total number of owned buildings that are not subdivisions, in the format of (null, #building Buildings, null).",
        "predicted_sql": "WITH filtered_buildings AS (\n    SELECT \n        BUILDING_NUMBER,\n        DATE_BUILT,\n        DATE_OCCUPIED\n    FROM FAC_BUILDING\n    WHERE OWNERSHIP_TYPE = 'OWNED'\n      AND (PARENT_BUILDING_NUMBER IS NULL OR PARENT_BUILDING_NUMBER = '')\n),\nyears AS (\n    SELECT \n        BUILDING_NUMBER,\n        CASE \n            WHEN DATE_BUILT IS NULL OR DATE_BUILT = '' OR STR_TO_DATE(DATE_BUILT, '%m/%d/%Y') IS NULL THEN 'UNKNOWN'\n            ELSE CAST(YEAR(STR_TO_DATE(DATE_BUILT, '%m/%d/%Y')) AS CHAR)\n        END AS construction_year,\n        CASE \n            WHEN DATE_OCCUPIED IS NULL OR DATE_OCCUPIED = '' OR STR_TO_DATE(DATE_OCCUPIED, '%m/%d/%Y') IS NULL THEN 'UNKNOWN'\n            ELSE CAST(YEAR(STR_TO_DATE(DATE_OCCUPIED, '%m/%d/%Y')) AS CHAR)\n        END AS occupancy_year\n    FROM filtered_buildings\n),\nordered_years AS (\n    SELECT \n        BUILDING_NUMBER,\n        construction_year,\n        occupancy_year,\n        LAG(construction_year) OVER (ORDER BY construction_year, BUILDING_NUMBER) AS prev_construction_year\n    FROM years\n)\nSELECT \n    construction_start_year,\n    building_number,\n    year_of_initial_occupancy\nFROM (\n    SELECT \n        1 AS sort_key,\n        CASE \n            WHEN construction_year != prev_construction_year OR prev_construction_year IS NULL THEN construction_year\n            ELSE NULL\n        END AS construction_start_year,\n        BUILDING_NUMBER AS building_number,\n        occupancy_year AS year_of_initial_occupancy\n    FROM ordered_years\n    UNION ALL\n    SELECT \n        2 AS sort_key,\n        NULL,\n        CONCAT((SELECT COUNT(*) FROM filtered_buildings), ' Buildings'),\n        NULL\n) t\nORDER BY sort_key, construction_start_year, building_number;"
    },
    {
        "db_id": "dw",
        "question": "Group all buildings at MIT into either owned or leased. For each group, state the ownership type, usage type, number of buildings, gross square footage, number of rooms, and the number of associated organizations. Display the ownership type only if it differs from the previous row. Include subtotals for each group and a grand total across all groups. The subtotal and grand total rows should not include ownership type and usage type. Footage should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH building_info AS (\n    SELECT \n        FCLT_BUILDING_KEY, \n        MAX(OWNERSHIP_TYPE) as OWNERSHIP_TYPE, \n        MAX(BUILDING_USE) as BUILDING_USE, \n        MAX(EXT_GROSS_AREA) as EXT_GROSS_AREA\n    FROM FCLT_BUILDING_HIST\n    WHERE SITE = 'MIT'\n    GROUP BY FCLT_BUILDING_KEY\n),\nroom_info AS (\n    SELECT \n        R.FCLT_BUILDING_KEY, \n        R.FCLT_ROOM_KEY, \n        O.FCLT_ORGANIZATION_KEY\n    FROM FCLT_ROOMS R\n    LEFT JOIN FCLT_ORGANIZATION O ON R.FCLT_ORGANIZATION_KEY = O.FCLT_ORGANIZATION_KEY\n)\nSELECT \n    CASE \n        WHEN GROUPING(BI.OWNERSHIP_TYPE) = 1 THEN NULL \n        ELSE BI.OWNERSHIP_TYPE \n    END as OWNERSHIP_TYPE,\n    CASE \n        WHEN GROUPING(BI.BUILDING_USE) = 1 THEN NULL \n        ELSE BI.BUILDING_USE \n    END as BUILDING_USE,\n    COUNT(DISTINCT BI.FCLT_BUILDING_KEY) as number_of_buildings,\n    FORMAT(ROUND(SUM(BI.EXT_GROSS_AREA)), 0) as gross_square_footage,\n    COUNT(DISTINCT RI.FCLT_ROOM_KEY) as number_of_rooms,\n    COUNT(DISTINCT RI.FCLT_ORGANIZATION_KEY) as number_of_organizations\nFROM building_info BI\nLEFT JOIN room_info RI ON BI.FCLT_BUILDING_KEY = RI.FCLT_BUILDING_KEY\nGROUP BY BI.OWNERSHIP_TYPE, BI.BUILDING_USE WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each building use, list the type, the number of distinct buildings (excluding subdivisions) of this use, the total gross square footage of these buildings, and the number of unique organizations associated with the rooms in these buildings. If the building is used as a residence, display the usage type as \"RESIDENTIAL.\" You should also include a row at the end showing the total number of buildings, the gross square footage, and the number of organizations across all types of building use. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH parent_building_gross AS (\n  SELECT \n    BUILDING_USE,\n    PARENT_BUILDING_NUMBER,\n    SUM(EXT_GROSS_AREA) AS parent_gross_area\n  FROM FCLT_BUILDING\n  GROUP BY PARENT_BUILDING_NUMBER, BUILDING_USE\n),\nuse_building_stats AS (\n  SELECT \n    BUILDING_USE,\n    COUNT(DISTINCT PARENT_BUILDING_NUMBER) AS num_buildings,\n    ROUND(SUM(parent_gross_area)) AS total_gross_area\n  FROM parent_building_gross\n  GROUP BY BUILDING_USE\n),\nuse_org_stats AS (\n  SELECT \n    b.BUILDING_USE,\n    COUNT(DISTINCT o.FCLT_ORGANIZATION_KEY) AS num_organizations\n  FROM FCLT_BUILDING b\n  JOIN FCLT_ROOMS r ON b.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY\n  JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY\n  GROUP BY b.BUILDING_USE\n),\nper_use AS (\n  SELECT \n    ubs.BUILDING_USE,\n    ubs.num_buildings,\n    ubs.total_gross_area,\n    uos.num_organizations\n  FROM use_building_stats ubs\n  JOIN use_org_stats uos ON ubs.BUILDING_USE = uos.BUILDING_USE\n),\ntotal_stats AS (\n  SELECT \n    'TOTAL' AS BUILDING_USE,\n    (SELECT COUNT(DISTINCT PARENT_BUILDING_NUMBER) FROM FCLT_BUILDING) AS num_buildings,\n    (SELECT ROUND(SUM(EXT_GROSS_AREA)) FROM FCLT_BUILDING) AS total_gross_area,\n    (SELECT COUNT(DISTINCT o.FCLT_ORGANIZATION_KEY)\n     FROM FCLT_ROOMS r\n     JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY) AS num_organizations\n)\nSELECT \n  CASE WHEN BUILDING_USE LIKE '%RES%' THEN 'RESIDENTIAL' ELSE BUILDING_USE END AS use_type,\n  printf(\"%,d\", num_buildings) AS num_buildings,\n  printf(\"%,d\", total_gross_area) AS total_gross_area,\n  printf(\"%,d\", num_organizations) AS num_organizations\nFROM per_use\nUNION ALL\nSELECT \n  'TOTAL' AS use_type,\n  printf(\"%,d\", num_buildings),\n  printf(\"%,d\", total_gross_area),\n  printf(\"%,d\", num_organizations)\nFROM total_stats;"
    },
    {
        "db_id": "dw",
        "question": "For each organization except Cambridge-MIT Institute, list its ID, number, level, formatted name according to level (if level is 2, there should be 1 space before the name, if level is 3, there should be 2 space before the name, up to level 6), whether it is assignable ('ASSIGNABLE' if assignable, 'NON-ASSIGNABLE' otherwise), total area, number of rooms, and average room area. Area and number of rooms should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    o.ORGANIZATION_ID AS ID,\n    o.ORGANIZATION_NUMBER AS number,\n    o.ORGANIZATION_LEVEL AS level,\n    CASE \n        WHEN o.ORGANIZATION_LEVEL = '2' THEN CONCAT(' ', o.ORGANIZATION_NAME)\n        WHEN o.ORGANIZATION_LEVEL = '3' THEN CONCAT('  ', o.ORGANIZATION_NAME)\n        WHEN o.ORGANIZATION_LEVEL = '4' THEN CONCAT('   ', o.ORGANIZATION_NAME)\n        WHEN o.ORGANIZATION_LEVEL = '5' THEN CONCAT('    ', o.ORGANIZATION_NAME)\n        WHEN o.ORGANIZATION_LEVEL = '6' THEN CONCAT('     ', o.ORGANIZATION_NAME)\n        ELSE o.ORGANIZATION_NAME\n    END AS formatted_name,\n    CASE \n        WHEN o.ASSIGNABLE = '1' THEN 'ASSIGNABLE'\n        ELSE 'NON-ASSIGNABLE'\n    END AS assignable,\n    FORMAT(ROUND(SUM(r.AREA)), 0) AS total_area,\n    FORMAT(ROUND(COUNT(r.BUILDING_ROOM)), 0) AS number_of_rooms,\n    ROUND(AVG(r.AREA), 2) AS average_room_area\nFROM FCLT_ORGANIZATION o\nLEFT JOIN FCLT_ROOMS r ON o.FCLT_ORGANIZATION_KEY = r.FCLT_ORGANIZATION_KEY\nWHERE o.ORGANIZATION_NAME != 'Cambridge-MIT Institute'\nGROUP BY o.ORGANIZATION_ID, o.ORGANIZATION_NUMBER, o.ORGANIZATION_LEVEL, o.ORGANIZATION_NAME, o.ASSIGNABLE\nORDER BY o.ORGANIZATION_ID;"
    },
    {
        "db_id": "dw",
        "question": "Group all rooms into whether or not they are assignable and the major use descriptions. For each group, state \"ASSIGNABLE\" if the room is assignable and \"NON-ASSIGNABLE\" otherwise, the major use description, the total number of rooms, total area, and average area. Include subtotals for each group and a grand total across all groups. The assignable status and major use descriptions should only be displayed when they differ from the previous row. Do not include rooms whose major use or major use description starts with 'ZUSE.' The results should be sorted by assignable status and major use description. The subtotal and grand total rows should not include assignable status or major use description.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN GROUPING(assignable_status) = 0 THEN assignable_status \n        ELSE NULL \n    END AS assignable_status,\n    CASE \n        WHEN GROUPING(major_use_desc) = 0 THEN major_use_desc \n        ELSE NULL \n    END AS major_use_desc,\n    COUNT(*) AS total_number_of_rooms,\n    SUM(area) AS total_area,\n    AVG(area) AS average_area\nFROM (\n    SELECT \n        CASE WHEN m.ASSIGNABLE = '1' THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END AS assignable_status,\n        m.DESCRIPTION AS major_use_desc,\n        r.AREA AS area\n    FROM FCLT_ROOMS r\n    JOIN FCLT_MAJOR_USE m ON r.FCLT_MAJOR_USE_KEY = m.FCLT_MAJOR_USE_KEY\n    WHERE NOT (m.MAJOR_USE LIKE 'ZUSE.%' OR m.DESCRIPTION LIKE 'ZUSE.%')\n) AS derived_table\nGROUP BY assignable_status, major_use_desc WITH ROLLUP\nORDER BY assignable_status, major_use_desc;"
    },
    {
        "db_id": "dw",
        "question": "List each floor key and department name within the Stata building, as well as the number of rooms, total area, and average area per department on each floor. Include subtotals for each floor and a grand total across all floors. Sort the results by floor key and department name in ascending order. Exclude departments without any rooms in the building. Only the first row of each floor group should include the floor key, and the subtotal and grand total rows should not include floor key or department name. Number of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH AggData AS (\n    SELECT \n        FR.FLOOR_KEY,\n        FO.ORGANIZATION_NAME,\n        COUNT(FR.FAC_ROOM_KEY) as num_rooms,\n        SUM(CAST(FR.AREA AS DECIMAL(10,2))) as total_area,\n        AVG(CAST(FR.AREA AS DECIMAL(10,2))) as avg_area\n    FROM FAC_ROOMS FR\n    INNER JOIN BUILDINGS B ON FR.BUILDING_KEY = B.BUILDING_KEY\n    INNER JOIN FCLT_ORGANIZATION FO ON FO.FCLT_ORGANIZATION_KEY = FR.ORGANIZATION_KEY\n    WHERE B.BUILDING_NAME = 'Stata building'\n    GROUP BY FR.FLOOR_KEY, FO.ORGANIZATION_NAME\n    WITH ROLLUP\n)\nSELECT \n    CASE \n        WHEN GROUPING(FLOOR_KEY) = 0 AND GROUPING(ORGANIZATION_NAME) = 0 THEN \n            CASE \n                WHEN ROW_NUMBER() OVER (PARTITION BY FLOOR_KEY ORDER BY ORGANIZATION_NAME) = 1 THEN FLOOR_KEY \n                ELSE '' \n            END\n        ELSE '' \n    END as `Floor Key`,\n    CASE \n        WHEN GROUPING(ORGANIZATION_NAME) = 0 THEN ORGANIZATION_NAME \n        ELSE '' \n    END as `Department Name`,\n    FORMAT(num_rooms, 0) as `Number of Rooms`,\n    FORMAT(ROUND(total_area), 0) as `Total Area`,\n    CASE \n        WHEN GROUPING(ORGANIZATION_NAME) = 0 THEN FORMAT(ROUND(avg_area), 0) \n        ELSE '' \n    END as `Average Area`\nFROM AggData\nORDER BY \n    CASE WHEN GROUPING(FLOOR_KEY) = 1 THEN 1 ELSE 0 END,\n    FLOOR_KEY,\n    CASE WHEN GROUPING(ORGANIZATION_NAME) = 1 THEN 1 ELSE 0 END,\n    ORGANIZATION_NAME"
    },
    {
        "db_id": "dw",
        "question": "List each building key and floor key within the department of facilities, the number of rooms, total area, average area per floor, building name, access level, zip code, and city. Include subtotals for each building and a grand total across all buildings. The subtotals and grand total should not include zip code or city. Numbers of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    CASE WHEN GROUPING(r.BUILDING_KEY) = 0 THEN r.BUILDING_KEY ELSE 'Grand Total' END AS building_key,\n    CASE WHEN GROUPING(r.FLOOR_KEY) = 0 THEN r.FLOOR_KEY \n         WHEN GROUPING(r.BUILDING_KEY) = 0 AND GROUPING(r.FLOOR_KEY) = 1 THEN 'Building Subtotal'\n         ELSE '' \n    END AS floor_key,\n    FORMAT(COUNT(r.FAC_ROOM_KEY), 0) AS number_of_rooms,\n    FORMAT(ROUND(SUM(r.AREA)), 0) AS total_area,\n    FORMAT(ROUND(SUM(r.AREA) / NULLIF(COUNT(r.FAC_ROOM_KEY), 0)), 0) AS average_area_per_floor,\n    CASE WHEN GROUPING(r.BUILDING_KEY) = 0 THEN b.BUILDING_NAME_LONG ELSE NULL END AS building_name,\n    CASE WHEN GROUPING(r.BUILDING_KEY) = 0 THEN b.ACCESS_LEVEL_NAME ELSE NULL END AS access_level,\n    CASE WHEN GROUPING(r.FLOOR_KEY) = 0 THEN MIN(a.POSTAL_CODE) ELSE NULL END AS zip_code,\n    CASE WHEN GROUPING(r.FLOOR_KEY) = 0 THEN MIN(a.CITY) ELSE NULL END AS city\nFROM FAC_ROOMS r\nJOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\nJOIN FAC_BUILDING b ON r.BUILDING_KEY = b.FAC_BUILDING_KEY\nJOIN FAC_BUILDING_ADDRESS a ON r.BUILDING_KEY = a.BUILDING_KEY\nWHERE o.ORGANIZATION_NAME = 'Facilities'\nGROUP BY r.BUILDING_KEY, r.FLOOR_KEY, b.BUILDING_NAME_LONG, b.ACCESS_LEVEL_NAME\nWITH ROLLUP\nORDER BY r.BUILDING_KEY, r.FLOOR_KEY;"
    },
    {
        "db_id": "dw",
        "question": "List the department, school, course number, subject title, total number of enrolled students, term code, and count of distinct catalog ISBNs. Add a summary row at the bottom showing the total number of students and distinct catalog ISBNs for the current term in the format of ('TOTAL:', null, null, null, total number of students, null, number of distinct catalog ISBNs).",
        "predicted_sql": "SELECT \n    LSO.OFFER_DEPT_NAME AS department,\n    LSO.OFFER_SCHOOL_NAME AS school,\n    LSO.COURSE_NUMBER AS course_number,\n    LSO.SUBJECT_TITLE AS subject_title,\n    LSO.NUM_ENROLLED_STUDENTS AS total_enrolled_students,\n    LSO.TERM_CODE AS term_code,\n    COUNT(DISTINCT LRC.CATALOG_ISBN) AS distinct_isbn_count,\n    1 AS sort_order\nFROM LIBRARY_SUBJECT_OFFERED LSO\nJOIN LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LSO.LIBRARY_SUBJECT_OFFERED_KEY = LRMD.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN LIBRARY_RESERVE_CATALOG LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\nJOIN ACADEMIC_TERM_PARAMETER ATP ON LSO.TERM_CODE = ATP.TERM_CODE\nWHERE ATP.IS_CURRENT_TERM = 'Y'\nGROUP BY LSO.LIBRARY_SUBJECT_OFFERED_KEY\nUNION ALL\nSELECT \n    'TOTAL:' AS department,\n    NULL AS school,\n    NULL AS course_number,\n    NULL AS subject_title,\n    SUM(LSO.NUM_ENROLLED_STUDENTS) AS total_enrolled_students,\n    NULL AS term_code,\n    COUNT(DISTINCT LRC.CATALOG_ISBN) AS distinct_isbn_count,\n    2 AS sort_order\nFROM LIBRARY_SUBJECT_OFFERED LSO\nJOIN LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LSO.LIBRARY_SUBJECT_OFFERED_KEY = LRMD.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN LIBRARY_RESERVE_CATALOG LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\nJOIN ACADEMIC_TERM_PARAMETER ATP ON LSO.TERM_CODE = ATP.TERM_CODE\nWHERE ATP.IS_CURRENT_TERM = 'Y'\nORDER BY sort_order, department, school, course_number, subject_title;"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list that involves subscribers that work in departments with names starting with 'Computer Science', state the ownership type, the list name, the number of owners, and the number of subscribers. Display the ownership type only if it differs from the previous entry. Include subtotals (the corresponding type field shoud be 'SUBTOTAL') for each ownership type and a grand total (the corresponding type field shoud be 'TOTAL') across all ownership types.",
        "predicted_sql": "WITH base_data AS (\n    SELECT \n        ml.MOIRA_LIST_KEY,\n        ml.MOIRA_LIST_NAME,\n        mlo.OWNER_TYPE,\n        mld.MOIRA_LIST_MEMBER_MIT_ID as subscriber_id,\n        mlo.OWNER\n    FROM MOIRA_LIST ml\n    JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n    JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY\n    JOIN EMPLOYEE_DIRECTORY ed ON mld.MOIRA_LIST_MEMBER_MIT_ID = ed.MIT_ID\n    WHERE ml.IS_MOIRA_MAILING_LIST = 'Y'\n    AND ed.DEPARTMENT_NAME LIKE 'Computer Science%'\n),\ndetail_agg AS (\n    SELECT \n        MOIRA_LIST_NAME,\n        OWNER_TYPE,\n        COUNT(DISTINCT OWNER) as num_owners,\n        COUNT(DISTINCT subscriber_id) as num_subscribers\n    FROM base_data\n    GROUP BY MOIRA_LIST_NAME, OWNER_TYPE\n),\nsubtotal_agg AS (\n    SELECT \n        OWNER_TYPE,\n        COUNT(DISTINCT OWNER) as num_owners,\n        COUNT(DISTINCT subscriber_id) as num_subscribers\n    FROM base_data\n    GROUP BY OWNER_TYPE\n),\ngrand_total AS (\n    SELECT \n        'TOTAL' as OWNER_TYPE,\n        COUNT(DISTINCT OWNER) as num_owners,\n        COUNT(DISTINCT subscriber_id) as num_subscribers\n    FROM base_data\n)\nSELECT \n    ownership_type,\n    list_name,\n    num_owners,\n    num_subscribers\nFROM (\n    SELECT \n        CASE WHEN LAG(OWNER_TYPE) OVER (ORDER BY OWNER_TYPE, MOIRA_LIST_NAME) = OWNER_TYPE THEN NULL ELSE OWNER_TYPE END as ownership_type,\n        MOIRA_LIST_NAME as list_name,\n        num_owners,\n        num_subscribers,\n        1 as sort_order,\n        OWNER_TYPE as sort_type\n    FROM detail_agg\n    UNION ALL\n    SELECT \n        'SUBTOTAL' as ownership_type,\n        OWNER_TYPE as list_name,\n        num_owners,\n        num_subscribers,\n        2 as sort_order,\n        OWNER_TYPE as sort_type\n    FROM subtotal_agg\n    UNION ALL\n    SELECT \n        'TOTAL' as ownership_type,\n        NULL as list_name,\n        num_owners,\n        num_subscribers,\n        3 as sort_order,\n        NULL as sort_type\n    FROM grand_total\n) AS combined\nORDER BY sort_order, sort_type, list_name;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list its name, number of unique sessions, total number of attendees, active period (in the format of 'beginning term code-end term code'), the most common sponsor name, and the most common session start time. Include a grand total row showing the total number of sessions and attendees across all categories in the format of ('TOTAL', number of sessions, number of attendees, null, null, null).",
        "predicted_sql": "WITH category_stats AS (\n    SELECT \n        c.IAP_CATEGORY_NAME,\n        COUNT(DISTINCT d.IAP_SUBJECT_SESSION_KEY) AS unique_sessions,\n        SUM(d.MAX_ENROLLMENT) AS total_attendees,\n        MIN(d.TERM_CODE) AS min_term_code,\n        MAX(d.TERM_CODE) AS max_term_code,\n        s_sponsor.SPONSOR_NAME,\n        s_session.SESSION_START_TIME,\n        ROW_NUMBER() OVER (PARTITION BY c.IAP_CATEGORY_NAME ORDER BY COUNT(*) DESC) AS sponsor_rank,\n        ROW_NUMBER() OVER (PARTITION BY c.IAP_CATEGORY_NAME ORDER BY COUNT(*) DESC) AS start_time_rank\n    FROM IAP_SUBJECT_DETAIL d\n    JOIN IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\n    JOIN IAP_SUBJECT_SPONSOR s_sponsor ON d.IAP_SUBJECT_SPONSOR_KEY = s_sponsor.IAP_SUBJECT_SPONSOR_KEY\n    JOIN IAP_SUBJECT_SESSION s_session ON d.IAP_SUBJECT_SESSION_KEY = s_session.IAP_SUBJECT_SESSION_KEY\n    GROUP BY c.IAP_CATEGORY_NAME, s_sponsor.SPONSOR_NAME, s_session.SESSION_START_TIME\n),\nmost_common_sponsor AS (\n    SELECT \n        IAP_CATEGORY_NAME,\n        SPONSOR_NAME\n    FROM category_stats\n    WHERE sponsor_rank = 1\n),\nmost_common_start_time AS (\n    SELECT \n        IAP_CATEGORY_NAME,\n        SESSION_START_TIME\n    FROM category_stats\n    WHERE start_time_rank = 1\n),\naggregated_categories AS (\n    SELECT \n        cs.IAP_CATEGORY_NAME,\n        SUM(cs.unique_sessions) AS unique_sessions,\n        SUM(cs.total_attendees) AS total_attendees,\n        MIN(cs.min_term_code) || '-' || MAX(cs.max_term_code) AS active_period,\n        mcs.SPONSOR_NAME AS most_common_sponsor_name,\n        mcst.SESSION_START_TIME AS most_common_session_start_time\n    FROM category_stats cs\n    LEFT JOIN most_common_sponsor mcs ON cs.IAP_CATEGORY_NAME = mcs.IAP_CATEGORY_NAME\n    LEFT JOIN most_common_start_time mcst ON cs.IAP_CATEGORY_NAME = mcst.IAP_CATEGORY_NAME\n    GROUP BY cs.IAP_CATEGORY_NAME, mcs.SPONSOR_NAME, mcst.SESSION_START_TIME\n),\ngrand_total AS (\n    SELECT \n        'TOTAL' AS IAP_CATEGORY_NAME,\n        COUNT(DISTINCT IAP_SUBJECT_SESSION_KEY) AS unique_sessions,\n        SUM(MAX_ENROLLMENT) AS total_attendees,\n        NULL AS active_period,\n        NULL AS most_common_sponsor_name,\n        NULL AS most_common_session_start_time\n    FROM IAP_SUBJECT_DETAIL\n)\n\nSELECT * FROM aggregated_categories\nUNION ALL\nSELECT * FROM grand_total\nORDER BY IAP_CATEGORY_NAME = 'TOTAL' DESC, IAP_CATEGORY_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each building type, list the name of the building type, the number of buildings that are not subdivisions, number of employees, number of unique building street address, number of unique city, number of unique state, number of unique postal code, and average gross square footage per employee. For building type of 'resident', display it as 'RESIDENTIAL'. Include a grand total across all building types (the corresponding type field is 'TOTAL').",
        "predicted_sql": "SELECT \n    CASE \n        WHEN GROUPING(fbh.BUILDING_TYPE) = 1 THEN 'TOTAL'\n        WHEN fbh.BUILDING_TYPE = 'resident' THEN 'RESIDENTIAL'\n        ELSE fbh.BUILDING_TYPE \n    END AS building_type,\n    COUNT(DISTINCT CASE WHEN fbh.PARENT_BUILDING_NUMBER IS NULL THEN fbh.FCLT_BUILDING_KEY END) AS num_buildings_not_subdivisions,\n    COUNT(DISTINCT ed.MIT_ID) AS num_employees,\n    COUNT(DISTINCT CASE WHEN fba.ADDRESS_PURPOSE = 'STREET' THEN CONCAT(fba.STREET_NUMBER, fba.STREET_NAME, fba.STREET_SUFFIX) END) AS num_unique_street_address,\n    COUNT(DISTINCT fba.CITY) AS num_unique_city,\n    COUNT(DISTINCT fba.STATE) AS num_unique_state,\n    COUNT(DISTINCT fba.POSTAL_CODE) AS num_unique_postal_code,\n    SUM(fbh.EXT_GROSS_AREA) / NULLIF(COUNT(DISTINCT ed.MIT_ID), 0) AS avg_gross_sqft_per_employee\nFROM FCLT_BUILDING_HIST fbh\nLEFT JOIN FAC_BUILDING_ADDRESS fba ON fbh.FCLT_BUILDING_KEY = fba.BUILDING_KEY\nLEFT JOIN BUILDINGS b ON fba.BUILDING_KEY = b.BUILDING_KEY\nLEFT JOIN FAC_ROOMS fr ON b.BUILDING_KEY = fr.BUILDING_KEY\nLEFT JOIN EMPLOYEE_DIRECTORY ed ON fr.FAC_ROOM_KEY = ed.OFFICE_LOCATION\nGROUP BY fbh.BUILDING_TYPE WITH ROLLUP"
    },
    {
        "db_id": "dw",
        "question": "Group spaces in the Stata building by the access level and usage type. For each group, state the access level, usage type, name of the space, the number of spaces, total area across all rooms in the space, and average area across all rooms in the space. Display the access level only if it differs from the previous entry. Include subtotals for each access level, usage type, and space name, subtotals for each access level, and a grand total across all access levels. Exclude usage type that includes \"STORAGE\". All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH grouped_data AS (\n    SELECT \n        z.ACCESS_LEVEL,\n        su.SPACE_USAGE,\n        fo.DLC_NAME,\n        COUNT(sd.BUILDING_ROOM) AS num_spaces,\n        SUM(sd.ROOM_SQUARE_FOOTAGE) AS total_sqft,\n        AVG(sd.ROOM_SQUARE_FOOTAGE) AS avg_sqft,\n        GROUPING(z.ACCESS_LEVEL) AS grp_access,\n        GROUPING(su.SPACE_USAGE) AS grp_usage,\n        GROUPING(fo.DLC_NAME) AS grp_name\n    FROM SPACE_DETAIL sd\n    JOIN ZPM_ROOMS_LOAD z ON sd.BUILDING_ROOM = z.BUILDING_ROOM AND sd.BUILDING_COMPONENT = z.BUILDING_COMPONENT\n    JOIN SPACE_USAGE su ON sd.SPACE_USAGE_KEY = su.SPACE_USAGE_KEY\n    JOIN SPACE_UNIT spu ON sd.SPACE_UNIT_KEY = spu.SPACE_UNIT_KEY\n    JOIN FCLT_ORGANIZATION fo ON spu.FCLT_ORGANIZATION_KEY = fo.FCLT_ORGANIZATION_KEY\n    WHERE sd.BUILDING_KEY = '1'\n    AND su.SPACE_USAGE NOT LIKE '%STORAGE%'\n    GROUP BY z.ACCESS_LEVEL, su.SPACE_USAGE, fo.DLC_NAME WITH ROLLUP\n)\nSELECT \n    CASE \n        WHEN grp_access = 0 AND grp_usage = 0 AND grp_name = 0 THEN \n            CASE \n                WHEN ACCESS_LEVEL = LAG(ACCESS_LEVEL) OVER (ORDER BY ACCESS_LEVEL, SPACE_USAGE, DLC_NAME) THEN ''\n                ELSE ACCESS_LEVEL\n            END\n        ELSE ACCESS_LEVEL\n    END AS access_level,\n    SPACE_USAGE,\n    DLC_NAME,\n    FORMAT(num_spaces, 0) AS number_of_spaces,\n    FORMAT(ROUND(total_sqft), 0) AS total_area,\n    FORMAT(ROUND(avg_sqft), 0) AS average_area\nFROM grouped_data\nORDER BY \n    CASE WHEN grp_access = 1 THEN 1 ELSE 0 END,\n    ACCESS_LEVEL,\n    CASE WHEN grp_usage = 1 THEN 1 ELSE 0 END,\n    SPACE_USAGE,\n    CASE WHEN grp_name = 1 THEN 1 ELSE 0 END,\n    DLC_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List each organization's break group, ID, name, and formatted name according to its level, along with whether its members are emeritus or non-emeritus. Also, include the organization number, level, employer count, and hierarchy type for each organization. Exclude organizations '139' and '250'. Sort the results by hierarchy type and ensure totals for employer counts are displayed.",
        "predicted_sql": "SELECT \n    fo.ORGANIZATION_SORT AS break_group,\n    fo.ORGANIZATION_ID AS ID,\n    fo.ORGANIZATION_NAME AS name,\n    CASE \n        WHEN fo.ORGANIZATION_LEVEL = '1' THEN UPPER(fo.ORGANIZATION_NAME)\n        WHEN fo.ORGANIZATION_LEVEL = '2' THEN '  ' || fo.ORGANIZATION_NAME\n        WHEN fo.ORGANIZATION_LEVEL = '3' THEN '    ' || fo.ORGANIZATION_NAME\n        WHEN fo.ORGANIZATION_LEVEL = '4' THEN '      ' || fo.ORGANIZATION_NAME\n        WHEN fo.ORGANIZATION_LEVEL = '5' THEN '        ' || fo.ORGANIZATION_NAME\n        WHEN fo.ORGANIZATION_LEVEL = '6' THEN '          ' || fo.ORGANIZATION_NAME\n        ELSE fo.ORGANIZATION_NAME\n    END AS formatted_name,\n    fo.ORGANIZATION_NUMBER AS organization_number,\n    fo.ORGANIZATION_LEVEL AS level,\n    COUNT(DISTINCT hfr.MIT_ID) AS employer_count,\n    CASE \n        WHEN MAX(hfr.EMERITUS_STATUS) = 'Emeritus' THEN 'Emeritus'\n        ELSE 'Non-Emeritus'\n    END AS emeritus_status,\n    mdh.HIERARCHY_TYPE AS hierarchy_type\nFROM \n    FCLT_ORGANIZATION fo\n    INNER JOIN MASTER_DEPT_HIERARCHY mdh ON fo.DLC_KEY = mdh.DLC_KEY\n    INNER JOIN HR_ORG_UNIT hou ON fo.DLC_KEY = hou.DLC_KEY\n    INNER JOIN HR_FACULTY_ROSTER hfr ON hou.HR_ORG_UNIT_TITLE = hfr.HR_ORG_UNIT_TITLE\nWHERE \n    fo.ORGANIZATION_ID NOT IN ('139', '250')\nGROUP BY \n    fo.ORGANIZATION_SORT,\n    fo.ORGANIZATION_ID,\n    fo.ORGANIZATION_NAME,\n    fo.ORGANIZATION_NUMBER,\n    fo.ORGANIZATION_LEVEL,\n    mdh.HIERARCHY_TYPE\nORDER BY \n    mdh.HIERARCHY_TYPE,\n    fo.ORGANIZATION_SORT;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its title, name of the building of the course location, duration (in terms of days), and a running average of the duration (in terms of days) using a window of two preceding and two following courses (partitioned by academic year and sorted by course start date).",
        "predicted_sql": "SELECT \n    C.SUBJECT_TITLE AS title,\n    B.BUILDING_NAME AS building_name,\n    DATEDIFF(A.TERM_END_DATE, A.TERM_START_DATE) AS duration_days,\n    AVG(DATEDIFF(A.TERM_END_DATE, A.TERM_START_DATE)) OVER (\n        PARTITION BY C.ACADEMIC_YEAR \n        ORDER BY A.TERM_START_DATE \n        ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING\n    ) AS running_avg_duration\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN \n    ACADEMIC_TERMS A ON C.EFFECTIVE_TERM_CODE = A.TERM_CODE\nJOIN \n    FCLT_ROOMS R ON C.MEET_PLACE = R.BUILDING_ROOM\nJOIN \n    FCLT_BUILDING B ON R.FCLT_BUILDING_KEY = B.FCLT_BUILDING_KEY;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, the start date, the name of the course before it, and the name of the course after it, access level of the building, and the assignable area of the room used for the course, sorted by the ascending order start date and course name.",
        "predicted_sql": "SELECT \n    C.SUBJECT_TITLE AS course_name,\n    B.BUILDING_NAME_LONG AS building_name,\n    T.TERM_START_DATE AS start_date,\n    LAG(C.SUBJECT_TITLE) OVER (ORDER BY T.TERM_START_DATE, C.SUBJECT_TITLE) AS previous_course_name,\n    LEAD(C.SUBJECT_TITLE) OVER (ORDER BY T.TERM_START_DATE, C.SUBJECT_TITLE) AS next_course_name,\n    B.ACCESS_LEVEL_NAME AS access_level,\n    R.AREA AS assignable_area\nFROM COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN ACADEMIC_TERMS T ON C.TERM_CODE = T.TERM_CODE\nJOIN FCLT_ROOMS R ON C.MEET_PLACE = R.BUILDING_ROOM\nJOIN FCLT_BUILDING B ON R.FCLT_BUILDING_KEY = B.FCLT_BUILDING_KEY\nORDER BY T.TERM_START_DATE, C.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, and the cumulative number of courses, including the course itself, held in the same year or preceding years (partitioned by academic year and sorted in the ascending order of course start date).",
        "predicted_sql": "SELECT \n  C.SUBJECT_TITLE AS course_name,\n  B.BUILDING_NAME AS building_name,\n  COUNT(*) OVER (ORDER BY CAST(C.ACADEMIC_YEAR AS UNSIGNED), A.TERM_START_DATE) AS cumulative_courses\nFROM COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN ACADEMIC_TERMS A ON C.EFFECTIVE_TERM_CODE = A.TERM_CODE\nJOIN FCLT_ROOMS R ON C.MEET_PLACE = R.FCLT_ROOM_KEY\nJOIN FCLT_BUILDING B ON R.FCLT_BUILDING_KEY = B.FCLT_BUILDING_KEY\nORDER BY CAST(C.ACADEMIC_YEAR AS UNSIGNED), A.TERM_START_DATE;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the cluster type. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), cluster type, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and cluster type.",
        "predicted_sql": "WITH base_data AS (\n    SELECT \n        CASE WHEN A.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END as current_status,\n        S.CLUSTER_TYPE,\n        DATEDIFF(A.TERM_END_DATE, A.TERM_START_DATE) as duration_days,\n        S.TOTAL_UNITS\n    FROM ACADEMIC_TERMS_ALL A\n    JOIN SUBJECT_SUMMARY S ON A.TERM_CODE = S.TERM_CODE\n    WHERE S.DEPARTMENT_NAME IN ('Biology', 'Chemistry')\n)\nSELECT \n    CASE \n        WHEN GROUPING(current_status) = 1 AND GROUPING(CLUSTER_TYPE) = 1 THEN 'TOTAL'\n        WHEN GROUPING(CLUSTER_TYPE) = 1 THEN 'SUBTOTAL'\n        ELSE current_status\n    END as current_status,\n    CLUSTER_TYPE,\n    MAX(duration_days) as max_duration,\n    MAX(TOTAL_UNITS) as max_units,\n    AVG(duration_days) as avg_duration,\n    AVG(TOTAL_UNITS) as avg_units\nFROM base_data\nGROUP BY current_status, CLUSTER_TYPE WITH ROLLUP\nORDER BY current_status, CLUSTER_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the department name. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), department name, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and department.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN GROUPING(a.IS_CURRENT_TERM) = 1 AND GROUPING(s.DEPARTMENT_NAME) = 1 THEN 'TOTAL'\n        WHEN GROUPING(s.DEPARTMENT_NAME) = 1 THEN 'SUBTOTAL'\n        ELSE CASE WHEN a.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END\n    END AS current_status,\n    s.DEPARTMENT_NAME AS department_name,\n    MAX(DATEDIFF(a.TERM_END_DATE, a.TERM_START_DATE)) AS max_duration,\n    MAX(s.TOTAL_UNITS) AS max_units,\n    AVG(DATEDIFF(a.TERM_END_DATE, a.TERM_START_DATE)) AS avg_duration,\n    AVG(s.TOTAL_UNITS) AS avg_units\nFROM ACADEMIC_TERMS_ALL a\nJOIN SUBJECT_SUMMARY s ON a.TERM_CODE = s.TERM_CODE\nJOIN SUBJECT_OFFERED o ON s.SUBJECT_ID = o.SUBJECT_ID\nWHERE s.DEPARTMENT_NAME IN ('Biology', 'Chemistry')\nGROUP BY a.IS_CURRENT_TERM, s.DEPARTMENT_NAME WITH ROLLUP\nORDER BY GROUPING(a.IS_CURRENT_TERM), a.IS_CURRENT_TERM DESC, GROUPING(s.DEPARTMENT_NAME), s.DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Group master courses by department. For each group, state the name of the department, the master course code, the number of subjects, the total new shelf price of associated TIP materials, and the number of unique TIP materials. Display the department and master course only if it differs from the previous entry. Include subtotals for each department and a grand total across all departments. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH subject_groups AS (\n  SELECT \n    OFFER_DEPT_NAME,\n    MASTER_COURSE_NUMBER,\n    COUNT(DISTINCT SUBJECT_ID) AS num_subjects\n  FROM TIP_SUBJECT_OFFERED\n  GROUP BY OFFER_DEPT_NAME, MASTER_COURSE_NUMBER\n),\nmaterial_groups AS (\n  SELECT \n    TSO.OFFER_DEPT_NAME,\n    TSO.MASTER_COURSE_NUMBER,\n    SUM(TM.NEW_SHELF_PRICE) AS total_new_shelf_price,\n    COUNT(DISTINCT TM.TIP_MATERIAL_KEY) AS num_unique_materials\n  FROM TIP_SUBJECT_OFFERED TSO\n  JOIN TIP_DETAIL TD ON TSO.TIP_SUBJECT_OFFERED_KEY = TD.TIP_SUBJECT_OFFERED_KEY\n  JOIN TIP_MATERIAL TM ON TD.TIP_MATERIAL_KEY = TM.TIP_MATERIAL_KEY\n  GROUP BY TSO.OFFER_DEPT_NAME, TSO.MASTER_COURSE_NUMBER\n),\naggregated AS (\n  SELECT \n    CASE \n      WHEN GROUPING(sg.OFFER_DEPT_NAME) = 1 THEN 'Grand Total'\n      ELSE sg.OFFER_DEPT_NAME \n    END AS department,\n    CASE \n      WHEN GROUPING(sg.MASTER_COURSE_NUMBER) = 1 AND GROUPING(sg.OFFER_DEPT_NAME) = 0 THEN 'Subtotal'\n      WHEN GROUPING(sg.MASTER_COURSE_NUMBER) = 1 AND GROUPING(sg.OFFER_DEPT_NAME) = 1 THEN ''\n      ELSE sg.MASTER_COURSE_NUMBER \n    END AS master_course,\n    SUM(sg.num_subjects) AS num_subjects,\n    SUM(COALESCE(mg.total_new_shelf_price, 0)) AS total_new_shelf_price,\n    SUM(COALESCE(mg.num_unique_materials, 0)) AS num_unique_materials\n  FROM subject_groups sg\n  LEFT JOIN material_groups mg ON sg.OFFER_DEPT_NAME = mg.OFFER_DEPT_NAME AND sg.MASTER_COURSE_NUMBER = mg.MASTER_COURSE_NUMBER\n  GROUP BY sg.OFFER_DEPT_NAME, sg.MASTER_COURSE_NUMBER WITH ROLLUP\n)\nSELECT \n  CASE \n    WHEN department = LAG(department) OVER (ORDER BY department, master_course) THEN ''\n    ELSE department \n  END AS department_display,\n  CASE \n    WHEN master_course = LAG(master_course) OVER (ORDER BY department, master_course) THEN ''\n    ELSE master_course \n  END AS master_course_display,\n  FORMAT(ROUND(num_subjects), 0) AS num_subjects_formatted,\n  FORMAT(ROUND(total_new_shelf_price), 0) AS total_new_shelf_price_formatted,\n  FORMAT(ROUND(num_unique_materials), 0) AS num_unique_materials_formatted\nFROM aggregated\nORDER BY department, master_course;"
    },
    {
        "db_id": "dw",
        "question": "For each term and department, list the term, department, the number of courses, average number of equivalent subjects, the school name, and department phone number. Include subtotals for each term (the corresponding term field is 'SUBTOTAL') and a grand total across all terms (the corresponding term field is 'TOTAL'). Do not repeat the term if it is the same as the previous row. Sort the table by term and department.",
        "predicted_sql": "WITH course_data AS (\n  SELECT \n    c.TERM_CODE,\n    c.DEPARTMENT_NAME,\n    c.DEPARTMENT_CODE,\n    c.SUBJECT_ID,\n    CASE \n      WHEN c.EQUIVALENT_SUBJECTS IS NULL OR c.EQUIVALENT_SUBJECTS = '' THEN 0\n      ELSE LENGTH(c.EQUIVALENT_SUBJECTS) - LENGTH(REPLACE(c.EQUIVALENT_SUBJECTS, ',', '')) + 1\n    END AS equivalent_count\n  FROM COURSE_CATALOG_SUBJECT_OFFERED c\n)\nSELECT \n  CASE \n    WHEN GROUPING(c.TERM_CODE) = 1 THEN 'TOTAL'\n    WHEN GROUPING(c.DEPARTMENT_NAME) = 1 THEN 'SUBTOTAL'\n    ELSE c.TERM_CODE\n  END AS term,\n  COALESCE(c.DEPARTMENT_NAME, 'All Departments') AS department,\n  COUNT(DISTINCT c.SUBJECT_ID) AS number_of_courses,\n  AVG(c.equivalent_count) AS avg_equivalent_subjects,\n  CASE \n    WHEN GROUPING(c.DEPARTMENT_NAME) = 0 THEN sd.SCHOOL_NAME\n    ELSE NULL \n  END AS school_name,\n  CASE \n    WHEN GROUPING(c.DEPARTMENT_NAME) = 0 THEN sad.DEPARTMENT_PHONE_NUMBER\n    ELSE NULL \n  END AS department_phone_number\nFROM course_data c\nLEFT JOIN SIS_DEPARTMENT sd ON c.DEPARTMENT_CODE = sd.DEPARTMENT_CODE\nLEFT JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE\nGROUP BY c.TERM_CODE, c.DEPARTMENT_NAME WITH ROLLUP\nORDER BY \n  GROUPING(c.TERM_CODE),\n  c.TERM_CODE,\n  GROUPING(c.DEPARTMENT_NAME),\n  c.DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Group sessions by their current term status. For each group, state the status ('CURRENT' if is current term and 'NOT CURRENT' otherwise), name of the session, number of IAP sessions, total IAP session time in days, and average IAP session time in days. Show a subtotal for each current status and a grand total row across all status. Order the results by current status and cluster type. Display the the current status only if it differs from the previous entry.",
        "predicted_sql": "WITH GroupedData AS (\n    SELECT \n        a.IS_CURRENT_TERM,\n        c.IAP_CATEGORY_NAME,\n        COUNT(s.IAP_SUBJECT_SESSION_KEY) AS Number_of_Sessions,\n        SUM( \n            TIMESTAMPDIFF(SECOND, \n                          STR_TO_DATE(s.SESSION_START_TIME, '%h%i%p'), \n                          STR_TO_DATE(s.SESSION_END_TIME, '%h%i%p')\n                         ) / (24 * 3600.0)\n        ) AS Total_Time_Days,\n        AVG(\n            TIMESTAMPDIFF(SECOND, \n                          STR_TO_DATE(s.SESSION_START_TIME, '%h%i%p'), \n                          STR_TO_DATE(s.SESSION_END_TIME, '%h%i%p')\n                         ) / (24 * 3600.0)\n        ) AS Avg_Time_Days\n    FROM IAP_SUBJECT_DETAIL d\n    JOIN ACADEMIC_TERMS a ON d.TERM_CODE = a.TERM_CODE\n    JOIN IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\n    JOIN IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\n    GROUP BY a.IS_CURRENT_TERM, c.IAP_CATEGORY_NAME WITH ROLLUP\n)\nSELECT \n    CASE \n        WHEN IS_CURRENT_TERM IS NULL AND IAP_CATEGORY_NAME IS NULL THEN 'ALL' \n        WHEN IAP_CATEGORY_NAME IS NULL THEN \n            CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END \n        ELSE \n            CASE \n                WHEN LAG(CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END) OVER (ORDER BY IS_CURRENT_TERM, IAP_CATEGORY_NAME) = \n                     CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END \n                THEN NULL \n                ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END \n            END \n    END AS Status,\n    IAP_CATEGORY_NAME AS Session_Name,\n    Number_of_Sessions,\n    Total_Time_Days,\n    Avg_Time_Days\nFROM GroupedData\nORDER BY IS_CURRENT_TERM, IAP_CATEGORY_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List each academic year, the term code, and the number of newly introduced subjects in this term. Display the academic year only if it differs from the previous entry. Include a grand total (the corresponding year field should be 'TOTAL') stating the total number of subjects across all academic years.",
        "predicted_sql": "WITH NewSubjects AS (\n    SELECT \n        ata.ACADEMIC_YEAR,\n        ata.TERM_CODE,\n        COUNT(DISTINCT ccso.SUBJECT_ID) AS new_subjects_count\n    FROM ACADEMIC_TERMS_ALL ata\n    JOIN COURSE_CATALOG_SUBJECT_OFFERED ccso \n        ON ata.TERM_CODE = ccso.TERM_CODE \n        AND ata.ACADEMIC_YEAR = ccso.ACADEMIC_YEAR\n    WHERE ccso.STATUS_CHANGE = 'New subject'\n    GROUP BY ata.ACADEMIC_YEAR, ata.TERM_CODE\n)\nSELECT \n    CASE \n        WHEN LAG(ACADEMIC_YEAR) OVER (ORDER BY ACADEMIC_YEAR, TERM_CODE) = ACADEMIC_YEAR \n        THEN '' \n        ELSE ACADEMIC_YEAR \n    END AS Academic_Year,\n    TERM_CODE,\n    new_subjects_count\nFROM NewSubjects\nUNION ALL\nSELECT \n    'TOTAL' AS Academic_Year,\n    NULL AS TERM_CODE,\n    SUM(new_subjects_count) AS new_subjects_count\nFROM NewSubjects\nORDER BY Academic_Year, TERM_CODE;"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with e (case insensitive), containing 10 to 20 members inclusive, and where over 75% are computer science students, provide the list name, owner, and member count.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME AS list_name,\n    mo.OWNER AS owner,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS member_count\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nLEFT JOIN \n    MIT_STUDENT_DIRECTORY msd ON sp.FULL_NAME = msd.FULL_NAME\nJOIN \n    MOIRA_LIST_OWNER mo ON mld.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY\nWHERE \n    LOWER(ml.MOIRA_LIST_NAME) LIKE 'e%'\nGROUP BY \n    ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME, mo.OWNER\nHAVING \n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) BETWEEN 10 AND 20\n    AND SUM(CASE WHEN msd.DEPARTMENT_NAME LIKE '%Computer Sci%' THEN 1 ELSE 0 END) / COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) > 0.75;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with K, list their names, the phone numbers of departments they belong to, total number of mailing lists each student is in, and the average size of the mailing lists each student is in.",
        "predicted_sql": "WITH list_sizes AS (\n    SELECT mld.MOIRA_LIST_KEY, COUNT(*) as size\n    FROM MOIRA_LIST_DETAIL mld\n    INNER JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\n    WHERE ml.IS_MOIRA_MAILING_LIST = 'Y'\n    GROUP BY mld.MOIRA_LIST_KEY\n)\nSELECT \n    s.FULL_NAME as student_name,\n    sad.DEPARTMENT_PHONE_NUMBER as department_phone,\n    COUNT(DISTINCT ml.MOIRA_LIST_KEY) as total_mailing_lists,\n    AVG(ls.size) as avg_mailing_list_size\nFROM MIT_STUDENT_DIRECTORY s\nINNER JOIN SE_PERSON sp ON s.FULL_NAME = sp.FULL_NAME\nINNER JOIN SIS_DEPARTMENT sd ON s.DEPARTMENT = sd.DEPARTMENT_CODE\nINNER JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE\nLEFT JOIN MOIRA_LIST_DETAIL mld ON sp.MIT_ID = mld.MOIRA_LIST_MEMBER_MIT_ID\nLEFT JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY AND ml.IS_MOIRA_MAILING_LIST = 'Y'\nLEFT JOIN list_sizes ls ON ml.MOIRA_LIST_KEY = ls.MOIRA_LIST_KEY\nWHERE s.LAST_NAME LIKE 'K%'\nGROUP BY s.FULL_NAME, sad.DEPARTMENT_PHONE_NUMBER;"
    },
    {
        "db_id": "dw",
        "question": "From the 100 email lists with the most number of subscribers, list their names, their total number of subscribers, their public status, the name of the department with the most presence in the list, and the number of students from this department in the list.",
        "predicted_sql": "WITH subscriber_counts AS (\n    SELECT MOIRA_LIST_KEY, COUNT(DISTINCT MOIRA_LIST_MEMBER) as total_subscribers\n    FROM MOIRA_LIST_DETAIL\n    GROUP BY MOIRA_LIST_KEY\n),\ntop_lists_info AS (\n    SELECT sc.MOIRA_LIST_KEY, sc.total_subscribers, ml.MOIRA_LIST_NAME, ml.IS_PUBLIC\n    FROM subscriber_counts sc\n    JOIN MOIRA_LIST ml ON sc.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\n    ORDER BY sc.total_subscribers DESC\n    LIMIT 100\n),\ndepartment_counts_per_list AS (\n    SELECT mld.MOIRA_LIST_KEY, sd.DEPARTMENT_NAME, COUNT(*) as student_count\n    FROM MOIRA_LIST_DETAIL mld\n    JOIN MIT_STUDENT_DIRECTORY msd ON mld.MOIRA_LIST_MEMBER_FULL_NAME = msd.FULL_NAME\n    JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\n    WHERE mld.MOIRA_LIST_KEY IN (SELECT MOIRA_LIST_KEY FROM top_lists_info)\n    GROUP BY mld.MOIRA_LIST_KEY, sd.DEPARTMENT_NAME\n),\nranked_departments AS (\n    SELECT MOIRA_LIST_KEY, DEPARTMENT_NAME, student_count,\n           ROW_NUMBER() OVER (PARTITION BY MOIRA_LIST_KEY ORDER BY student_count DESC) as rn\n    FROM department_counts_per_list\n)\nSELECT tli.MOIRA_LIST_NAME as list_name,\n       tli.total_subscribers,\n       tli.IS_PUBLIC as public_status,\n       rd.DEPARTMENT_NAME as top_department_name,\n       rd.student_count as students_in_top_department\nFROM top_lists_info tli\nLEFT JOIN ranked_departments rd ON tli.MOIRA_LIST_KEY = rd.MOIRA_LIST_KEY AND rd.rn = 1\nORDER BY tli.total_subscribers DESC;"
    },
    {
        "db_id": "dw",
        "question": "Calculate the total assignable and non-assignable area for each building by summing up the respective areas of all its floors. For each building, list the building name, building number, total assignable area, total non-assignable area, and total room count, sorted in descending order of the total assignable area.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME,\n    b.BUILDING_NUMBER,\n    COALESCE(fa.total_assignable, 0) AS total_assignable_area,\n    COALESCE(fa.total_non_assignable, 0) AS total_non_assignable_area,\n    COALESCE(rc.room_count, 0) AS total_room_count\nFROM FAC_BUILDING b\nLEFT JOIN (\n    SELECT BUILDING_KEY, \n           SUM(ASSIGNABLE_AREA) AS total_assignable,\n           SUM(NON_ASSIGNABLE_AREA) AS total_non_assignable\n    FROM FAC_FLOOR\n    GROUP BY BUILDING_KEY\n) fa ON b.FAC_BUILDING_KEY = fa.BUILDING_KEY\nLEFT JOIN (\n    SELECT BUILDING_KEY, \n           COUNT(DISTINCT FAC_ROOM_KEY) AS room_count\n    FROM FAC_ROOMS\n    GROUP BY BUILDING_KEY\n) rc ON b.FAC_BUILDING_KEY = rc.BUILDING_KEY\nORDER BY fa.total_assignable DESC;"
    },
    {
        "db_id": "dw",
        "question": "List all rooms in building 45, including their full name, area, major use, the organization that occupies them, the count of rooms per major use, and the total area occupied by rooms for each organization.",
        "predicted_sql": "SELECT \n    r.ROOM_FULL_NAME,\n    r.AREA,\n    mu.MAJOR_USE,\n    o.ORGANIZATION_NAME,\n    COUNT(*) OVER (PARTITION BY r.MAJOR_USE_KEY) AS rooms_per_major_use,\n    SUM(CAST(r.AREA AS DECIMAL(10,2))) OVER (PARTITION BY r.ORGANIZATION_KEY) AS total_area_per_org\nFROM FAC_ROOMS r\nJOIN FAC_MAJOR_USE mu ON r.MAJOR_USE_KEY = mu.MAJOR_USE_KEY\nJOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\nWHERE r.BUILDING_KEY = '45';"
    },
    {
        "db_id": "dw",
        "question": "List the name, number, construction date, and type of all buildings, along with the count of addresses associated with each building, the average gross area of the buildings, and the total number of rooms in each building. Sort the results by building name.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME AS name,\n    b.BUILDING_NUMBER AS number,\n    b.DATE_BUILT AS construction_date,\n    b.BUILDING_TYPE AS type,\n    COUNT(DISTINCT a.BUILDING_ADDRESS_KEY) AS address_count,\n    AVG(CAST(b.EXT_GROSS_AREA AS DECIMAL)) AS avg_gross_area,\n    COUNT(DISTINCT r.FAC_ROOM_KEY) AS total_rooms\nFROM FAC_BUILDING b\nLEFT JOIN FAC_BUILDING_ADDRESS a ON b.FAC_BUILDING_KEY = a.BUILDING_KEY\nLEFT JOIN FAC_ROOMS r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY\nGROUP BY \n    b.FAC_BUILDING_KEY,\n    b.BUILDING_NAME,\n    b.BUILDING_NUMBER,\n    b.DATE_BUILT,\n    b.BUILDING_TYPE\nORDER BY b.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list its name, number of unique courses offered, the number of unique reserved materials, and the number of unique instructors associated with those courses, sorted by the number of unique courses offered in descending order.",
        "predicted_sql": "SELECT \n    lso.OFFER_DEPT_NAME AS department_name,\n    COUNT(DISTINCT lso.MASTER_COURSE_NUMBER) AS unique_courses_offered,\n    COUNT(DISTINCT lrc.CATALOG_TITLE) AS unique_reserved_materials,\n    COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS unique_instructors\nFROM \n    LIBRARY_SUBJECT_OFFERED lso\nLEFT JOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lso.LIBRARY_SUBJECT_OFFERED_KEY = lrmd.LIBRARY_SUBJECT_OFFERED_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nLEFT JOIN \n    LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    lso.OFFER_DEPT_NAME\nORDER BY \n    unique_courses_offered DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each course title, list the title, the total number of reserved materials, and the count of distinct material status associated with those materials, sorted by the total number of reserved materials in descending order.",
        "predicted_sql": "SELECT \n    lso.SUBJECT_TITLE AS title,\n    COUNT(lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS total_reserved_materials,\n    COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS distinct_status_count\nFROM \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd\nINNER JOIN \n    LIBRARY_SUBJECT_OFFERED lso \n    ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nINNER JOIN \n    LIBRARY_MATERIAL_STATUS lms \n    ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    lso.SUBJECT_TITLE\nORDER BY \n    total_reserved_materials DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each instructor, list their name, the number of unique courses they teach, the total number of material assignments, average publication year, and number of distinct status, sorted by the number of unique courses in descending order.",
        "predicted_sql": "SELECT \n    lci.INSTRUCTOR_NAME AS instructor_name,\n    COUNT(DISTINCT lci.COURSE_NAME) AS num_unique_courses,\n    COUNT(lrm.LIBRARY_COURSE_INSTRUCTOR_KEY) AS total_material_assignments,\n    AVG(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS avg_publication_year,\n    COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS num_distinct_status\nFROM \n    LIBRARY_COURSE_INSTRUCTOR lci\n    LEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL lrm ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrm.LIBRARY_COURSE_INSTRUCTOR_KEY\n    LEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON lrm.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\n    LEFT JOIN LIBRARY_MATERIAL_STATUS lms ON lrm.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    lci.INSTRUCTOR_NAME\nORDER BY \n    num_unique_courses DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each publication year, list the year, the total number of reserved materials, the average length of their titles, distinct number of status, and number of courses, sorted by publication year in descending order.",
        "predicted_sql": "SELECT \n    C.CATALOG_YEAR AS year,\n    COUNT(DISTINCT C.LIBRARY_RESERVE_CATALOG_KEY) AS total_reserved_materials,\n    AVG(LENGTH(C.CATALOG_TITLE)) AS avg_title_length,\n    COUNT(DISTINCT S.LIBRARY_MATERIAL_STATUS) AS distinct_status_count,\n    COUNT(DISTINCT I.COURSE_NAME) AS number_of_courses\nFROM \n    LIBRARY_RESERVE_CATALOG C\n    INNER JOIN LIBRARY_RESERVE_MATRL_DETAIL D ON C.LIBRARY_RESERVE_CATALOG_KEY = D.LIBRARY_RESERVE_CATALOG_KEY\n    INNER JOIN LIBRARY_MATERIAL_STATUS S ON D.LIBRARY_MATERIAL_STATUS_KEY = S.LIBRARY_MATERIAL_STATUS_KEY\n    INNER JOIN LIBRARY_COURSE_INSTRUCTOR I ON D.LIBRARY_COURSE_INSTRUCTOR_KEY = I.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    C.CATALOG_YEAR\nORDER BY \n    CAST(C.CATALOG_YEAR AS UNSIGNED) DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list the category name, the sponsor name, the number of activities offered, and the average fee per activity, sorted by the number of activities in descending order.",
        "predicted_sql": "SELECT \n    c.IAP_CATEGORY_NAME AS category_name,\n    s.SPONSOR_NAME AS sponsor_name,\n    COUNT(*) AS number_of_activities,\n    AVG(d.FEE) AS average_fee_per_activity\nFROM \n    IAP_SUBJECT_DETAIL d\nJOIN \n    IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    IAP_SUBJECT_SPONSOR s ON d.IAP_SUBJECT_SPONSOR_KEY = s.IAP_SUBJECT_SPONSOR_KEY\nGROUP BY \n    c.IAP_CATEGORY_NAME, s.SPONSOR_NAME\nORDER BY \n    number_of_activities DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor, list the sponsor name, the number of IAP sessions hosted, and the number of unique subjects organized.",
        "predicted_sql": "SELECT \n    sp.SPONSOR_NAME,\n    COUNT(DISTINCT s.IAP_SUBJECT_SESSION_KEY) AS number_of_sessions,\n    COUNT(DISTINCT d.IAP_SUBJECT_SESSION_KEY) AS number_of_unique_subjects\nFROM IAP_SUBJECT_SPONSOR sp\nLEFT JOIN IAP_SUBJECT_DETAIL d ON sp.IAP_SUBJECT_SPONSOR_KEY = d.IAP_SUBJECT_SPONSOR_KEY\nLEFT JOIN IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nGROUP BY sp.IAP_SUBJECT_SPONSOR_KEY, sp.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each person role and IAP category, list the role, the category name, the number of people in this role, and the average fee, sorted by the role count in descending order.",
        "predicted_sql": "SELECT p.PERSON_ROLE, c.IAP_CATEGORY_NAME, COUNT(p.IAP_SUBJECT_PERSON_KEY) AS number_of_people, AVG(d.FEE) AS average_fee\nFROM IAP_SUBJECT_PERSON p\nJOIN IAP_SUBJECT_DETAIL d ON p.IAP_SUBJECT_PERSON_KEY = d.IAP_SUBJECT_PERSON_KEY\nJOIN IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\nGROUP BY p.PERSON_ROLE, c.IAP_CATEGORY_NAME\nORDER BY number_of_people DESC;"
    },
    {
        "db_id": "dw",
        "question": "List the names of the buildings with the most floors. If there are ties, list each one separately.",
        "predicted_sql": "SELECT b.BUILDING_NAME\nFROM FAC_BUILDING b\nINNER JOIN FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nGROUP BY b.FAC_BUILDING_KEY, b.BUILDING_NAME\nHAVING COUNT(DISTINCT f.LEVEL_ID) = (\n    SELECT MAX(floor_count)\n    FROM (\n        SELECT COUNT(DISTINCT LEVEL_ID) as floor_count\n        FROM FAC_FLOOR\n        GROUP BY BUILDING_KEY\n    ) as temp\n);"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered in the summer term, list the subject titles, number of instructors, and the length of the longest instructor name.",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE,\n    COUNT(DISTINCT e.MIT_ID) AS number_of_instructors,\n    MAX(LENGTH(e.FULL_NAME)) AS longest_instructor_name_length\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nINNER JOIN \n    ACADEMIC_TERMS_ALL a ON c.TERM_CODE = a.TERM_CODE\nINNER JOIN \n    EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nWHERE \n    a.TERM_CODE LIKE '%SU'\nGROUP BY \n    c.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For the mailing list with owner key LIST69.377-keeper-xenon, list the owner, total number of mailing lists, and total number of members across all these mailing lists.",
        "predicted_sql": "SELECT \n    mo.OWNER AS owner,\n    COUNT(DISTINCT ml.MOIRA_LIST_KEY) AS total_mailing_lists,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS total_members\nFROM \n    MOIRA_LIST_OWNER mo\nJOIN \n    MOIRA_LIST_DETAIL mld ON mo.MOIRA_LIST_OWNER_KEY = mld.MOIRA_LIST_OWNER_KEY\nJOIN \n    MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nWHERE \n    mo.MOIRA_LIST_OWNER_KEY = 'LIST69.377-keeper-xenon'\n    AND ml.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY \n    mo.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For each school, list the school name, total number of courses that appear in SIS subject code catalog, and the total number of degree-granting courses that appear in SIS subject code catalog.",
        "predicted_sql": "SELECT \n    d.SCHOOL_NAME,\n    COUNT(DISTINCT s.COURSE_NUMBER) AS total_courses,\n    COUNT(DISTINCT CASE WHEN cd.IS_DEGREE_GRANTING = 'Y' THEN s.COURSE_NUMBER END) AS degree_granting_courses\nFROM SIS_SUBJECT_CODE s\nJOIN SIS_COURSE_DESCRIPTION cd ON s.COURSE_NUMBER = cd.COURSE\nJOIN SIS_DEPARTMENT d ON cd.DEPARTMENT = d.DEPARTMENT_CODE\nGROUP BY d.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the department name, department phone number, number of students, and the length of the longest student full name in that department.",
        "predicted_sql": "SELECT \n    sd.DEPARTMENT_NAME,\n    sad.DEPARTMENT_PHONE_NUMBER,\n    COUNT(DISTINCT msd.EMAIL_ADDRESS) AS number_of_students,\n    MAX(LENGTH(msd.FULL_NAME)) AS longest_full_name_length\nFROM SIS_DEPARTMENT sd\nLEFT JOIN MIT_STUDENT_DIRECTORY msd ON sd.DEPARTMENT_CODE = msd.DEPARTMENT\nLEFT JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE\nGROUP BY sd.DEPARTMENT_CODE, sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER;"
    }
]