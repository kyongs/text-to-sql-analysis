[
    {
        "db_id": "dw",
        "question": "What is the current building key, building street address, city, state, and postal code of the history department?",
        "predicted_sql": "SELECT \n    BUILDINGS.BUILDING_KEY, \n    BUILDINGS.BUILDING_STREET_ADDRESS, \n    FCLT_BUILDING_ADDRESS.CITY, \n    FCLT_BUILDING_ADDRESS.STATE, \n    FCLT_BUILDING_ADDRESS.POSTAL_CODE \nFROM \n    BUILDINGS \nJOIN \n    FCLT_BUILDING_ADDRESS ON BUILDINGS.BUILDING_KEY = FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY \nJOIN \n    FCLT_ROOMS ON FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY \nJOIN \n    FCLT_ORG_DLC_KEY ON FCLT_ROOMS.FCLT_ORGANIZATION_KEY = FCLT_ORG_DLC_KEY.FCLT_ORGANIZATION_KEY \nJOIN \n    MASTER_DEPT_HIERARCHY ON FCLT_ORG_DLC_KEY.DLC_KEY = MASTER_DEPT_HIERARCHY.DLC_KEY \nWHERE \n    MASTER_DEPT_HIERARCHY.DLC_NAME = 'history department';"
    },
    {
        "db_id": "dw",
        "question": "Show the unique activity titles, locations, term start date, and supervisor name for all independent activities, sorted by the ascending order of start date.",
        "predicted_sql": "SELECT DISTINCT sd.ACTIVITY_TITLE, s.SESSION_LOCATION, at.TERM_START_DATE, sp.PERSON_NAME\nFROM IAP_SUBJECT_DETAIL sd\nJOIN IAP_SUBJECT_SESSION s ON sd.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nJOIN ACADEMIC_TERMS_ALL at ON sd.TERM_CODE = at.TERM_CODE\nJOIN IAP_SUBJECT_PERSON sp ON sd.IAP_SUBJECT_PERSON_KEY = sp.IAP_SUBJECT_PERSON_KEY\nWHERE sp.PERSON_ROLE = 'Activity leader'\nORDER BY at.TERM_START_DATE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the unique course instructor names, course titles, and the amount of material for each course instructor key and the key of subject offered.",
        "predicted_sql": "SELECT \n    DISTINCT LCI.INSTRUCTOR_NAME, \n    LSO.SUBJECT_TITLE, \n    COUNT(LRCD.LIBRARY_RESERVE_CATALOG_KEY) AS AMOUNT_OF_MATERIAL\nFROM \n    LIBRARY_COURSE_INSTRUCTOR LCI\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED LSO ON LRMD.LIBRARY_SUBJECT_OFFERED_KEY = LSO.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRCD ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRCD.LIBRARY_RESERVE_CATALOG_KEY\nGROUP BY \n    LCI.INSTRUCTOR_NAME, \n    LSO.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "What is the room, floor, building key, building street address, city, state, and postal code of Professor Summer Haynes's office?",
        "predicted_sql": "SELECT \n    fr.ROOM, \n    fr.FLOOR, \n    fb.BUILDING_KEY, \n    b.BUILDING_STREET_ADDRESS, \n    fb.CITY, \n    fb.STATE, \n    fb.POSTAL_CODE\nFROM \n    EMPLOYEE_DIRECTORY ed\nJOIN \n    FAC_ROOMS fr ON ed.OFFICE_LOCATION = fr.FAC_ROOM_KEY\nJOIN \n    FAC_BUILDING_ADDRESS fb ON fr.BUILDING_KEY = fb.BUILDING_KEY\nJOIN \n    BUILDINGS b ON fb.BUILDING_KEY = b.BUILDING_KEY\nWHERE \n    ed.FULL_NAME = 'Haynes, Summer';"
    },
    {
        "db_id": "dw",
        "question": "List the unique full room names, their corresponding building names, street addresses, cities, states, postal codes, and building heights for rooms associated with subjects that Computer Science students can enroll in.",
        "predicted_sql": "SELECT DISTINCT \n    FR.ROOM_FULL_NAME, \n    B.BUILDING_NAME, \n    BA.STREET_NAME || ' ' || BA.STREET_SUFFIX || ' ' || BA.POST_DIRECTIONAL || ' ' || BA.STREET_NUMBER AS STREET_ADDRESS,\n    BA.CITY, \n    BA.STATE, \n    BA.POSTAL_CODE, \n    FB.BUILDING_HEIGHT\nFROM \n    FCLT_ROOMS FR\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED CS ON FR.FCLT_ROOM_KEY = CS.MEET_PLACE\nJOIN \n    FCLT_BUILDING FB ON FR.FCLT_BUILDING_KEY = FB.FCLT_BUILDING_KEY\nJOIN \n    FCLT_BUILDING_ADDRESS BA ON FB.FCLT_BUILDING_KEY = BA.FCLT_BUILDING_KEY\nJOIN \n    BUILDINGS B ON FB.FCLT_BUILDING_KEY = B.BUILDING_KEY\nWHERE \n    CS.DEPARTMENT_NAME = 'Electrical Eng & Computer Sci';"
    },
    {
        "db_id": "dw",
        "question": "List the unique term code, subject title, room, floor, building key, building street address, city, state, and postal code, formats, and number of enrolled students for all courses with more than 300 attendees.",
        "predicted_sql": "SELECT DISTINCT SUBJECT_OFFERED.TERM_CODE, SUBJECT_OFFERED.SUBJECT_TITLE, FCLT_ROOMS.ROOM, FCLT_ROOMS.FLOOR, FCLT_ROOMS.FCLT_BUILDING_KEY, BUILDINGS.BUILDING_STREET_ADDRESS, FCLT_BUILDING_ADDRESS.CITY, FCLT_BUILDING_ADDRESS.STATE, FCLT_BUILDING_ADDRESS.POSTAL_CODE, SUBJECT_OFFERED.FORM_TYPE, SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS \nFROM SUBJECT_OFFERED \nJOIN FCLT_ROOMS ON FCLT_ROOMS.MEET_PLACE = SUBJECT_OFFERED.MEET_PLACE \nJOIN FCLT_BUILDING_ADDRESS ON FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY \nJOIN BUILDINGS ON FCLT_ROOMS.FCLT_BUILDING_KEY = BUILDINGS.BUILDING_KEY \nWHERE SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS > 300;"
    },
    {
        "db_id": "dw",
        "question": "What are the subject titles, their material titles, ISBN numbers, new shelf prices, and total costs of new materials for each subject title, sorted by individual item prices in ascending order?",
        "predicted_sql": "SELECT \n    TSO.SUBJECT_TITLE, \n    TM.TITLE AS MATERIAL_TITLE, \n    TM.ISBN, \n    TM.NEW_SHELF_PRICE, \n    TM.NEW_SHELF_PRICE AS TOTAL_COST\nFROM \n    TIP_SUBJECT_OFFERED TSO\nJOIN \n    TIP_DETAIL TD ON TSO.SUBJECT_ID = TD.SUBJECT_ID\nJOIN \n    TIP_MATERIAL TM ON TD.TIP_MATERIAL_KEY = TM.TIP_MATERIAL_KEY\nORDER BY \n    TM.NEW_SHELF_PRICE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the long names of buildings constructed before 1950 that have more than 100 employees, the built year of the building, and number of employees.",
        "predicted_sql": "SELECT \n    F.BUILDING_NAME_LONG, \n    F.DATE_BUILT, \n    COUNT(E.MIT_ID) AS num_of_employees\nFROM \n    FCLT_BUILDING_HIST F\nJOIN \n    FCLT_ROOMS R ON F.FCLT_BUILDING_KEY = R.FCLT_BUILDING_KEY\nJOIN \n    EMPLOYEE_DIRECTORY E ON R.BUILDING_ROOM = E.OFFICE_LOCATION\nWHERE \n    F.DATE_BUILT < '1950-01-01'\nGROUP BY \n    F.BUILDING_NAME_LONG, F.DATE_BUILT\nHAVING \n    COUNT(E.MIT_ID) > 100;"
    },
    {
        "db_id": "dw",
        "question": "For each building key, what is the building name and the number of courses offered by the Center for International Studies?",
        "predicted_sql": "SELECT \n    FCLT_BUILDING.FCLT_BUILDING_KEY, \n    FCLT_BUILDING.BUILDING_NAME, \n    COUNT(COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID) AS number_of_courses\nFROM \n    FCLT_BUILDING\nJOIN \n    FCLT_ROOMS ON FCLT_BUILDING.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED ON FCLT_ROOMS.BUILDING_ROOM = COURSE_CATALOG_SUBJECT_OFFERED.PRINT_SUBJECT_ID\nJOIN \n    CIS_COURSE_CATALOG ON COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID = CIS_COURSE_CATALOG.SUBJECT_ID\nWHERE \n    CIS_COURSE_CATALOG.DEPARTMENT_NAME = 'Center for International Studies'\nGROUP BY \n    FCLT_BUILDING.FCLT_BUILDING_KEY, \n    FCLT_BUILDING.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building that accomodates the most students, and how many students does it accomodate?",
        "predicted_sql": "SELECT FB.BUILDING_NAME, COUNT(MS.FULL_NAME) AS student_count\nFROM FCLT_BUILDING FB\nJOIN FCLT_ROOMS FR ON FB.FCLT_BUILDING_KEY = FR.FCLT_BUILDING_KEY\nJOIN MIT_STUDENT_DIRECTORY MS ON FR.BUILDING_ROOM = MS.OFFICE_LOCATION\nGROUP BY FB.BUILDING_NAME\nORDER BY student_count DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "List the name and floor of the building with the largest floor number.",
        "predicted_sql": "SELECT b.BUILDING_NAME, f.FLOOR\nFROM FAC_BUILDING b\nJOIN FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nWHERE f.FLOOR = (SELECT MAX(FLOOR) FROM FAC_FLOOR)"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category and academic year, list the category name, academic year, total fee collected, total number of IAP subjects, and the minimum and maximum enrollment.",
        "predicted_sql": "SELECT \n    isc.IAP_CATEGORY_NAME,\n    td.ACADEMIC_YEAR,\n    SUM(isd.FEE) AS total_fee_collected,\n    COUNT(isd.ACTIVITY_TITLE) AS total_IAP_subjects,\n    MIN(isd.MAX_ENROLLMENT) AS min_enrollment,\n    MAX(isd.MAX_ENROLLMENT) AS max_enrollment\nFROM \n    IAP_SUBJECT_DETAIL isd\nJOIN \n    IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    TIME_DAY td ON isd.TERM_CODE = td.ACADEMIC_TERM_CODE\nGROUP BY \n    isc.IAP_CATEGORY_NAME, td.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor of the independent activity periods, list the sponsor name, number of sessions held, the total number of enrollment, the minimum and maximum fee, the number of sessions with info, and the number of sessions without info.",
        "predicted_sql": "SELECT \n    sp.SPONSOR_NAME,\n    COUNT(DISTINCT s.IAP_SUBJECT_SESSION_KEY) AS number_of_sessions,\n    SUM(d.MAX_ENROLLMENT) AS total_enrollment,\n    MIN(d.FEE) AS minimum_fee,\n    MAX(d.FEE) AS maximum_fee,\n    SUM(CASE WHEN s.HAS_SESSION_INFO = 'Y' THEN 1 ELSE 0 END) AS sessions_with_info,\n    SUM(CASE WHEN s.HAS_SESSION_INFO = 'N' THEN 1 ELSE 0 END) AS sessions_without_info\nFROM \n    IAP_SUBJECT_SPONSOR sp\nJOIN \n    IAP_SUBJECT_DETAIL d ON sp.IAP_SUBJECT_SPONSOR_KEY = d.IAP_SUBJECT_SPONSOR_KEY\nJOIN \n    IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    sp.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the individual's email and name, academic year, total number of IAP subjects, the minimum and maximum fees, and the total course enrollment for each individual and academic year?",
        "predicted_sql": "SELECT \n    sp.PERSON_EMAIL,\n    sp.PERSON_NAME,\n    td.ACADEMIC_YEAR,\n    COUNT(sd.ACTIVITY_TITLE) AS total_subjects,\n    MIN(sd.FEE) AS min_fee,\n    MAX(sd.FEE) AS max_fee,\n    SUM(sd.MAX_ENROLLMENT) AS total_enrollment\nFROM \n    IAP_SUBJECT_PERSON sp\nJOIN \n    IAP_SUBJECT_DETAIL sd ON sp.IAP_SUBJECT_PERSON_KEY = sd.IAP_SUBJECT_PERSON_KEY\nJOIN \n    TIME_DAY td ON sd.TERM_CODE = td.ACADEMIC_TERM_CODE\nGROUP BY \n    sp.PERSON_EMAIL, sp.PERSON_NAME, td.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "What is the term code, term description, total number of IAP sessions, total fee collected, and minimum and maximum enrollment for each term code?",
        "predicted_sql": "SELECT \n    at.TERM_CODE,\n    at.TERM_DESCRIPTION,\n    COUNT(iss.IAP_SUBJECT_SESSION_KEY) AS total_sessions,\n    SUM(isd.FEE) AS total_fee_collected,\n    MIN(isd.MAX_ENROLLMENT) AS min_enrollment,\n    MAX(isd.MAX_ENROLLMENT) AS max_enrollment\nFROM \n    ACADEMIC_TERMS_ALL at\nLEFT JOIN \n    IAP_SUBJECT_DETAIL isd ON at.TERM_CODE = isd.TERM_CODE\nLEFT JOIN \n    IAP_SUBJECT_SESSION iss ON isd.IAP_SUBJECT_SESSION_KEY = iss.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    at.TERM_CODE, \n    at.TERM_DESCRIPTION"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building, total number of subjects, total fee, and shortest and longest sessions for each physical IAP session location?",
        "predicted_sql": "SELECT \n    B.BUILDING_NAME,\n    COUNT(DISTINCT ISD.ACTIVITY_TITLE) AS total_subjects,\n    SUM(ISD.FEE) AS total_fee,\n    MIN(STRFTIME('%H:%M', ISS.SESSION_END_TIME) - STRFTIME('%H:%M', ISS.SESSION_START_TIME)) AS shortest_session,\n    MAX(STRFTIME('%H:%M', ISS.SESSION_END_TIME) - STRFTIME('%H:%M', ISS.SESSION_START_TIME)) AS longest_session\nFROM \n    BUILDINGS B\nJOIN \n    IAP_SUBJECT_SESSION ISS ON B.BUILDING_NUMBER = ISS.SESSION_LOCATION\nJOIN \n    IAP_SUBJECT_DETAIL ISD ON ISS.IAP_SUBJECT_SESSION_KEY = ISD.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    B.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is total number of subjects, the total fee, and the shortest and longest sessions, for all virtual IAP sessions?",
        "predicted_sql": "SELECT \n    COUNT(DISTINCT IAP_SUBJECT_DETAIL.ACTIVITY_TITLE) AS total_subjects,\n    SUM(IAP_SUBJECT_DETAIL.FEE) AS total_fee,\n    MIN(strftime('%H:%M', IAP_SUBJECT_SESSION.SESSION_END_TIME) - strftime('%H:%M', IAP_SUBJECT_SESSION.SESSION_START_TIME)) AS shortest_session,\n    MAX(strftime('%H:%M', IAP_SUBJECT_SESSION.SESSION_END_TIME) - strftime('%H:%M', IAP_SUBJECT_SESSION.SESSION_START_TIME)) AS longest_session\nFROM \n    IAP_SUBJECT_DETAIL\nJOIN \n    IAP_SUBJECT_SESSION ON IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY = IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY\nWHERE \n    IAP_SUBJECT_SESSION.SESSION_LOCATION = 'On line'"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, full name of the department, course level, total number of courses, and total number of degree-granting courses for each school code, department, and course level?",
        "predicted_sql": "SELECT \n    sc.SCHOOL_CODE, \n    sc.SCHOOL_NAME, \n    d.DEPARTMENT_FULL_NAME, \n    cd.COURSE_LEVEL, \n    COUNT(cd.COURSE) AS total_courses, \n    SUM(CASE WHEN cd.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS total_degree_granting_courses\nFROM \n    SIS_COURSE_DESCRIPTION cd\nJOIN \n    SIS_DEPARTMENT d ON cd.DEPARTMENT = d.DEPARTMENT_CODE\nJOIN \n    SIS_SUBJECT_CODE sc ON cd.COURSE = sc.SUBJECT_CODE\nGROUP BY \n    sc.SCHOOL_CODE, \n    sc.SCHOOL_NAME, \n    d.DEPARTMENT_FULL_NAME, \n    cd.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What are the different schools and departments that offer SIS courses? List their school code, school name, department code, department name, the total number of phone numbers, and the most common course level.",
        "predicted_sql": "SELECT \n    SSD.SCHOOL_CODE, \n    SSD.SCHOOL_NAME, \n    SAD.SIS_ADMIN_DEPARTMENT_CODE AS DEPARTMENT_CODE, \n    SAD.SIS_ADMIN_DEPARTMENT_NAME AS DEPARTMENT_NAME, \n    COUNT(SAD.DEPARTMENT_PHONE_NUMBER) AS TOTAL_PHONE_NUMBERS, \n    (SELECT COURSE_LEVEL \n     FROM SIS_COURSE_DESCRIPTION \n     WHERE DEPARTMENT = SAD.SIS_ADMIN_DEPARTMENT_CODE \n     GROUP BY COURSE_LEVEL \n     ORDER BY COUNT(*) DESC \n     LIMIT 1) AS MOST_COMMON_COURSE_LEVEL\nFROM \n    SIS_ADMIN_DEPARTMENT SAD\nJOIN \n    SIS_DEPARTMENT SD ON SAD.SIS_ADMIN_DEPARTMENT_CODE = SD.DEPARTMENT_CODE\nJOIN \n    SIS_COURSE_DESCRIPTION SCD ON SD.DEPARTMENT_CODE = SCD.DEPARTMENT\nJOIN \n    SIS_SUBJECT_CODE SSD ON SCD.COURSE = SSD.SUBJECT_CODE\nGROUP BY \n    SSD.SCHOOL_CODE, SSD.SCHOOL_NAME, SAD.SIS_ADMIN_DEPARTMENT_CODE, SAD.SIS_ADMIN_DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, DLC key, the graduate level, total number of SIS subjects, the minimum and maximum course numbers, and the total number of departments offering subjects for each school?",
        "predicted_sql": "SELECT \n    S.SCHOOL_CODE, \n    S.SCHOOL_NAME, \n    D.DLC_KEY, \n    C.GRADUATE_LEVEL, \n    COUNT(DISTINCT S.SUBJECT_CODE) AS total_sis_subjects, \n    MIN(S.COURSE_NUMBER) AS min_course_number, \n    MAX(S.COURSE_NUMBER) AS max_course_number, \n    COUNT(DISTINCT D.DEPARTMENT_CODE) AS total_departments\nFROM \n    SIS_SUBJECT_CODE S\nJOIN \n    SIS_COURSE_DESCRIPTION C ON S.SUBJECT_CODE = C.COURSE\nJOIN \n    SIS_DEPARTMENT D ON C.DEPARTMENT = D.DEPARTMENT_CODE\nGROUP BY \n    S.SCHOOL_CODE, \n    S.SCHOOL_NAME, \n    D.DLC_KEY, \n    C.GRADUATE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What is the building component, name of the building, square footage for all rooms, total number of floors, total number of rooms, total number of facility organizations, total number of supervisors, and total number of supervisees for each building component?",
        "predicted_sql": "SELECT \n    sd.BUILDING_COMPONENT,\n    b.BUILDING_NAME,\n    SUM(sd.ROOM_SQUARE_FOOTAGE) AS total_square_footage,\n    COUNT(DISTINCT sf.FLOOR) AS total_floors,\n    COUNT(DISTINCT sd.BUILDING_ROOM) AS total_rooms,\n    COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS total_facility_organizations,\n    COUNT(DISTINCT su.MIT_ID) AS total_supervisors,\n    SUM(su.NUM_OF_SUPERVISEES) AS total_supervisees\nFROM \n    SPACE_DETAIL sd\nJOIN \n    BUILDINGS b ON sd.BUILDING_KEY = b.BUILDING_KEY\nJOIN \n    SPACE_FLOOR sf ON sf.FLOOR_KEY = sd.FLOOR_KEY\nLEFT JOIN \n    SPACE_UNIT su ON su.SPACE_UNIT_KEY = sd.SPACE_UNIT_KEY\nLEFT JOIN \n    SPACE_SUPERVISOR_USAGE ssu ON ssu.DEPT_NAMES = su.DLC_KEY\nGROUP BY \n    sd.BUILDING_COMPONENT, b.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the DLC key, name of the DLC, total number of floors, total square footage, total number of facility organizations, total number of supervisors, total number of supervisees, and total building heights for each DLC?",
        "predicted_sql": "SELECT \n    su.DLC_KEY AS \"DLC key\",\n    fo.DLC_NAME AS \"name of the DLC\",\n    COUNT(DISTINCT sf.FLOOR_KEY) AS \"total number of floors\",\n    SUM(sd.ROOM_SQUARE_FOOTAGE) AS \"total square footage\",\n    COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS \"total number of facility organizations\",\n    COUNT(DISTINCT su.MIT_ID) AS \"total number of supervisors\",\n    SUM(su.NUM_OF_SUPERVISEES) AS \"total number of supervisees\",\n    SUM(fb.BUILDING_HEIGHT) AS \"total building heights\"\nFROM \n    SPACE_UNIT su\nJOIN \n    SPACE_SUPERVISOR_USAGE su ON su.DLC_KEY = su.DEPT_NAMES\nJOIN \n    SPACE_DETAIL sd ON sd.BUILDING_KEY = su.SPACE_UNIT_KEY\nJOIN \n    SPACE_FLOOR sf ON sf.FLOOR_KEY = sd.FLOOR_KEY\nJOIN \n    FCLT_ORGANIZATION fo ON fo.DLC_KEY = su.DLC_KEY\nJOIN \n    FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = sd.BUILDING_KEY\nGROUP BY \n    su.DLC_KEY, fo.DLC_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the department name, total number of types of TIP subjects, total number of enrolled students, the minimum and maximum rental new price for each department?",
        "predicted_sql": "SELECT \n    s.OFFER_DEPT_NAME,\n    COUNT(DISTINCT s.SUBJECT_ID) AS total_tip_subjects,\n    SUM(s.NUM_ENROLLED_STUDENTS) AS total_enrolled_students,\n    MIN(m.RENTAL_NEW_PRICE) AS min_rental_new_price,\n    MAX(m.RENTAL_NEW_PRICE) AS max_rental_new_price\nFROM \n    TIP_SUBJECT_OFFERED s\nJOIN \n    TIP_DETAIL d ON s.TIP_SUBJECT_OFFERED_KEY = d.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL m ON d.TIP_MATERIAL_KEY = m.TIP_MATERIAL_KEY\nGROUP BY \n    s.OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the details of courses offered in the current academic term, including the academic year, term code, hgn code, the total number of types of courses, the average number of units, the department name, the name and email address of the person in charge?",
        "predicted_sql": "SELECT \n    ACADEMIC_TERMS.ACADEMIC_YEAR, \n    COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE, \n    SUBJECT_OFFERED.HGN_CODE, \n    COUNT(DISTINCT COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID) AS total_number_of_courses, \n    AVG(COURSE_CATALOG_SUBJECT_OFFERED.TOTAL_UNITS) AS average_units, \n    COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME, \n    EMPLOYEE_DIRECTORY.FULL_NAME, \n    EMPLOYEE_DIRECTORY.EMAIL_ADDRESS\nFROM \n    ACADEMIC_TERMS\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED ON ACADEMIC_TERMS.TERM_CODE = COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE\nJOIN \n    SUBJECT_OFFERED ON COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID = SUBJECT_OFFERED.SUBJECT_ID\nJOIN \n    EMPLOYEE_DIRECTORY ON SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID = EMPLOYEE_DIRECTORY.MIT_ID\nWHERE \n    ACADEMIC_TERMS.IS_CURRENT_TERM = 'Y'\nGROUP BY \n    ACADEMIC_TERMS.ACADEMIC_YEAR, \n    COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE, \n    SUBJECT_OFFERED.HGN_CODE, \n    COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME, \n    EMPLOYEE_DIRECTORY.FULL_NAME, \n    EMPLOYEE_DIRECTORY.EMAIL_ADDRESS;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve information about the IAP subjects, including their titles, categories, session titles, session start time, session end time, sponsor names, and total number of sessions.",
        "predicted_sql": "SELECT \n    IAP_SUBJECT_DETAIL.ACTIVITY_TITLE AS title,\n    IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME AS category,\n    IAP_SUBJECT_SESSION.SESSION_TITLE AS session_title,\n    IAP_SUBJECT_SESSION.SESSION_START_TIME AS session_start_time,\n    IAP_SUBJECT_SESSION.SESSION_END_TIME AS session_end_time,\n    IAP_SUBJECT_SPONSOR.SPONSOR_NAME AS sponsor_name,\n    COUNT(IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY) OVER (PARTITION BY IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY) AS total_sessions\nFROM \n    IAP_SUBJECT_DETAIL\nJOIN \n    IAP_SUBJECT_CATEGORY ON IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY = IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    IAP_SUBJECT_SESSION ON IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY = IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY\nJOIN \n    IAP_SUBJECT_SPONSOR ON IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY = IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY;"
    },
    {
        "db_id": "dw",
        "question": "Show the department names, the corresponding SIS subject code, subject code descriptions, graduate level, and the total number of courses per department.",
        "predicted_sql": "SELECT \n    d.DEPARTMENT_NAME, \n    s.SUBJECT_CODE, \n    s.SUBJECT_CODE_DESC, \n    c.GRADUATE_LEVEL, \n    COUNT(s.COURSE_NUMBER) AS total_courses\nFROM \n    SIS_DEPARTMENT d\nJOIN \n    SIS_COURSE_DESCRIPTION c ON c.DEPARTMENT = d.DEPARTMENT_CODE\nJOIN \n    SIS_SUBJECT_CODE s ON s.COURSE_NUMBER = c.COURSE\nGROUP BY \n    d.DEPARTMENT_NAME, s.SUBJECT_CODE, s.SUBJECT_CODE_DESC, c.GRADUATE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "For each term, list the term code, the term description, whether the term is current or not, and the total number of types of CIS courses.",
        "predicted_sql": "SELECT \n    ata.TERM_CODE, \n    ata.TERM_DESCRIPTION, \n    atp.IS_CURRENT_TERM, \n    COUNT(DISTINCT ccc.SUBJECT_ID) AS total_types_of_cis_courses\nFROM \n    ACADEMIC_TERMS_ALL ata\nLEFT JOIN \n    ACADEMIC_TERM_PARAMETER atp ON ata.TERM_CODE = atp.TERM_CODE\nLEFT JOIN \n    CIS_COURSE_CATALOG ccc ON ccc.ACADEMIC_YEAR = ata.ACADEMIC_YEAR\nGROUP BY \n    ata.TERM_CODE, \n    ata.TERM_DESCRIPTION, \n    atp.IS_CURRENT_TERM;"
    },
    {
        "db_id": "dw",
        "question": "What is the author, school name, material status, total record counts, and total number of types of courses for each author and school?",
        "predicted_sql": "SELECT \n    m.AUTHOR,\n    d.SCHOOL_NAME,\n    s.TIP_MATERIAL_STATUS,\n    SUM(td.RECORD_COUNT) AS total_record_counts,\n    COUNT(DISTINCT td.SUBJECT_ID) AS total_number_of_types_of_courses\nFROM \n    TIP_MATERIAL m\nJOIN \n    TIP_DETAIL td ON m.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY\nJOIN \n    TIP_MATERIAL_STATUS s ON s.TIP_MATERIAL_STATUS_KEY = td.TIP_MATERIAL_STATUS_KEY\nJOIN \n    TIP_SUBJECT_OFFERED o ON o.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    STUDENT_DEPARTMENT d ON d.DEPARTMENT_CODE = o.OFFER_DEPT_CODE\nGROUP BY \n    m.AUTHOR, d.SCHOOL_NAME, s.TIP_MATERIAL_STATUS"
    },
    {
        "db_id": "dw",
        "question": "What is the course number, subject title, material status, the total, min, and max new shelf price, the total, min, and max used shelf price, total number of schools and the total number of materials for each TIP subject and material status?",
        "predicted_sql": "SELECT \n    tso.COURSE_NUMBER,\n    tso.SUBJECT_TITLE,\n    tms.TIP_MATERIAL_STATUS,\n    COUNT(DISTINCT tso.OFFER_SCHOOL_NAME) AS total_schools,\n    COUNT(td.TIP_MATERIAL_KEY) AS total_materials,\n    SUM(tm.NEW_SHELF_PRICE) AS total_new_price,\n    MIN(tm.NEW_SHELF_PRICE) AS min_new_price,\n    MAX(tm.NEW_SHELF_PRICE) AS max_new_price,\n    SUM(tm.USED_SHELF_PRICE) AS total_used_price,\n    MIN(tm.USED_SHELF_PRICE) AS min_used_price,\n    MAX(tm.USED_SHELF_PRICE) AS max_used_price\nFROM \n    TIP_SUBJECT_OFFERED tso\nJOIN \n    TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN \n    TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nGROUP BY \n    tso.COURSE_NUMBER, \n    tso.SUBJECT_TITLE, \n    tms.TIP_MATERIAL_STATUS"
    },
    {
        "db_id": "dw",
        "question": "What is material status, the total number of materials, the total number of subjects, the total number of schools, and the most recent publication year for each material status?",
        "predicted_sql": "SELECT \n    TMS.TIP_MATERIAL_STATUS AS material_status,\n    COUNT(DISTINCT TD.TIP_MATERIAL_KEY) AS total_materials,\n    COUNT(DISTINCT TD.SUBJECT_ID) AS total_subjects,\n    COUNT(DISTINCT SD.SCHOOL_NAME) AS total_schools,\n    MAX(TM.YEAR) AS most_recent_publication_year\nFROM \n    TIP_DETAIL TD\nJOIN \n    TIP_MATERIAL TM ON TM.TIP_MATERIAL_KEY = TD.TIP_MATERIAL_KEY\nJOIN \n    TIP_MATERIAL_STATUS TMS ON TMS.TIP_MATERIAL_STATUS_KEY = TD.TIP_MATERIAL_STATUS_KEY\nJOIN \n    TIP_SUBJECT_OFFERED TSO ON TSO.TIP_SUBJECT_OFFERED_KEY = TD.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    STUDENT_DEPARTMENT SD ON SD.DEPARTMENT_CODE = TSO.OFFER_DEPT_CODE\nGROUP BY \n    TMS.TIP_MATERIAL_STATUS"
    },
    {
        "db_id": "dw",
        "question": "What is the term description, whether the term is current or not, total number of types of TIP subjects offered and materials needed, the minimum and maximum number of enrolled students, the total number of schools offering subjects, and the total number of records for each term code?",
        "predicted_sql": "SELECT \n    at.TERM_DESCRIPTION,\n    at.IS_CURRENT_TERM,\n    COUNT(DISTINCT tso.COURSE_NUMBER) AS total_tip_subjects_offered,\n    COUNT(DISTINCT tm.ISBN) AS total_materials_needed,\n    MIN(tso.NUM_ENROLLED_STUDENTS) AS min_enrolled_students,\n    MAX(tso.NUM_ENROLLED_STUDENTS) AS max_enrolled_students,\n    COUNT(DISTINCT tso.OFFER_SCHOOL_NAME) AS total_schools_offering_subjects,\n    COUNT(td.RECORD_COUNT) AS total_records\nFROM \n    ACADEMIC_TERMS_ALL at\nLEFT JOIN \n    TIP_SUBJECT_OFFERED tso ON at.TERM_CODE = tso.TERM_CODE\nLEFT JOIN \n    TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nLEFT JOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nGROUP BY \n    at.TERM_DESCRIPTION, at.IS_CURRENT_TERM;"
    },
    {
        "db_id": "dw",
        "question": "List all buildings with their names, building numbers, building height, street address, city, state, HR department name, assignable square footage, total and average square footage, ordered in descending order of assignable, total, and average square footage.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME,\n    b.BUILDING_NUMBER,\n    fb.BUILDING_HEIGHT,\n    b.BUILDING_STREET_ADDRESS,\n    fa.CITY,\n    fa.STATE,\n    fo.HR_DEPARTMENT_NAME,\n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE,\n    SUM(fr.AREA) AS total_square_footage,\n    AVG(fr.AREA) AS average_square_footage\nFROM \n    BUILDINGS b\nJOIN \n    FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY\nJOIN \n    FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS fa ON b.BUILDING_KEY = fa.BUILDING_KEY\nJOIN \n    FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY\nGROUP BY \n    b.BUILDING_NAME,\n    b.BUILDING_NUMBER,\n    fb.BUILDING_HEIGHT,\n    b.BUILDING_STREET_ADDRESS,\n    fa.CITY,\n    fa.STATE,\n    fo.HR_DEPARTMENT_NAME,\n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE\nORDER BY \n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE DESC,\n    total_square_footage DESC,\n    average_square_footage DESC;"
    },
    {
        "db_id": "dw",
        "question": "For the 2023 Fall term, what are the unique term descriptions, subject titles along with their prerequisites, total number of types of subjects per term code, instructor of this course, and the number of types of courses ever taught by the instructor?",
        "predicted_sql": "SELECT \n    DISTINCT a.TERM_DESCRIPTION, \n    c.SUBJECT_TITLE, \n    c.PREREQUISITES, \n    COUNT(DISTINCT c.SUBJECT_ID) OVER (PARTITION BY c.TERM_CODE) AS TYPE_COUNT,\n    c.FALL_INSTRUCTORS,\n    COUNT(DISTINCT c.SUBJECT_ID) OVER (PARTITION BY c.FALL_INSTRUCTORS) AS INSTRUCTOR_COURSE_COUNT\nFROM \n    ACADEMIC_TERMS a\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED c ON a.TERM_CODE = c.TERM_CODE\nWHERE \n    a.TERM_CODE = '2023FA';"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the assignable floor area and building.",
        "predicted_sql": "SELECT \n    FR.ROOM_FULL_NAME,\n    FB.BUILDING_NAME,\n    FF.FLOOR,\n    FO.ORGANIZATION_NAME,\n    FO.HR_DEPARTMENT_NAME,\n    (FR.AREA / FF.ASSIGNABLE_AREA * 100) AS ROOM_AREA_PERCENTAGE,\n    (FR.AREA / (SELECT SUM(FS.ASSIGNABLE_AREA) FROM FAC_FLOOR AS FS WHERE FS.BUILDING_KEY = FR.BUILDING_KEY) * 100) AS ROOM_AREA_PERCENTAGE_BUILDING\nFROM \n    FAC_ROOMS FR\nJOIN \n    FAC_FLOOR FF ON FR.FLOOR_KEY = FF.FLOOR_KEY\nJOIN \n    FAC_BUILDING FB ON FR.BUILDING_KEY = FB.FAC_BUILDING_KEY\nJOIN \n    FAC_ORGANIZATION FO ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the floor area and building.",
        "predicted_sql": "SELECT \n    FR.ROOM_FULL_NAME,\n    FB.BUILDING_NAME,\n    FF.FLOOR,\n    FO.ORGANIZATION_NAME,\n    FO.HR_DEPARTMENT_NAME,\n    (FR.AREA / FF.ASSIGNABLE_AREA * 100) AS ROOM_AREA_PERCENTAGE,\n    (FR.AREA / FF.EXT_GROSS_AREA * 100) AS ROOM_AREA_PERCENTAGE_BUILDING\nFROM \n    FAC_ROOMS FR\nJOIN \n    FAC_BUILDING FB ON FR.BUILDING_KEY = FB.FAC_BUILDING_KEY\nJOIN \n    FAC_FLOOR FF ON FR.BUILDING_KEY = FF.BUILDING_KEY AND FR.FLOOR = FF.FLOOR\nJOIN \n    FAC_ORGANIZATION FO ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What are the academic year, and instructors names for courses offered in the academic year 2022, along with the total number of types of courses per instructor?",
        "predicted_sql": "SELECT \n    ACADEMIC_TERMS_ALL.ACADEMIC_YEAR, \n    EMPLOYEE_DIRECTORY.FULL_NAME, \n    COUNT(DISTINCT SUBJECT_OFFERED.COURSE_NUMBER) AS total_course_types\nFROM \n    ACADEMIC_TERMS_ALL\nJOIN \n    SUBJECT_OFFERED ON ACADEMIC_TERMS_ALL.TERM_CODE = SUBJECT_OFFERED.TERM_CODE\nJOIN \n    EMPLOYEE_DIRECTORY ON SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID = EMPLOYEE_DIRECTORY.MIT_ID\nWHERE \n    ACADEMIC_TERMS_ALL.ACADEMIC_YEAR = '2022'\nGROUP BY \n    ACADEMIC_TERMS_ALL.ACADEMIC_YEAR, \n    EMPLOYEE_DIRECTORY.FULL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the building names, department names, organizations, their highest and lowest floor number, along with the total number of rooms per each building key?",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME, \n    o.HR_DEPARTMENT_NAME, \n    o.ORGANIZATION, \n    MIN(f.FLOOR) AS lowest_floor, \n    MAX(f.FLOOR) AS highest_floor, \n    COUNT(r.FAC_ROOM_KEY) AS total_rooms\nFROM \n    FAC_BUILDING b\nJOIN \n    FAC_ROOMS r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY\nJOIN \n    FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nJOIN \n    FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\nGROUP BY \n    b.BUILDING_NAME, \n    o.HR_DEPARTMENT_NAME, \n    o.ORGANIZATION;"
    },
    {
        "db_id": "dw",
        "question": "Provide the complete information for students with the first name Kevin, including their full names, email addresses, department names, department phone numbers, school names, and the total student count per department and school. If a student is associated with more than one department, list a separate row for each department.",
        "predicted_sql": "SELECT \n    MSD.FULL_NAME, \n    MSD.EMAIL_ADDRESS, \n    SD.DEPARTMENT_NAME, \n    SAD.DEPARTMENT_PHONE_NUMBER, \n    SD.SCHOOL_NAME, \n    COUNT(*) OVER (PARTITION BY SD.DEPARTMENT_NAME, SD.SCHOOL_NAME) AS TOTAL_STUDENT_COUNT\nFROM \n    MIT_STUDENT_DIRECTORY MSD\nJOIN \n    SIS_DEPARTMENT SD ON MSD.DEPARTMENT = SD.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT SAD ON SD.DEPARTMENT_CODE = SAD.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    MSD.FIRST_NAME = 'Kevin';"
    },
    {
        "db_id": "dw",
        "question": "What are the unique titles of subjects offered in the fall term along with their instructor names, instructor emails, and the total number of types of subjects per instructor?",
        "predicted_sql": "SELECT DISTINCT c.SUBJECT_TITLE, e.FULL_NAME AS INSTRUCTOR_NAME, e.EMAIL_ADDRESS AS INSTRUCTOR_EMAIL, COUNT(DISTINCT c.SUBJECT_ID) AS SUBJECT_COUNT\nFROM COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nJOIN ACADEMIC_TERMS_ALL t ON c.TERM_CODE = t.TERM_CODE\nWHERE t.TERM_CODE LIKE '%FA%'\nGROUP BY c.SUBJECT_TITLE, e.FULL_NAME, e.EMAIL_ADDRESS;"
    },
    {
        "db_id": "dw",
        "question": "List the building names, names of HR departments occupying them, the total gross square footage, the total and average assignable square footage, and the built year per building key.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME, \n    fo.HR_DEPARTMENT_NAME, \n    b.BLDG_GROSS_SQUARE_FOOTAGE, \n    SUM(b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) AS total_assignable_square_footage, \n    AVG(b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) AS average_assignable_square_footage, \n    fb.DATE_BUILT \nFROM \n    BUILDINGS b \nJOIN \n    FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY \nJOIN \n    FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY \nJOIN \n    FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY \nGROUP BY \n    b.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, b.BLDG_GROSS_SQUARE_FOOTAGE, fb.DATE_BUILT;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve the titles of subjects offered in the summer term along with their descriptions, responsible faculty names, email address, building name, room name, floor level, building street address, and the total number of types of courses per departmnet.",
        "predicted_sql": "SELECT \n    C.SUBJECT_TITLE,\n    C.SUBJECT_DESCRIPTION,\n    C.RESPONSIBLE_FACULTY_NAME,\n    E.EMAIL_ADDRESS,\n    B.BUILDING_NAME,\n    R.ROOM_FULL_NAME,\n    F.LEVEL_ID,\n    B.BUILDING_STREET_ADDRESS,\n    COUNT(DISTINCT C.SUBJECT_ID) AS TOTAL_COURSE_TYPES\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN \n    ACADEMIC_TERMS T ON C.TERM_CODE = T.TERM_CODE\nJOIN \n    EMPLOYEE_DIRECTORY E ON C.RESPONSIBLE_FACULTY_MIT_ID = E.MIT_ID\nJOIN \n    FAC_ROOMS R ON C.MEET_PLACE = R.FAC_ROOM_KEY\nJOIN \n    FAC_FLOOR F ON R.FLOOR_KEY = F.FLOOR_KEY\nJOIN \n    BUILDINGS B ON R.BUILDING_KEY = B.BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS A ON B.BUILDING_KEY = A.BUILDING_KEY\nWHERE \n    T.TERM_CODE LIKE '%SUMMER%' \nGROUP BY \n    C.SUBJECT_TITLE, C.SUBJECT_DESCRIPTION, C.RESPONSIBLE_FACULTY_NAME, E.EMAIL_ADDRESS, B.BUILDING_NAME, R.ROOM_FULL_NAME, F.LEVEL_ID, B.BUILDING_STREET_ADDRESS"
    },
    {
        "db_id": "dw",
        "question": "For each term code, list the term description, attribute desciption, department name, school name, and the number of subjects in the area of humanities, arts and social sciences.",
        "predicted_sql": "SELECT \n    at.TERM_CODE, \n    at.TERM_DESCRIPTION, \n    ca.HASS_ATTRIBUTE_DESC, \n    d.DEPARTMENT_NAME, \n    d.SCHOOL_NAME, \n    COUNT(ca.SUBJECT_ID) AS NUMBER_OF_SUBJECTS\nFROM \n    ACADEMIC_TERMS_ALL at\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED ca ON at.TERM_CODE = ca.TERM_CODE\nJOIN \n    CIS_HASS_ATTRIBUTE cha ON ca.HASS_ATTRIBUTE = cha.HASS_ATTRIBUTE\nJOIN \n    SIS_DEPARTMENT d ON ca.DEPARTMENT_CODE = d.DEPARTMENT_CODE\nWHERE \n    cha.CIS_ATTRIBUTE_GROUP = 'H'\nGROUP BY \n    at.TERM_CODE, \n    at.TERM_DESCRIPTION, \n    ca.HASS_ATTRIBUTE_DESC, \n    d.DEPARTMENT_NAME, \n    d.SCHOOL_NAME\nORDER BY \n    at.TERM_CODE;"
    },
    {
        "db_id": "dw",
        "question": "List building names, their height, street address, city, state, postal code, their gross and assignable square footage, the smallest and largest floor level and the total area of all rooms for each building key.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME,\n    fb.BUILDING_HEIGHT,\n    b.BUILDING_STREET_ADDRESS,\n    fba.CITY,\n    fba.STATE,\n    fba.POSTAL_CODE,\n    fb.EXT_GROSS_AREA,\n    fb.ASSIGNABLE_AREA,\n    MIN(ff.LEVEL_ID) AS smallest_floor_level,\n    MAX(ff.LEVEL_ID) AS largest_floor_level,\n    SUM(fr.AREA) AS total_room_area\nFROM \n    BUILDINGS b\nJOIN \n    FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS fba ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY\nJOIN \n    FAC_FLOOR ff ON fb.FAC_BUILDING_KEY = ff.BUILDING_KEY\nJOIN \n    FAC_ROOMS fr ON ff.FLOOR_KEY = fr.FLOOR_KEY\nGROUP BY \n    b.BUILDING_NAME, fb.BUILDING_HEIGHT, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, fb.EXT_GROSS_AREA, fb.ASSIGNABLE_AREA;"
    },
    {
        "db_id": "dw",
        "question": "What is the category title, version, department name, school name, total number of courses for each course level, and the total number of degree-granting courses for each CIP category code?",
        "predicted_sql": "SELECT \n    CIP.CATEGORY_TITLE, \n    CIP.VERSION, \n    SIS_DEPARTMENT.DEPARTMENT_NAME, \n    SIS_DEPARTMENT.SCHOOL_NAME, \n    SIS_COURSE_DESCRIPTION.COURSE_LEVEL, \n    COUNT(SIS_COURSE_DESCRIPTION.COURSE) AS total_courses, \n    SUM(CASE WHEN SIS_COURSE_DESCRIPTION.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS total_degree_granting_courses\nFROM \n    CIP \nJOIN \n    SIS_COURSE_DESCRIPTION ON CIP.PROGRAM_CODE = SIS_COURSE_DESCRIPTION.CIP_PROGRAM_CODE \nJOIN \n    SIS_DEPARTMENT ON SIS_COURSE_DESCRIPTION.DEPARTMENT = SIS_DEPARTMENT.DEPARTMENT_CODE\nGROUP BY \n    CIP.CATEGORY_TITLE, \n    CIP.VERSION, \n    SIS_DEPARTMENT.DEPARTMENT_NAME, \n    SIS_DEPARTMENT.SCHOOL_NAME, \n    SIS_COURSE_DESCRIPTION.COURSE_LEVEL\nORDER BY \n    CIP.CATEGORY_TITLE, \n    SIS_DEPARTMENT.DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library materials, the minimum and maximum publication years, and the total number of materials status for each course name?",
        "predicted_sql": "SELECT \n    LCI.COURSE_NAME,\n    COUNT(LRCD.CATALOG_SYSTEM_NUMBER) AS total_materials,\n    MIN(LRCD.CATALOG_YEAR) AS min_publication_year,\n    MAX(LRCD.CATALOG_YEAR) AS max_publication_year,\n    COUNT(DISTINCT LMS.LIBRARY_MATERIAL_STATUS) AS total_material_status\nFROM \n    LIBRARY_COURSE_INSTRUCTOR LCI\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRCD ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRCD.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS LMS ON LRMD.LIBRARY_MATERIAL_STATUS_KEY = LMS.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    LCI.COURSE_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library reserve materials, the minimum and maximum publication years, and the total number of enrolled students for each course instructor?",
        "predicted_sql": "SELECT \n    LCI.INSTRUCTOR_NAME,\n    COUNT(DISTINCT LRC.CATALOG_SYSTEM_NUMBER) AS TOTAL_LIBRARY_RESERVE_MATERIALS,\n    MIN(LRC.CATALOG_YEAR) AS MIN_PUBLICATION_YEAR,\n    MAX(LRC.CATALOG_YEAR) AS MAX_PUBLICATION_YEAR,\n    SUM(LSO.NUM_ENROLLED_STUDENTS) AS TOTAL_ENROLLED_STUDENTS\nFROM \n    LIBRARY_COURSE_INSTRUCTOR LCI\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED LSO ON LRMD.LIBRARY_SUBJECT_OFFERED_KEY = LSO.LIBRARY_SUBJECT_OFFERED_KEY\nGROUP BY \n    LCI.INSTRUCTOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the material status, term description, total number of courses and materials, occurences in departments and school, and the total number of instructors for each library material status code and term code?",
        "predicted_sql": "SELECT \n    LMS.LIBRARY_MATERIAL_STATUS,\n    ATA.TERM_DESCRIPTION,\n    COUNT(DISTINCT LSO.COURSE_NUMBER) AS total_courses,\n    COUNT(DISTINCT LRC.CATALOG_SYSTEM_NUMBER) AS total_materials,\n    COUNT(DISTINCT LSO.OFFER_DEPT_CODE) AS occurrences_in_departments,\n    COUNT(DISTINCT LSO.OFFER_SCHOOL_NAME) AS occurrences_in_schools,\n    COUNT(DISTINCT LCI.INSTRUCTOR_NAME) AS total_instructors\nFROM \n    LIBRARY_MATERIAL_STATUS LMS\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LMS.LIBRARY_MATERIAL_STATUS_KEY = LRMD.LIBRARY_MATERIAL_STATUS_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED LSO ON LSO.LIBRARY_SUBJECT_OFFERED_KEY = LRMD.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRC ON LRC.LIBRARY_RESERVE_CATALOG_KEY = LRMD.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    ACADEMIC_TERMS_ALL ATA ON ATA.TERM_CODE = LSO.TERM_CODE\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR LCI ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    LMS.LIBRARY_MATERIAL_STATUS,\n    ATA.TERM_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "For building 36, list all space units, their floor and building name, building street address, their space usage, and the number of organizations and space units on the same building and floor.",
        "predicted_sql": "SELECT \n    SU.SPACE_UNIT,\n    SF.FLOOR,\n    B.BUILDING_NAME,\n    B.BUILDING_STREET_ADDRESS,\n    U.SPACE_USAGE,\n    COUNT(DISTINCT O.FCLT_ORGANIZATION_KEY) AS organization_count,\n    COUNT(DISTINCT SU.SPACE_UNIT_KEY) AS space_unit_count\nFROM \n    BUILDINGS B\nJOIN \n    SPACE_DETAIL SD ON B.BUILDING_KEY = SD.BUILDING_KEY\nJOIN \n    SPACE_UNIT SU ON SD.SPACE_UNIT_KEY = SU.SPACE_UNIT_KEY\nJOIN \n    SPACE_FLOOR SF ON SD.FLOOR_KEY = SF.FLOOR_KEY\nJOIN \n    SPACE_USAGE U ON SD.SPACE_USAGE_KEY = U.SPACE_USAGE_KEY\nJOIN \n    FCLT_ORGANIZATION O ON SU.FCLT_ORGANIZATION_KEY = O.FCLT_ORGANIZATION_KEY\nWHERE \n    B.BUILDING_NUMBER = '36'\nGROUP BY \n    SU.SPACE_UNIT, SF.FLOOR, B.BUILDING_NAME, B.BUILDING_STREET_ADDRESS, U.SPACE_USAGE;"
    },
    {
        "db_id": "dw",
        "question": "For each distinct mailing list containing more than 1000 people and with a name starting with A (case insensitive), provide its name, whether it is a mailing list, whether it is a moira group, whether it is a NFS group, the owner of the mailing list, and the number of people in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME, \n    ml.IS_MOIRA_MAILING_LIST, \n    ml.IS_MOIRA_GROUP, \n    ml.IS_NFS_GROUP, \n    mo.OWNER, \n    COUNT(dl.MOIRA_LIST_MEMBER) AS member_count\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL dl ON ml.MOIRA_LIST_KEY = dl.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER mo ON dl.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY\nWHERE \n    LOWER(ml.MOIRA_LIST_NAME) LIKE 'a%' \nGROUP BY \n    ml.MOIRA_LIST_NAME, ml.IS_MOIRA_MAILING_LIST, ml.IS_MOIRA_GROUP, ml.IS_NFS_GROUP, mo.OWNER\nHAVING \n    COUNT(dl.MOIRA_LIST_MEMBER) > 1000;"
    },
    {
        "db_id": "dw",
        "question": "List the mailing lists with the largest number of members and the least number of members, including their names, owners, public status, hidden status, and number of members in the list. If a mailing list has multiple owners, create a separate entry for each owner. Similarly, if multiple lists share the minimum or maximum member count, include all those lists.",
        "predicted_sql": "WITH MemberCounts AS (\n    SELECT\n        ml.MOIRA_LIST_NAME,\n        mld.MOIRA_LIST_MEMBER,\n        mol.OWNER,\n        ml.IS_PUBLIC,\n        ml.IS_HIDDEN,\n        COUNT(mld.MOIRA_LIST_MEMBER) OVER (PARTITION BY ml.MOIRA_LIST_KEY) AS member_count\n    FROM\n        MOIRA_LIST ml\n    JOIN\n        MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n    JOIN\n        MOIRA_LIST_OWNER mol ON mld.MOIRA_LIST_OWNER_KEY = mol.MOIRA_LIST_OWNER_KEY\n    WHERE\n        ml.IS_MOIRA_MAILING_LIST = 'Y'\n)\nSELECT\n    MOIRA_LIST_NAME,\n    OWNER,\n    IS_PUBLIC,\n    IS_HIDDEN,\n    member_count\nFROM\n    MemberCounts\nWHERE\n    member_count = (SELECT MAX(member_count) FROM MemberCounts)\n    OR member_count = (SELECT MIN(member_count) FROM MemberCounts);"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with C (case insensitive) and containing faculty who teach courses in the summer in financial aid years after 2001, provide the name of the list, the number of people in the list, and the number of faculty in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME, \n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS total_people, \n    COUNT(DISTINCT ed.MIT_ID) AS total_faculty\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    EMPLOYEE_DIRECTORY ed ON mld.MOIRA_LIST_MEMBER_MIT_ID = ed.MIT_ID\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED cc ON ed.MIT_ID = cc.RESPONSIBLE_FACULTY_MIT_ID\nJOIN \n    ACADEMIC_TERMS at ON cc.TERM_CODE = at.TERM_CODE\nWHERE \n    ml.MOIRA_LIST_NAME ILIKE 'C%' \n    AND at.FINANCIAL_AID_YEAR > '2001' \n    AND at.IS_OFFERED_SUMMER_TERM = 'Y'\nGROUP BY \n    ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Regarding the mailing list about duo users, provide the number of students in this list, and the number of departments and schools associated with these students.",
        "predicted_sql": "SELECT \n    COUNT(DISTINCT md.MOIRA_LIST_MEMBER_MIT_ID) AS student_count,\n    COUNT(DISTINCT sd.DEPARTMENT_CODE) AS department_count,\n    COUNT(DISTINCT sd.SCHOOL_CODE) AS school_count\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL md ON ml.MOIRA_LIST_KEY = md.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON md.MOIRA_LIST_MEMBER_MIT_ID = sp.MIT_ID\nJOIN \n    MIT_STUDENT_DIRECTORY msd ON sp.MIT_ID = msd.EMAIL_ADDRESS\nJOIN \n    SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nWHERE \n    ml.MOIRA_LIST_NAME = 'cat-duo-users'"
    },
    {
        "db_id": "dw",
        "question": "For faculty who are responsible for courses in 2023 fall term, list the name of mailing lists with ten members that they subscribe to, the number of faculty in these lists, and the number of courses associated with those faculty.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER_MIT_ID) AS number_of_faculty,\n    COUNT(DISTINCT c.SUBJECT_TITLE) AS number_of_courses\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nJOIN \n    MOIRA_LIST_DETAIL mld ON e.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN \n    MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nWHERE \n    c.TERM_CODE = '2023FA' \nGROUP BY \n    ml.MOIRA_LIST_NAME\nHAVING \n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) = 10;"
    },
    {
        "db_id": "dw",
        "question": "For each course instructor in the 'keeper-zephyr' mailing list, provide the name of mailing lists they subscribe to, instructor name, earliest and latest publication years, and total number of enrolled students.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME, \n    lci.INSTRUCTOR_NAME, \n    MIN(lrc.CATALOG_YEAR) AS Earliest_Publication_Year, \n    MAX(lrc.CATALOG_YEAR) AS Latest_Publication_Year, \n    lso.NUM_ENROLLED_STUDENTS\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR lci ON sp.FULL_NAME = lci.INSTRUCTOR_NAME\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrcd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrcd.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrcd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED lso ON lrcd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nWHERE \n    ml.MOIRA_LIST_NAME = 'keeper-zephyr'\nGROUP BY \n    ml.MOIRA_LIST_NAME, lci.INSTRUCTOR_NAME, lso.NUM_ENROLLED_STUDENTS;"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list with a name beginning with R (case insensitive), and that Professor Ayden Hopkins is subscribed to, list its name, description, owner, number of people in the list, and number of tenured faculty in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME, \n    ml.MOIRA_LIST_DESCRIPTION, \n    mo.OWNER,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS number_of_people,\n    COUNT(CASE WHEN sp.PAYROLL_RANK LIKE '%tenured%' THEN 1 END) AS number_of_tenured_faculty\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER mo ON mo.MOIRA_LIST_OWNER_KEY = mld.MOIRA_LIST_OWNER_KEY\nJOIN \n    SE_PERSON sp ON sp.MIT_ID = mld.MOIRA_LIST_MEMBER_MIT_ID\nWHERE \n    ml.IS_MOIRA_MAILING_LIST = 'Y' \n    AND LOWER(ml.MOIRA_LIST_NAME) LIKE 'r%' \n    AND mld.MOIRA_LIST_MEMBER_FULL_NAME = 'Hopkins, Ayden' \nGROUP BY \n    ml.MOIRA_LIST_NAME, ml.MOIRA_LIST_DESCRIPTION, mo.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For the email list with name 'date-destiny', list the name of the list, department name, the number of students from the Management department, and the percentage of students who are from the Management department, rounded to two decimal places.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME, \n    sad.SIS_ADMIN_DEPARTMENT_NAME, \n    COUNT(CASE WHEN sd.DEPARTMENT_NAME = 'Management' THEN 1 END) AS num_management_students,\n    ROUND(COUNT(CASE WHEN sd.DEPARTMENT_NAME = 'Management' THEN 1 END) * 100.0 / COUNT(*), 2) AS percentage_management_students\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN \n    MIT_STUDENT_DIRECTORY sd ON sp.FULL_NAME = sd.FULL_NAME\nJOIN \n    SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT = sad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    ml.MOIRA_LIST_NAME = 'date-destiny'\nGROUP BY \n    ml.MOIRA_LIST_NAME, sad.SIS_ADMIN_DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For the building with the most floors, list the building name and the names of the mailing lists staring with a (case insensitive) that the building employees with kerberos starting with c (case insensitive) subscribe to.",
        "predicted_sql": "SELECT \n    fb.BUILDING_NAME, \n    ml.MOIRA_LIST_NAME\nFROM \n    FAC_BUILDING fb\nJOIN \n    FAC_FLOOR ff ON fb.FAC_BUILDING_KEY = ff.BUILDING_KEY\nJOIN \n    FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY\nJOIN \n    EMPLOYEE_DIRECTORY ed ON fr.FAC_ROOM_KEY = ed.OFFICE_LOCATION\nJOIN \n    MOIRA_LIST_DETAIL mld ON ed.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN \n    MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nWHERE \n    fb.FAC_BUILDING_KEY = (SELECT \n                               fb_inner.FAC_BUILDING_KEY\n                           FROM \n                               FAC_BUILDING fb_inner\n                           JOIN \n                               FAC_FLOOR ff_inner ON fb_inner.FAC_BUILDING_KEY = ff_inner.BUILDING_KEY\n                           GROUP BY \n                               fb_inner.FAC_BUILDING_KEY\n                           ORDER BY \n                               COUNT(ff_inner.FLOOR) DESC\n                           LIMIT 1)\n    AND ed.KRB_NAME LIKE 'c%'\nORDER BY \n    fb.BUILDING_NAME, ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For the email lists subscribed by faculty members with last names begin with Y, list the names of the lists, the total number of subjects managed by faculty in those mailing lists, and the number of such faculty in the lists.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(DISTINCT c.SUBJECT_ID) AS total_subjects_managed,\n    COUNT(DISTINCT e.MIT_ID) AS total_faculty\nFROM \n    MOIRA_LIST AS ml\nJOIN \n    MOIRA_LIST_DETAIL AS mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    EMPLOYEE_DIRECTORY AS e ON mld.MOIRA_LIST_MEMBER_MIT_ID = e.MIT_ID\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED AS c ON e.FULL_NAME LIKE '%' || substr(c.RESPONSIBLE_FACULTY_NAME, instr(c.RESPONSIBLE_FACULTY_NAME, ',') + 1) || '%'\nWHERE \n    e.LAST_NAME LIKE 'Y%'\nGROUP BY \n    ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with H who are subscribed to mailing list 'beacon-date-date', list the names of the students, the phone numbers of departments they belong to, and the size of the mailing list 'beacon-date-date' that they are subscribed to.",
        "predicted_sql": "SELECT \n    msd.FULL_NAME, \n    sad.DEPARTMENT_PHONE_NUMBER, \n    (SELECT COUNT(*) FROM MOIRA_LIST_DETAIL mld WHERE mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY) AS LIST_SIZE\nFROM \n    MIT_STUDENT_DIRECTORY msd\nJOIN \n    MOIRA_LIST_DETAIL mld ON msd.FULL_NAME = mld.MOIRA_LIST_MEMBER_FULL_NAME\nJOIN \n    MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nJOIN \n    SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    msd.LAST_NAME LIKE 'H%' AND \n    ml.MOIRA_LIST_NAME = 'beacon-date-date';"
    },
    {
        "db_id": "dw",
        "question": "Give the count of mailing lists with names starting with B that include members from the Electrical Engineering and Computer Science department, along with the name of the list starting with B that have the highest number of members from that department and the corresponding member count.",
        "predicted_sql": "WITH MailingListCounts AS (\n    SELECT \n        ml.MOIRA_LIST_NAME,\n        COUNT(*) AS MemberCount\n    FROM \n        MOIRA_LIST ml\n    JOIN \n        MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n    JOIN \n        SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\n    WHERE \n        ml.MOIRA_LIST_NAME LIKE 'B%' \n        AND sp.ORGANIZATION = 'Electrical Engineering and Computer Science'\n    GROUP BY \n        ml.MOIRA_LIST_NAME\n),\nMailingListSummary AS (\n    SELECT \n        COUNT(*) AS TotalMailingLists,\n        MAX(MemberCount) AS MaxMemberCount\n    FROM \n        MailingListCounts\n)\nSELECT \n    mlc.TotalMailingLists,\n    mlc.MOIRA_LIST_NAME,\n    mlc.MemberCount\nFROM \n    MailingListCounts mlc\nJOIN \n    MailingListSummary mls ON mlc.MemberCount = mls.MaxMemberCount\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For the 'kangaroo-inspire-yearn' email list, for each department present in the list, list the department name, the number of students in that department, and its percentage relative to the students in the mailing list.",
        "predicted_sql": "SELECT \n    SAD.SIS_ADMIN_DEPARTMENT_NAME, \n    COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER_MIT_ID) AS student_count, \n    ROUND((COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER_MIT_ID) * 100.0 / (SELECT COUNT(*) FROM MOIRA_LIST_DETAIL MLD2 WHERE MLD2.MOIRA_LIST_KEY = 'kangaroo-inspire-yearn')), 2) AS percentage\nFROM \n    MOIRA_LIST ML\nJOIN \n    MOIRA_LIST_DETAIL MLD ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON SP ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME\nJOIN \n    MIT_STUDENT_DIRECTORY MSD ON SP.FULL_NAME = MSD.FULL_NAME\nJOIN \n    SIS_ADMIN_DEPARTMENT SAD ON MSD.DEPARTMENT = SAD.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    ML.MOIRA_LIST_NAME = 'kangaroo-inspire-yearn'\nGROUP BY \n    SAD.SIS_ADMIN_DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Among the mailing lists subscribed by people with physical offices in building 24, provide the name of the most subscribed mailing list and the total number of subscribers.",
        "predicted_sql": "SELECT ml.MOIRA_LIST_NAME, COUNT(md.MOIRA_LIST_MEMBER) AS total_subscribers\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL md ON ml.MOIRA_LIST_KEY = md.MOIRA_LIST_KEY\nJOIN EMPLOYEE_DIRECTORY ed ON ed.KRB_NAME = md.MOIRA_LIST_MEMBER\nWHERE ed.OFFICE_LOCATION LIKE '24%'\nGROUP BY ml.MOIRA_LIST_NAME\nORDER BY total_subscribers DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For email lists subscribed by either support staff or faculty, list its name, the number of subscribers that are support staff, the number of subscribers that are faculty, as well as its active status.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME, \n    SUM(CASE WHEN sp.EMPLOYEE_TYPE = 'Support Staff' THEN 1 ELSE 0 END) AS support_staff_count,\n    SUM(CASE WHEN sp.EMPLOYEE_TYPE = 'Faculty' THEN 1 ELSE 0 END) AS faculty_count,\n    ml.IS_ACTIVE\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER_MIT_ID = sp.MIT_ID\nWHERE \n    sp.EMPLOYEE_TYPE IN ('Support Staff', 'Faculty')\nGROUP BY \n    ml.MOIRA_LIST_NAME, ml.IS_ACTIVE;"
    },
    {
        "db_id": "dw",
        "question": "For the 'ocean-apple' mailing list, identify the department with the highest student count. Provide the department name, phone number, and the total number of students subscribed to the mailing list from that department. If multiple departments have the same highest count, list each one separately.",
        "predicted_sql": "SELECT \n    SAD.SIS_ADMIN_DEPARTMENT_NAME, \n    SAD.DEPARTMENT_PHONE_NUMBER, \n    COUNT(*) AS student_count\nFROM \n    MOIRA_LIST ML\nJOIN \n    MOIRA_LIST_DETAIL MLD ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON SP ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME\nJOIN \n    MIT_STUDENT_DIRECTORY MSD ON SP.FULL_NAME = MSD.FULL_NAME\nJOIN \n    SIS_ADMIN_DEPARTMENT SAD ON MSD.DEPARTMENT = SAD.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    ML.MOIRA_LIST_NAME = 'ocean-apple'\nGROUP BY \n    SAD.SIS_ADMIN_DEPARTMENT_NAME, SAD.DEPARTMENT_PHONE_NUMBER\nHAVING \n    COUNT(*) = (SELECT MAX(student_count)\n                 FROM (SELECT COUNT(*) AS student_count\n                       FROM MOIRA_LIST ML\n                       JOIN MOIRA_LIST_DETAIL MLD ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\n                       JOIN SE_PERSON SP ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME\n                       JOIN MIT_STUDENT_DIRECTORY MSD ON SP.FULL_NAME = MSD.FULL_NAME\n                       JOIN SIS_ADMIN_DEPARTMENT SAD ON MSD.DEPARTMENT = SAD.SIS_ADMIN_DEPARTMENT_CODE\n                       WHERE ML.MOIRA_LIST_NAME = 'ocean-apple'\n                       GROUP BY SAD.SIS_ADMIN_DEPARTMENT_NAME) AS dept_counts);"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list, list its owner, owner type, the member visibility ('Public Members' if public, and 'Hidden Members' otherwise), and the number of members of this type of visibility. For each owner and owner type, include a grand total for all members in the format of (owner, owner type, null, total members).",
        "predicted_sql": "SELECT \n    o.OWNER, \n    o.OWNER_TYPE, \n    CASE \n        WHEN ml.IS_PUBLIC = 'Y' THEN 'Public Members' \n        ELSE 'Hidden Members' \n    END AS member_visibility, \n    COUNT(DISTINCT d.MOIRA_LIST_MEMBER) AS total_members\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL d ON ml.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER o ON d.MOIRA_LIST_OWNER_KEY = o.MOIRA_LIST_OWNER_KEY\nGROUP BY \n    o.OWNER, \n    o.OWNER_TYPE, \n    ml.IS_PUBLIC\n\nUNION ALL\n\nSELECT \n    o.OWNER, \n    o.OWNER_TYPE, \n    NULL AS member_visibility, \n    COUNT(DISTINCT d.MOIRA_LIST_MEMBER) AS total_members\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL d ON ml.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER o ON d.MOIRA_LIST_OWNER_KEY = o.MOIRA_LIST_OWNER_KEY\nGROUP BY \n    o.OWNER, \n    o.OWNER_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "Group biology courses by cluster type and course level. For each group, list the name of the department, the course title, cluster type, total enrollments, average enrollment within its cluster, course level, number of unique course materials, average new and used prices for TIP materials, total material record count for TIP materials, number of unique library titles, and number of unique library ISBNs.",
        "predicted_sql": "SELECT \n    sos.OFFER_DEPT_NAME AS department_name,\n    sos.SUBJECT_TITLE AS course_title,\n    sos.CLUSTER_TYPE,\n    SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollments,\n    AVG(sos.NUM_ENROLLED_STUDENTS) OVER (PARTITION BY sos.CLUSTER_TYPE) AS avg_enrollment_within_cluster,\n    scd.COURSE_LEVEL,\n    COUNT(DISTINCT tm.TITLE) AS unique_course_materials,\n    AVG(tm.NEW_SHELF_PRICE) AS avg_new_price,\n    AVG(tm.USED_SHELF_PRICE) AS avg_used_price,\n    SUM(td.RECORD_COUNT) AS total_material_record_count,\n    COUNT(DISTINCT lrc.CATALOG_TITLE) AS unique_library_titles,\n    COUNT(DISTINCT lrc.CATALOG_ISBN) AS unique_library_isbns\nFROM \n    SUBJECT_OFFERED_SUMMARY sos\nJOIN \n    SIS_COURSE_DESCRIPTION scd ON sos.COURSE_NUMBER = scd.COURSE\nLEFT JOIN \n    TIP_DETAIL td ON sos.SUBJECT_ID = td.SUBJECT_ID\nLEFT JOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_CATALOG lrc ON tm.ISBN = lrc.CATALOG_ISBN\nWHERE \n    sos.SUBJECT_TITLE LIKE '%Biology%'\nGROUP BY \n    sos.OFFER_DEPT_NAME, sos.SUBJECT_TITLE, sos.CLUSTER_TYPE, scd.COURSE_LEVEL\nORDER BY \n    sos.OFFER_DEPT_NAME, sos.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered this year in either the Fall or Spring term, list its department name, school name, subject ID, subject title, course level, total units, the term it is offered ('Spring' for Spring term and 'Fall' for Fall term), term description, the number of distinct instructors teaching in the Fall, and the number of distinct instructors teaching in the Spring.",
        "predicted_sql": "SELECT \n    cs.DEPARTMENT_NAME, \n    d.SCHOOL_NAME, \n    cs.SUBJECT_ID, \n    cs.SUBJECT_TITLE, \n    cd.COURSE_LEVEL, \n    cs.TOTAL_UNITS, \n    CASE \n        WHEN cs.TERM_CODE LIKE '%FA%' THEN 'Fall' \n        WHEN cs.TERM_CODE LIKE '%SP%' THEN 'Spring' \n    END AS TERM, \n    at.TERM_DESCRIPTION, \n    (SELECT COUNT(DISTINCT FALL_INSTRUCTORS) FROM COURSE_CATALOG_SUBJECT_OFFERED cs1 WHERE cs1.TERM_CODE LIKE '%FA%' AND cs1.IS_OFFERED_THIS_YEAR = 'Y' AND cs1.SUBJECT_CODE = cs.SUBJECT_CODE) AS FALL_INSTRUCTORS_COUNT, \n    (SELECT COUNT(DISTINCT SPRING_INSTRUCTORS) FROM COURSE_CATALOG_SUBJECT_OFFERED cs2 WHERE cs2.TERM_CODE LIKE '%SP%' AND cs2.IS_OFFERED_THIS_YEAR = 'Y' AND cs2.SUBJECT_CODE = cs.SUBJECT_CODE) AS SPRING_INSTRUCTORS_COUNT\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED cs\nJOIN \n    SIS_DEPARTMENT d ON cs.DEPARTMENT_CODE = d.DEPARTMENT_CODE\nJOIN \n    SIS_COURSE_DESCRIPTION cd ON cs.SUBJECT_CODE = cd.COURSE\nJOIN \n    ACADEMIC_TERMS at ON cs.TERM_CODE = at.TERM_CODE\nWHERE \n    cs.IS_OFFERED_THIS_YEAR = 'Y' \n    AND cs.TERM_CODE LIKE '%FA%'\n    OR cs.TERM_CODE LIKE '%SP%';"
    },
    {
        "db_id": "dw",
        "question": "For Political Science courses with HASS attributes, for each attribute, list the name and description of the attribute, the number of unique subjects, average units, the total enrollment, the number of departments that grant degrees, and the subject code description.",
        "predicted_sql": "SELECT \n    C.HASS_ATTRIBUTE AS name,\n    C.HASS_ATTRIBUTE_DESC AS description,\n    COUNT(DISTINCT C.SUBJECT_ID) AS unique_subjects,\n    AVG(C.TOTAL_UNITS) AS average_units,\n    SUM(S.NUM_ENROLLED_STUDENTS) AS total_enrollment,\n    COUNT(DISTINCT D.DEPARTMENT_CODE) AS departments_granting_degrees,\n    SC.SUBJECT_CODE_DESC\nFROM \n    CIS_COURSE_CATALOG C\nJOIN \n    SUBJECT_OFFERED_SUMMARY S ON C.SUBJECT_ID = S.SUBJECT_ID\nJOIN \n    SIS_SUBJECT_CODE SC ON C.SUBJECT_CODE = SC.SUBJECT_CODE\nJOIN \n    SIS_DEPARTMENT D ON SC.DEPARTMENT_CODE = D.DEPARTMENT_CODE\nWHERE \n    D.DEPARTMENT_NAME LIKE '%Political Science%' \n    AND C.HASS_ATTRIBUTE IS NOT NULL\nGROUP BY \n    C.HASS_ATTRIBUTE, C.HASS_ATTRIBUTE_DESC, SC.SUBJECT_CODE_DESC;"
    },
    {
        "db_id": "dw",
        "question": "Group subjects by cluster type, department offering the subject, and the school name. For each group, list the cluster type, name of the department, school name, whether the department grants degrees, total number of subjects, total enrollment, and average enrollment. Exclude clusters or schools with no student data.",
        "predicted_sql": "SELECT \n    sos.CLUSTER_TYPE,\n    sos.OFFER_DEPT_NAME,\n    sd.SCHOOL_NAME,\n    sd.IS_DEGREE_GRANTING,\n    COUNT(sos.SUBJECT_ID) AS total_subjects,\n    SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollment,\n    AVG(sos.NUM_ENROLLED_STUDENTS) AS avg_enrollment\nFROM \n    SUBJECT_OFFERED_SUMMARY sos\nJOIN \n    SIS_DEPARTMENT sd ON sos.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE\nGROUP BY \n    sos.CLUSTER_TYPE, \n    sos.OFFER_DEPT_NAME, \n    sd.SCHOOL_NAME, \n    sd.IS_DEGREE_GRANTING\nHAVING \n    total_enrollment > 0;"
    },
    {
        "db_id": "dw",
        "question": "Group classes that take place in buildings at MIT by the building name and course level. For each group, provide the name of the building, the course level ('Graduate' or 'Undergraduate'), the total number of unique courses of such level, and total instructors for these courses. Include subtotals for each building and course level and a grand total across all buildings and course levels.",
        "predicted_sql": "WITH CourseDetails AS (\n    SELECT \n        fb.BUILDING_NAME AS building_name,\n        CASE \n            WHEN sc.COURSE_LEVEL = 'G' THEN 'Graduate'\n            WHEN sc.COURSE_LEVEL = 'U' THEN 'Undergraduate'\n            ELSE 'Other'\n        END AS course_level,\n        so.SUBJECT_ID AS course_id,\n        so.RESPONSIBLE_FACULTY_NAME AS instructor\n    FROM \n        FAC_BUILDING fb\n    JOIN \n        SUBJECT_OFFERED so ON fb.FAC_BUILDING_KEY = so.MEET_PLACE\n    JOIN \n        SIS_COURSE_DESCRIPTION sc ON so.COURSE_NUMBER = sc.COURSE\n    WHERE \n        fb.SITE = 'MIT'\n)\n\nSELECT \n    building_name,\n    course_level,\n    COUNT(DISTINCT course_id) AS total_courses,\n    COUNT(DISTINCT instructor) AS total_instructors\nFROM \n    CourseDetails\nWHERE \n    course_level IN ('Graduate', 'Undergraduate')\nGROUP BY \n    building_name, course_level\n\nWITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each course, provide the room number of course location, building name, building number, building city, building state, area, organization name, room usage, term code, course level, the total number of subjects, unique meeting times, and total units. Do not include meet place or meet times with NULL values.",
        "predicted_sql": "SELECT \n    FAC_ROOMS.ROOM AS 'room_number',\n    FAC_BUILDING.BUILDING_NAME_LONG AS 'building_name',\n    FAC_BUILDING.BUILDING_NUMBER AS 'building_number',\n    FAC_BUILDING_ADDRESS.CITY AS 'building_city',\n    FAC_BUILDING_ADDRESS.STATE AS 'building_state',\n    FAC_ROOMS.AREA AS 'area',\n    FAC_ROOMS.ORGANIZATION_NAME AS 'organization_name',\n    FAC_MAJOR_USE.MAJOR_USE AS 'room_usage',\n    COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE AS 'term_code',\n    SIS_COURSE_DESCRIPTION.COURSE_LEVEL AS 'course_level',\n    COUNT(DISTINCT COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID) AS 'total_subjects',\n    COUNT(DISTINCT COURSE_CATALOG_SUBJECT_OFFERED.MEET_TIME) AS 'unique_meeting_times',\n    SUM(COURSE_CATALOG_SUBJECT_OFFERED.TOTAL_UNITS) AS 'total_units'\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED\nJOIN \n    FAC_ROOMS ON FAC_ROOMS.FAC_ROOM_KEY = COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE\nJOIN \n    FAC_BUILDING ON FAC_ROOMS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY\nJOIN \n    FAC_MAJOR_USE ON FAC_ROOMS.MAJOR_USE_KEY = FAC_MAJOR_USE.MAJOR_USE_KEY\nJOIN \n    SIS_COURSE_DESCRIPTION ON SIS_COURSE_DESCRIPTION.COURSE = COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID\nWHERE \n    COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE IS NOT NULL\n    AND COURSE_CATALOG_SUBJECT_OFFERED.MEET_TIME IS NOT NULL\nGROUP BY \n    FAC_ROOMS.ROOM,\n    FAC_BUILDING.BUILDING_NAME_LONG,\n    FAC_BUILDING.BUILDING_NUMBER,\n    FAC_BUILDING_ADDRESS.CITY,\n    FAC_BUILDING_ADDRESS.STATE,\n    FAC_ROOMS.AREA,\n    FAC_ROOMS.ORGANIZATION_NAME,\n    COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE,\n    SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
    },
    {
        "db_id": "dw",
        "question": "Consider only books cataloged on or after 2000. For each library material status and department, list the material status, department name, number of associated catalog items, and the total number of enrolled students in courses using those materials. Include subtotals for each material status and a grand total across all status (the corresponding status field is 'Grand Total').",
        "predicted_sql": "WITH MaterialStats AS (\n    SELECT \n        LMS.LIBRARY_MATERIAL_STATUS AS material_status,\n        SSC.DEPARTMENT_NAME AS department_name,\n        COUNT(DISTINCT RLC.LIBRARY_RESERVE_CATALOG_KEY) AS catalog_item_count,\n        SUM(SSO.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\n    FROM \n        LIBRARY_RESERVE_CATALOG RLC\n    JOIN \n        LIBRARY_RESERVE_MATRL_DETAIL RMD ON RLC.LIBRARY_RESERVE_CATALOG_KEY = RMD.LIBRARY_RESERVE_CATALOG_KEY\n    JOIN \n        LIBRARY_MATERIAL_STATUS LMS ON RMD.LIBRARY_MATERIAL_STATUS_KEY = LMS.LIBRARY_MATERIAL_STATUS_KEY\n    JOIN \n        LIBRARY_SUBJECT_OFFERED SSO ON RMD.LIBRARY_SUBJECT_OFFERED_KEY = SSO.LIBRARY_SUBJECT_OFFERED_KEY\n    JOIN \n        SIS_SUBJECT_CODE SSC ON SSO.COURSE_NUMBER = SSC.COURSE_NUMBER\n    WHERE \n        RLC.CATALOG_YEAR >= '2000'\n    GROUP BY \n        LMS.LIBRARY_MATERIAL_STATUS, SSC.DEPARTMENT_NAME\n),\nSubtotals AS (\n    SELECT \n        material_status,\n        department_name,\n        catalog_item_count,\n        total_enrolled_students\n    FROM \n        MaterialStats\n\n    UNION ALL\n\n    SELECT \n        material_status,\n        'Subtotal' AS department_name,\n        SUM(catalog_item_count) AS catalog_item_count,\n        SUM(total_enrolled_students) AS total_enrolled_students\n    FROM \n        MaterialStats\n    GROUP BY \n        material_status\n    \n    UNION ALL\n    \n    SELECT \n        'Grand Total' AS material_status,\n        'Grand Total' AS department_name,\n        SUM(catalog_item_count) AS catalog_item_count,\n        SUM(total_enrolled_students) AS total_enrolled_students\n    FROM \n        MaterialStats\n)\n\nSELECT \n    material_status,\n    department_name,\n    catalog_item_count,\n    total_enrolled_students\nFROM \n    Subtotals\nORDER BY \n    material_status, department_name;"
    },
    {
        "db_id": "dw",
        "question": "For each department in the library system, list the name of the department, total number of courses using library materials, the number of catalog items associated with those courses, and the average enrollment per course. Include a grand total across all departments (the corresponding department field should be 'Grand Total').",
        "predicted_sql": "WITH CourseStats AS (\n    SELECT \n        LCI.DEPARTMENT,\n        COUNT(DISTINCT LCI.COURSE_NAME) AS total_courses,\n        COUNT(DISTINCT LRC.LIBRARY_RESERVE_CATALOG_KEY) AS total_catalog_items,\n        AVG(LSO.NUM_ENROLLED_STUDENTS) AS avg_enrollment\n    FROM \n        LIBRARY_COURSE_INSTRUCTOR LCI\n    JOIN \n        LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LCI.LIBRARY_COURSE_INSTRUCTOR_KEY = LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY\n    JOIN \n        LIBRARY_RESERVE_CATALOG LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\n    JOIN \n        LIBRARY_SUBJECT_OFFERED LSO ON LRMD.LIBRARY_SUBJECT_OFFERED_KEY = LSO.LIBRARY_SUBJECT_OFFERED_KEY\n    GROUP BY \n        LCI.DEPARTMENT\n)\n\nSELECT \n    DEPARTMENT,\n    total_courses,\n    total_catalog_items,\n    avg_enrollment\nFROM \n    CourseStats\n\nUNION ALL\n\nSELECT \n    'Grand Total' AS DEPARTMENT,\n    SUM(total_courses) AS total_courses,\n    SUM(total_catalog_items) AS total_catalog_items,\n    AVG(avg_enrollment) AS avg_enrollment\nFROM \n    CourseStats;"
    },
    {
        "db_id": "dw",
        "question": "For each department and school offering courses with materials, list the department name, school name, number of unique course materials, number of courses, average new and used shelf prices of materials, total material records, and number of distinct material statuses. Include a grand total across all schools and departments (the corresponding school and department fields should be null).",
        "predicted_sql": "SELECT \n    d.DEPARTMENT_NAME,\n    d.SCHOOL_NAME,\n    COUNT(DISTINCT m.TITLE) AS num_unique_course_materials,\n    COUNT(DISTINCT so.SUBJECT_TITLE) AS num_courses,\n    AVG(m.NEW_SHELF_PRICE) AS average_new_price,\n    AVG(m.USED_SHELF_PRICE) AS average_used_price,\n    SUM(dt.RECORD_COUNT) AS total_material_records,\n    COUNT(DISTINCT ms.TIP_MATERIAL_STATUS) AS num_distinct_material_statuses\nFROM SIS_DEPARTMENT d\nJOIN TIP_SUBJECT_OFFERED so ON d.DEPARTMENT_CODE = so.OFFER_DEPT_CODE\nJOIN TIP_DETAIL dt ON so.TIP_SUBJECT_OFFERED_KEY = dt.TIP_SUBJECT_OFFERED_KEY\nJOIN TIP_MATERIAL m ON dt.TIP_MATERIAL_KEY = m.TIP_MATERIAL_KEY\nJOIN TIP_MATERIAL_STATUS ms ON dt.TIP_MATERIAL_STATUS_KEY = ms.TIP_MATERIAL_STATUS_KEY\nWHERE so.IS_NO_COURSE_MATERIAL = 'N'\nGROUP BY d.DEPARTMENT_NAME, d.SCHOOL_NAME\nWITH ROLLUP\nHAVING (GROUPING(d.DEPARTMENT_NAME) = 0 OR GROUPING(d.SCHOOL_NAME) = 0);"
    },
    {
        "db_id": "dw",
        "question": "For each TIP material status, list the total number of unique materials associated with the status, the total number of records associated with the status, and the total student enrollment associated with the status. Any material status with null values should be displayed as 'No material status'. Additionally, include a grand total across all material status (the material status for this row should be displayed as 'Grand Total').",
        "predicted_sql": "SELECT \n    COALESCE(TMS.TIP_MATERIAL_STATUS, 'No material status') AS Material_Status,\n    COUNT(DISTINCT TM.ISBN) AS Unique_Materials,\n    SUM(TD.RECORD_COUNT) AS Total_Records,\n    SUM(TSO.NUM_ENROLLED_STUDENTS) AS Total_Enrollment\nFROM \n    TIP_DETAIL TD\nLEFT JOIN \n    TIP_MATERIAL_STATUS TMS ON TD.TIP_MATERIAL_STATUS_KEY = TMS.TIP_MATERIAL_STATUS_KEY\nLEFT JOIN \n    TIP_MATERIAL TM ON TD.TIP_MATERIAL_KEY = TM.TIP_MATERIAL_KEY\nLEFT JOIN \n    TIP_SUBJECT_OFFERED TSO ON TD.TIP_SUBJECT_OFFERED_KEY = TSO.TIP_SUBJECT_OFFERED_KEY\nGROUP BY \n    TMS.TIP_MATERIAL_STATUS\n\nUNION ALL\n\nSELECT \n    'Grand Total' AS Material_Status,\n    COUNT(DISTINCT TM.ISBN) AS Unique_Materials,\n    SUM(TD.RECORD_COUNT) AS Total_Records,\n    SUM(TSO.NUM_ENROLLED_STUDENTS) AS Total_Enrollment\nFROM \n    TIP_DETAIL TD\nLEFT JOIN \n    TIP_MATERIAL_STATUS TMS ON TD.TIP_MATERIAL_STATUS_KEY = TMS.TIP_MATERIAL_STATUS_KEY\nLEFT JOIN \n    TIP_MATERIAL TM ON TD.TIP_MATERIAL_KEY = TM.TIP_MATERIAL_KEY\nLEFT JOIN \n    TIP_SUBJECT_OFFERED TSO ON TD.TIP_SUBJECT_OFFERED_KEY = TSO.TIP_SUBJECT_OFFERED_KEY;"
    },
    {
        "db_id": "dw",
        "question": "For each room, list its associated building name, floor number, room number, ownership type, organization name, number of rooms, area, and percentage of area relative to the building. Include subtotals across floors, subtotals across all floors for each building, and a grand total across all buildings. For the subtotal for each building and the grand total, the percentage of area should be relative to area of all buildings. All numeric values should be rounded to integers and formatted using commas as thousands separators except the relative percentages which should be rounded to two decimal places.",
        "predicted_sql": "WITH RoomData AS (\n    SELECT \n        B.BUILDING_NAME_LONG,\n        F.FLOOR,\n        R.BUILDING_ROOM,\n        B.OWNERSHIP_TYPE,\n        O.ORGANIZATION_NAME,\n        COUNT(R.FCLT_ROOM_KEY) AS NUM_OF_ROOMS,\n        ROUND(SUM(R.AREA)) AS AREA\n    FROM \n        FCLT_ROOMS R\n    JOIN \n        FCLT_FLOOR F ON R.FCLT_FLOOR_KEY = F.FCLT_FLOOR_KEY\n    JOIN \n        FCLT_BUILDING B ON F.FCLT_BUILDING_KEY = B.FCLT_BUILDING_KEY\n    JOIN \n        FCLT_ORGANIZATION O ON R.FCLT_ORGANIZATION_KEY = O.FCLT_ORGANIZATION_KEY\n    GROUP BY \n        B.BUILDING_NAME_LONG, F.FLOOR, R.BUILDING_ROOM, B.OWNERSHIP_TYPE, O.ORGANIZATION_NAME\n), TotalData AS (\n    SELECT \n        SUM(AREA) AS TOTAL_AREA\n    FROM \n        RoomData\n), FloorSubtotals AS (\n    SELECT \n        BUILDING_NAME_LONG,\n        FLOOR,\n        SUM(AREA) AS FLOOR_TOTAL_AREA,\n        ROUND(100.0 * SUM(AREA) / (SELECT SUM(AREA) FROM RoomData), 2) AS FLOOR_PERCENTAGE\n    FROM \n        RoomData\n    GROUP BY \n        BUILDING_NAME_LONG, FLOOR\n), BuildingSubtotals AS (\n    SELECT \n        BUILDING_NAME_LONG,\n        SUM(AREA) AS BUILDING_TOTAL_AREA,\n        ROUND(100.0 * SUM(AREA) / (SELECT SUM(AREA) FROM RoomData), 2) AS BUILDING_PERCENTAGE\n    FROM \n        RoomData\n    GROUP BY \n        BUILDING_NAME_LONG\n)\nSELECT \n    R.BUILDING_NAME_LONG,\n    R.FLOOR,\n    R.BUILDING_ROOM,\n    R.OWNERSHIP_TYPE,\n    R.ORGANIZATION_NAME,\n    R.NUM_OF_ROOMS,\n    R.AREA,\n    ROUND(100.0 * R.AREA / (SELECT SUM(AREA) FROM RoomData), 2) AS AREA_PERCENTAGE\nFROM \n    RoomData R\nUNION ALL\nSELECT \n    FLOOR_SUB.BUILDING_NAME_LONG,\n    FLOOR_SUB.FLOOR,\n    'Subtotal' AS BUILDING_ROOM,\n    NULL AS OWNERSHIP_TYPE,\n    NULL AS ORGANIZATION_NAME,\n    NULL AS NUM_OF_ROOMS,\n    FLOOR_SUB.FLOOR_TOTAL_AREA,\n    FLOOR_SUB.FLOOR_PERCENTAGE\nFROM \n    FloorSubtotals FLOOR_SUB\nUNION ALL\nSELECT \n    BUILDING_SUB.BUILDING_NAME_LONG,\n    'Total' AS FLOOR,\n    NULL AS BUILDING_ROOM,\n    NULL AS OWNERSHIP_TYPE,\n    NULL AS ORGANIZATION_NAME,\n    NULL AS NUM_OF_ROOMS,\n    BUILDING_SUB.BUILDING_TOTAL_AREA,\n    BUILDING_SUB.BUILDING_PERCENTAGE\nFROM \n    BuildingSubtotals BUILDING_SUB\nUNION ALL\nSELECT \n    'Grand Total' AS BUILDING_NAME_LONG,\n    NULL AS FLOOR,\n    NULL AS BUILDING_ROOM,\n    NULL AS OWNERSHIP_TYPE,\n    NULL AS ORGANIZATION_NAME,\n    NULL AS NUM_OF_ROOMS,\n    (SELECT SUM(AREA) FROM RoomData) AS GRAND_TOTAL_AREA,\n    100 AS GRAND_TOTAL_PERCENTAGE\nORDER BY \n    1, 2, 3;"
    },
    {
        "db_id": "dw",
        "question": "For each financial aid year and academic year, list the number of fiscal periods, quarters, the start term date, the end term date, and number of distinct department-level term parameters.",
        "predicted_sql": "SELECT \n    AT.FINANCIAL_AID_YEAR,\n    AT.ACADEMIC_YEAR,\n    COUNT(DISTINCT TM.FISCAL_PERIOD) AS fiscal_periods,\n    COUNT(DISTINCT TQ.FY_QUARTER_CODE) AS quarters,\n    AT.TERM_START_DATE AS start_term_date,\n    AT.TERM_END_DATE AS end_term_date,\n    COUNT(DISTINCT ATP.TERM_PARAMETER) AS distinct_term_parameters\nFROM \n    ACADEMIC_TERMS AT\nJOIN \n    TIME_DAY TD ON AT.TERM_START_DATE = TD.CALENDAR_DATE\nJOIN \n    TIME_MONTH TM ON TD.FISCAL_PERIOD = TM.FISCAL_PERIOD\nJOIN \n    TIME_QUARTER TQ ON TM.FISCAL_YEAR = TQ.FISCAL_YEAR\nLEFT JOIN \n    ACADEMIC_TERM_PARAMETER ATP ON AT.TERM_CODE = ATP.TERM_CODE\nGROUP BY \n    AT.FINANCIAL_AID_YEAR,\n    AT.ACADEMIC_YEAR,\n    AT.TERM_START_DATE,\n    AT.TERM_END_DATE;"
    },
    {
        "db_id": "dw",
        "question": "Group buildings by campus sectors. For each group, list the campus sector, name of the building, city and state where the building is located, total number of floors, total assignable area, total number of rooms, total number of organizations, ownership type, and a rank column indicating the order (1-indexed) of this row within each sector based on the descending order of assignable area. Include subtotals for each sector and a grand total across all sectors. The subtotal and grand total only need to computed over the total number of floors and assignable area.",
        "predicted_sql": "WITH BuildingSummary AS (\n    SELECT \n        B.CAMPUS_SECTOR,\n        B.BUILDING_NAME_LONG,\n        A.CITY,\n        A.STATE,\n        COUNT(DISTINCT F.FLOOR) AS total_floors,\n        SUM(B.ASSIGNABLE_AREA) AS total_assignable_area,\n        COUNT(DISTINCT R.FCLT_ROOM_KEY) AS total_rooms,\n        COUNT(DISTINCT O.FCLT_ORGANIZATION_KEY) AS total_organizations,\n        B.OWNERSHIP_TYPE\n    FROM \n        FCLT_BUILDING B\n    JOIN \n        FCLT_BUILDING_ADDRESS A ON B.FCLT_BUILDING_KEY = A.FCLT_BUILDING_KEY\n    JOIN \n        FCLT_FLOOR F ON B.FCLT_BUILDING_KEY = F.FCLT_BUILDING_KEY\n    JOIN \n        FCLT_ROOMS R ON B.FCLT_BUILDING_KEY = R.FCLT_BUILDING_KEY\n    JOIN \n        FCLT_ORGANIZATION O ON R.FCLT_ORGANIZATION_KEY = O.FCLT_ORGANIZATION_KEY\n    GROUP BY \n        B.CAMPUS_SECTOR, B.BUILDING_NAME_LONG, A.CITY, A.STATE, B.OWNERSHIP_TYPE\n),\nRankedBuildings AS (\n    SELECT \n        *, \n        ROW_NUMBER() OVER (PARTITION BY CAMPUS_SECTOR ORDER BY total_assignable_area DESC) AS rank\n    FROM \n        BuildingSummary\n),\nSectorSubtotals AS (\n    SELECT \n        CAMPUS_SECTOR,\n        NULL AS BUILDING_NAME_LONG,\n        NULL AS CITY,\n        NULL AS STATE,\n        SUM(total_floors) AS total_floors,\n        SUM(total_assignable_area) AS total_assignable_area,\n        NULL AS total_rooms,\n        NULL AS total_organizations,\n        NULL AS OWNERSHIP_TYPE,\n        0 AS rank\n    FROM \n        BuildingSummary\n    GROUP BY \n        CAMPUS_SECTOR\n)\nSELECT \n    CAMPUS_SECTOR,\n    BUILDING_NAME_LONG,\n    CITY,\n    STATE,\n    total_floors,\n    total_assignable_area,\n    total_rooms,\n    total_organizations,\n    rank\nFROM \n    RankedBuildings\n\nUNION ALL\n\nSELECT \n    CAMPUS_SECTOR,\n    BUILDING_NAME_LONG,\n    CITY,\n    STATE,\n    total_floors,\n    total_assignable_area,\n    total_rooms,\n    total_organizations,\n    rank\nFROM \n    SectorSubtotals\n\nORDER BY\n    CAMPUS_SECTOR,\n    rank;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the name of the department, the title of the TIP material associated with the department, author, ISBN, library term code, and whether it is available in the library reserves ('Available in Library' if yes and 'Not Available in Library' otherwise), the total number of instructors per library book for the department, the total number of materials available in the library for the department, and the total number of available materials across all departments.",
        "predicted_sql": "SELECT \n    tso.OFFER_DEPT_NAME,\n    tm.TITLE AS 'TIP Material Title',\n    tm.AUTHOR AS 'Author',\n    tm.ISBN,\n    tso.TERM_CODE AS 'Library Term Code',\n    CASE \n        WHEN lrc.CATALOG_ISBN IS NOT NULL THEN 'Available in Library' \n        ELSE 'Not Available in Library' \n    END AS 'Availability in Library',\n    COUNT(DISTINCT lci.LIBRARY_COURSE_INSTRUCTOR_KEY) AS 'Total Instructors',\n    COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS 'Total Materials',\n    (SELECT COUNT(DISTINCT tm1.TIP_MATERIAL_KEY) \n     FROM TIP_MATERIAL tm1 \n     JOIN TIP_DETAIL td1 ON tm1.TIP_MATERIAL_KEY = td1.TIP_MATERIAL_KEY) AS 'Total Available Materials Across All Departments'\nFROM \n    TIP_SUBJECT_OFFERED tso\nJOIN \n    TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrd ON tso.LIBRARY_SUBJECT_OFFERED_KEY = lrd.LIBRARY_SUBJECT_OFFERED_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nLEFT JOIN \n    LIBRARY_COURSE_INSTRUCTOR lci ON lrd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    tso.OFFER_DEPT_NAME, \n    tm.TITLE, \n    tm.AUTHOR, \n    tm.ISBN,\n    tso.TERM_CODE,\n    lrc.CATALOG_ISBN\nORDER BY \n    tso.OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department and material status, list the name of the department, the material status, the number of TIP materials associated with this department and status, the number of library materials associated with this department and status, the total number of TIP and library materials associated with this department and status. Include a subtotal for each department and a grand total across all departments.",
        "predicted_sql": "WITH TIP_STATS AS (\n    SELECT \n        TSO.OFFER_DEPT_NAME,\n        TMS.TIP_MATERIAL_STATUS,\n        COUNT(DISTINCT TD.TIP_MATERIAL_KEY) AS TIP_MATERIAL_COUNT\n    FROM \n        TIP_DETAIL TD\n    JOIN \n        TIP_SUBJECT_OFFERED TSO ON TD.TIP_SUBJECT_OFFERED_KEY = TSO.TIP_SUBJECT_OFFERED_KEY\n    JOIN \n        TIP_MATERIAL_STATUS TMS ON TMS.TIP_MATERIAL_STATUS_KEY = TD.TIP_MATERIAL_STATUS_KEY\n    GROUP BY \n        TSO.OFFER_DEPT_NAME, TMS.TIP_MATERIAL_STATUS\n),\nLIBRARY_STATS AS (\n    SELECT \n        LSO.OFFER_DEPT_NAME,\n        LMS.LIBRARY_MATERIAL_STATUS,\n        COUNT(DISTINCT LRM.LIBRARY_RESERVE_CATALOG_KEY) AS LIBRARY_MATERIAL_COUNT\n    FROM \n        LIBRARY_RESERVE_MATRL_DETAIL LRM\n    JOIN \n        LIBRARY_SUBJECT_OFFERED LSO ON LRM.LIBRARY_SUBJECT_OFFERED_KEY = LSO.LIBRARY_SUBJECT_OFFERED_KEY\n    JOIN \n        LIBRARY_MATERIAL_STATUS LMS ON LMS.LIBRARY_MATERIAL_STATUS_KEY = LRM.LIBRARY_MATERIAL_STATUS_KEY\n    GROUP BY \n        LSO.OFFER_DEPT_NAME, LMS.LIBRARY_MATERIAL_STATUS\n)\nSELECT \n    COALESCE(TS.OFFER_DEPT_NAME, LS.OFFER_DEPT_NAME) AS DEPARTMENT,\n    COALESCE(TS.TIP_MATERIAL_STATUS, LS.LIBRARY_MATERIAL_STATUS) AS MATERIAL_STATUS,\n    COALESCE(TS.TIP_MATERIAL_COUNT, 0) AS TIP_MATERIAL_COUNT,\n    COALESCE(LS.LIBRARY_MATERIAL_COUNT, 0) AS LIBRARY_MATERIAL_COUNT,\n    COALESCE(TS.TIP_MATERIAL_COUNT, 0) + COALESCE(LS.LIBRARY_MATERIAL_COUNT, 0) AS TOTAL_MATERIAL_COUNT\nFROM \n    TIP_STATS TS\nFULL OUTER JOIN \n    LIBRARY_STATS LS ON TS.OFFER_DEPT_NAME = LS.OFFER_DEPT_NAME AND TS.TIP_MATERIAL_STATUS = LS.LIBRARY_MATERIAL_STATUS\nORDER BY \n    DEPARTMENT, MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "For each building that is not a subdivision, list the building number, full name, street address, building type, occupancy date, ownership type, and site location. You should also include three rows at the end showing the number of owned, leased, all buildings at MIT that are not subdivisions, in the format of (null, #building Buildings, null, null, null, null, null).",
        "predicted_sql": "SELECT \n    FB.BUILDING_NUMBER,\n    FB.BUILDING_NAME_LONG AS full_name,\n    B.BUILDING_STREET_ADDRESS AS street_address,\n    FB.BUILDING_TYPE,\n    FB.DATE_OCCUPIED AS occupancy_date,\n    FB.OWNERSHIP_TYPE,\n    FB.SITE\nFROM \n    FAC_BUILDING FB\nJOIN \n    BUILDINGS B ON FB.FAC_BUILDING_KEY = B.BUILDING_KEY\nLEFT JOIN \n    FAC_BUILDING_ADDRESS FBA ON FBA.BUILDING_KEY = FB.FAC_BUILDING_KEY\nWHERE \n    FB.PARENT_BUILDING_NUMBER IS NULL\n\nUNION ALL\n\nSELECT \n    NULL, \n    COUNT(*) AS owned_buildings, \n    NULL, \n    NULL, \n    NULL, \n    NULL, \n    NULL\nFROM \n    FAC_BUILDING \nWHERE \n    OWNERSHIP_TYPE = 'OWNED' AND \n    PARENT_BUILDING_NUMBER IS NULL\n\nUNION ALL\n\nSELECT \n    NULL, \n    COUNT(*) AS leased_buildings, \n    NULL, \n    NULL, \n    NULL, \n    NULL, \n    NULL\nFROM \n    FAC_BUILDING \nWHERE \n    OWNERSHIP_TYPE = 'LEASED' AND \n    PARENT_BUILDING_NUMBER IS NULL\n\nUNION ALL\n\nSELECT \n    NULL, \n    COUNT(*) AS all_buildings, \n    NULL, \n    NULL, \n    NULL, \n    NULL, \n    NULL\nFROM \n    FAC_BUILDING \nWHERE \n    PARENT_BUILDING_NUMBER IS NULL;"
    },
    {
        "db_id": "dw",
        "question": "For each owned building that is not a subdivision, list the construction start year, the building number, and the year of initial occupancy. Display the construction start year only if it differs from the previous row. If the year of initial occupancy or construction start year is unknown, display 'UNKNOWN'. You should also include a row at the end showing the total number of owned buildings that are not subdivisions, in the format of (null, #building Buildings, null).",
        "predicted_sql": "WITH OwnedBuildings AS (\n    SELECT \n        IFNULL(YEAR(FAC.DATE_BUILT), 'UNKNOWN') AS ConstructionYear,\n        FAC.BUILDING_NUMBER,\n        IFNULL(YEAR(FAC.DATE_OCCUPIED), 'UNKNOWN') AS OccupancyYear\n    FROM \n        FAC_BUILDING FAC\n    WHERE \n        FAC.OWNERSHIP_TYPE = 'OWNED' \n        AND FAC.PARENT_BUILDING_NUMBER IS NULL\n),\nDistinctYears AS (\n    SELECT \n        DISTINCT ConstructionYear,\n        BUILDING_NUMBER,\n        OccupancyYear\n    FROM \n        OwnedBuildings\n),\nFinalOutput AS (\n    SELECT \n        ConstructionYear,\n        BUILDING_NUMBER,\n        OccupancyYear\n    FROM (\n        SELECT \n            D. ConstructionYear,\n            D.BUILDING_NUMBER,\n            D.OccupancyYear,\n            @prevYear AS PrevYear,\n            @prevYear := D.ConstructionYear\n        FROM \n            DistinctYears D,\n            (SELECT @prevYear := NULL) AS init\n    ) AS Result\n    WHERE \n        Result.ConstructionYear <> Result.PrevYear OR Result.PrevYear IS NULL\n)\nSELECT \n    ConstructionYear, \n    BUILDING_NUMBER, \n    OccupancyYear \nFROM \n    FinalOutput\n\nUNION ALL\n\nSELECT \n    NULL, \n    COUNT(*) || ' owned buildings', \n    NULL \nFROM \n    FAC_BUILDING \nWHERE \n    OWNERSHIP_TYPE = 'OWNED' \n    AND PARENT_BUILDING_NUMBER IS NULL;"
    },
    {
        "db_id": "dw",
        "question": "Group all buildings at MIT into either owned or leased. For each group, state the ownership type, usage type, number of buildings, gross square footage, number of rooms, and the number of associated organizations. Display the ownership type only if it differs from the previous row. Include subtotals for each group and a grand total across all groups. The subtotal and grand total rows should not include ownership type and usage type. Footage should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH BuildingStats AS (\n    SELECT \n        FCLT_BUILDING_HIST.OWNERSHIP_TYPE,\n        FCLT_BUILDING_HIST.BUILDING_USE,\n        COUNT(DISTINCT FCLT_BUILDING_HIST.FCLT_BUILDING_KEY) AS Num_Buildings,\n        ROUND(SUM(FCLT_BUILDING_HIST.EXT_GROSS_AREA)) AS Total_Gross_SQ_FT,\n        COUNT(DISTINCT FCLT_ROOMS.FCLT_ROOM_KEY) AS Num_Rooms,\n        COUNT(DISTINCT FCLT_ROOMS.FCLT_ORGANIZATION_KEY) AS Num_Organizations\n    FROM \n        FCLT_BUILDING_HIST\n    LEFT JOIN \n        FCLT_ROOMS ON FCLT_BUILDING_HIST.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY\n    WHERE \n        FCLT_BUILDING_HIST.SITE = 'MIT'\n    GROUP BY \n        FCLT_BUILDING_HIST.OWNERSHIP_TYPE, FCLT_BUILDING_HIST.BUILDING_USE\n),\nSubtotals AS (\n    SELECT \n        Ownership_Type, \n        SUM(Num_Buildings) AS Subtotal_Buildings,\n        SUM(Total_Gross_SQ_FT) AS Subtotal_Gross_SQ_FT,\n        SUM(Num_Rooms) AS Subtotal_Rooms,\n        SUM(Num_Organizations) AS Subtotal_Organizations\n    FROM \n        BuildingStats\n    GROUP BY \n        Ownership_Type\n),\nGrandTotal AS (\n    SELECT \n        SUM(Num_Buildings) AS Total_Buildings,\n        SUM(Total_Gross_SQ_FT) AS Total_Gross_SQ_FT,\n        SUM(Num_Rooms) AS Total_Rooms,\n        SUM(Num_Organizations) AS Total_Organizations\n    FROM \n        BuildingStats\n)\n\nSELECT \n    s.Ownership_Type,\n    s.Building_Use,\n    s.Num_Buildings,\n    s.Total_Gross_SQ_FT,\n    s.Num_Rooms,\n    s.Num_Organizations\nFROM \n    BuildingStats s\n\nUNION ALL\n\nSELECT \n    NULL,\n    NULL,\n    st.Subtotal_Buildings,\n    st.Subtotal_Gross_SQ_FT,\n    st.Subtotal_Rooms,\n    st.Subtotal_Organizations\nFROM \n    Subtotals st\n\nUNION ALL\n\nSELECT \n    NULL,\n    NULL,\n    gt.Total_Buildings,\n    gt.Total_Gross_SQ_FT,\n    gt.Total_Rooms,\n    gt.Total_Organizations\nFROM \n    GrandTotal gt\n\nORDER BY \n    Ownership_Type, Building_Use;"
    },
    {
        "db_id": "dw",
        "question": "For each building use, list the type, the number of distinct buildings (excluding subdivisions) of this use, the total gross square footage of these buildings, and the number of unique organizations associated with the rooms in these buildings. If the building is used as a residence, display the usage type as \"RESIDENTIAL.\" You should also include a row at the end showing the total number of buildings, the gross square footage, and the number of organizations across all types of building use. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH BuildingStats AS (\n    SELECT \n        CASE \n            WHEN FB.BUILDING_USE = 'RESIDENT' THEN 'RESIDENTIAL' \n            ELSE FB.BUILDING_USE \n        END AS BUILDING_USE,\n        COUNT(DISTINCT FB.FCLT_BUILDING_KEY) AS num_buildings,\n        SUM(FB.EXT_GROSS_AREA) AS total_gross_area,\n        COUNT(DISTINCT FR.FCLT_ORGANIZATION_KEY) AS num_organizations\n    FROM \n        FCLT_BUILDING FB\n    JOIN \n        FCLT_ROOMS FR ON FB.FCLT_BUILDING_KEY = FR.FCLT_BUILDING_KEY\n    WHERE \n        FB.PARENT_BUILDING_NUMBER IS NULL\n    GROUP BY \n        CASE \n            WHEN FB.BUILDING_USE = 'RESIDENT' THEN 'RESIDENTIAL' \n            ELSE FB.BUILDING_USE \n        END\n), Summary AS (\n    SELECT \n        SUM(num_buildings) AS total_buildings,\n        SUM(total_gross_area) AS total_gross_area,\n        SUM(num_organizations) AS total_num_organizations\n    FROM \n        BuildingStats\n)\nSELECT \n    BUILDING_USE, \n    num_buildings AS building_type, \n    ROUND(total_gross_area) AS total_gross_sqft, \n    num_organizations AS unique_organizations\nFROM \n    BuildingStats\n\nUNION ALL\n\nSELECT \n    'TOTAL' AS BUILDING_USE, \n    total_buildings AS building_type, \n    ROUND(total_gross_area) AS total_gross_sqft, \n    total_num_organizations AS unique_organizations\nFROM \n    Summary\nORDER BY \n    BUILDING_USE;"
    },
    {
        "db_id": "dw",
        "question": "For each organization except Cambridge-MIT Institute, list its ID, number, level, formatted name according to level (if level is 2, there should be 1 space before the name, if level is 3, there should be 2 space before the name, up to level 6), whether it is assignable ('ASSIGNABLE' if assignable, 'NON-ASSIGNABLE' otherwise), total area, number of rooms, and average room area. Area and number of rooms should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    FO.ORGANIZATION_ID, \n    FORMAT(FO.ORGANIZATION_NUMBER, 'N0') AS ORGANIZATION_NUMBER,\n    FO.ORGANIZATION_LEVEL,\n    REPLACE(REPLACE(IF(FO.ORGANIZATION_LEVEL = '1', FO.ORGANIZATION_NAME,\n        IF(FO.ORGANIZATION_LEVEL = '2', CONCAT(' ', FO.ORGANIZATION_NAME),\n        IF(FO.ORGANIZATION_LEVEL = '3', CONCAT('  ', FO.ORGANIZATION_NAME),\n        IF(FO.ORGANIZATION_LEVEL = '4', CONCAT('   ', FO.ORGANIZATION_NAME),\n        IF(FO.ORGANIZATION_LEVEL = '5', CONCAT('    ', FO.ORGANIZATION_NAME),\n        IF(FO.ORGANIZATION_LEVEL = '6', CONCAT('     ', FO.ORGANIZATION_NAME), FO.ORGANIZATION_NAME))))))), ' ', ' '),\n    FO.ASSIGNABLE, \n    FORMAT(SUM(FR.AREA), 'N0') AS TOTAL_AREA,\n    COUNT(DISTINCT FR.ROOM) AS NUMBER_OF_ROOMS,\n    FORMAT(AVG(FR.AREA), 'N0') AS AVERAGE_ROOM_AREA\nFROM \n    FCLT_ORGANIZATION FO\nJOIN \n    FCLT_ROOMS FR ON FO.FCLT_ORGANIZATION_KEY = FR.FCLT_ORGANIZATION_KEY\nWHERE \n    FO.ORGANIZATION_NAME <> 'Cambridge-MIT Institute'\nGROUP BY \n    FO.ORGANIZATION_ID, \n    FO.ORGANIZATION_NUMBER, \n    FO.ORGANIZATION_LEVEL, \n    FO.ORGANIZATION_NAME, \n    FO.ASSIGNABLE\nORDER BY \n    FO.ORGANIZATION_ID;"
    },
    {
        "db_id": "dw",
        "question": "Group all rooms into whether or not they are assignable and the major use descriptions. For each group, state \"ASSIGNABLE\" if the room is assignable and \"NON-ASSIGNABLE\" otherwise, the major use description, the total number of rooms, total area, and average area. Include subtotals for each group and a grand total across all groups. The assignable status and major use descriptions should only be displayed when they differ from the previous row. Do not include rooms whose major use or major use description starts with 'ZUSE.' The results should be sorted by assignable status and major use description. The subtotal and grand total rows should not include assignable status or major use description.",
        "predicted_sql": "WITH RoomData AS (\n    SELECT \n        CASE WHEN fr.ASSIGNABLE = '1' THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END AS Assignable_Status,\n        fm.DESCRIPTION AS Major_Use_Description,\n        COUNT(fr.ROOM) AS Total_Rooms,\n        SUM(fr.AREA) AS Total_Area,\n        AVG(fr.AREA) AS Average_Area\n    FROM \n        FCLT_ROOMS fr\n    JOIN \n        FCLT_MAJOR_USE fm ON fr.FCLT_MAJOR_USE_KEY = fm.FCLT_MAJOR_USE_KEY\n    WHERE \n        fm.DESCRIPTION NOT LIKE 'ZUSE%'\n    GROUP BY \n        Assignable_Status, fm.DESCRIPTION\n)\nSELECT \n    Assignable_Status,\n    Major_Use_Description,\n    Total_Rooms,\n    Total_Area,\n    Average_Area\nFROM \n    RoomData\nUNION ALL\nSELECT \n    NULL AS Assignable_Status,\n    NULL AS Major_Use_Description,\n    SUM(Total_Rooms) AS Total_Rooms,\n    SUM(Total_Area) AS Total_Area,\n    AVG(Average_Area) AS Average_Area\nFROM \n    RoomData\nGROUP BY \n    NULL\nORDER BY \n    Assignable_Status, Major_Use_Description;"
    },
    {
        "db_id": "dw",
        "question": "List each floor key and department name within the Stata building, as well as the number of rooms, total area, and average area per department on each floor. Include subtotals for each floor and a grand total across all floors. Sort the results by floor key and department name in ascending order. Exclude departments without any rooms in the building. Only the first row of each floor group should include the floor key, and the subtotal and grand total rows should not include floor key or department name. Number of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH RoomData AS (\n    SELECT \n        F.FLOOR_KEY,\n        FO.ORGANIZATION_NAME,\n        COUNT(R.FAC_ROOM_KEY) AS number_of_rooms,\n        SUM(R.AREA) AS total_area,\n        SUM(R.AREA) / NULLIF(COUNT(R.FAC_ROOM_KEY), 0) AS average_area\n    FROM \n        FAC_ROOMS R\n    JOIN \n        FCLT_ORGANIZATION FO ON R.ORGANIZATION_KEY = FO.FCLT_ORGANIZATION_KEY\n    JOIN \n        FAC_FLOOR F ON R.FLOOR_KEY = F.FLOOR_KEY\n    JOIN \n        BUILDINGS B ON R.BUILDING_KEY = B.BUILDING_KEY\n    WHERE \n        B.BUILDING_NAME = 'Stata building'\n    GROUP BY \n        F.FLOOR_KEY, FO.ORGANIZATION_NAME\n),\nSubtotalData AS (\n    SELECT \n        FLOOR_KEY,\n        NULL AS ORGANIZATION_NAME,\n        SUM(number_of_rooms) AS number_of_rooms,\n        SUM(total_area) AS total_area,\n        AVG(average_area) AS average_area\n    FROM \n        RoomData\n    GROUP BY \n        FLOOR_KEY\n)\nSELECT \n    CASE \n        WHEN R.FLOOR_KEY IS NOT NULL THEN R.FLOOR_KEY \n        ELSE NULL \n    END AS FLOOR_KEY,\n    CASE \n        WHEN R.ORGANIZATION_NAME IS NOT NULL THEN R.ORGANIZATION_NAME \n        ELSE NULL \n    END AS DEPARTMENT_NAME,\n    CAST(REGEXP_REPLACE(ROUND(R.number_of_rooms), '(\\\\d)(?=(\\\\d{3})+(?!\\\\d))', '\\\\1,') AS VARCHAR) AS number_of_rooms,\n    CAST(REGEXP_REPLACE(ROUND(R.total_area), '(\\\\d)(?=(\\\\d{3})+(?!\\\\d))', '\\\\1,') AS VARCHAR) AS total_area,\n    CAST(ROUND(R.average_area) AS VARCHAR) AS average_area\nFROM \n    RoomData R\nUNION ALL\nSELECT \n    NULL, \n    NULL, \n    CAST(REGEXP_REPLACE(ROUND(S.number_of_rooms), '(\\\\d)(?=(\\\\d{3})+(?!\\\\d))', '\\\\1,') AS VARCHAR) AS number_of_rooms,\n    CAST(REGEXP_REPLACE(ROUND(S.total_area), '(\\\\d)(?=(\\\\d{3})+(?!\\\\d))', '\\\\1,') AS VARCHAR) AS total_area,\n    NULL AS average_area\nFROM \n    SubtotalData S\nORDER BY \n    FLOOR_KEY, DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List each building key and floor key within the department of facilities, the number of rooms, total area, average area per floor, building name, access level, zip code, and city. Include subtotals for each building and a grand total across all buildings. The subtotals and grand total should not include zip code or city. Numbers of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH RoomData AS (\n    SELECT \n        FR.BUILDING_KEY,\n        FR.FLOOR_KEY,\n        COUNT(FR.FAC_ROOM_KEY) AS NumOfRooms,\n        ROUND(SUM(FR.AREA)) AS TotalArea\n    FROM FAC_ROOMS FR\n    JOIN FAC_ORGANIZATION FO ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY\n    WHERE FO.ORGANIZATION_NAME = 'FACILITIES'\n    GROUP BY FR.BUILDING_KEY, FR.FLOOR_KEY\n),\nBuildingData AS (\n    SELECT \n        FB.FAC_BUILDING_KEY AS BuildingKey,\n        FB.BUILDING_NAME_LONG AS BuildingName,\n        FB.ACCESS_LEVEL_NAME AS AccessLevel,\n        BA.POSTAL_CODE AS ZipCode,\n        BA.CITY AS City,\n        SUM(RD.NumOfRooms) AS TotalRooms,\n        SUM(RD.TotalArea) AS TotalArea,\n        COUNT(DISTINCT RD.FLOOR_KEY) AS TotalFloors\n    FROM FAC_BUILDING FB\n    JOIN RoomData RD ON FB.FAC_BUILDING_KEY = RD.BUILDING_KEY\n    JOIN FAC_BUILDING_ADDRESS BA ON FB.FAC_BUILDING_KEY = BA.BUILDING_KEY\n    GROUP BY FB.FAC_BUILDING_KEY, FB.BUILDING_NAME_LONG, FB.ACCESS_LEVEL_NAME, BA.POSTAL_CODE, BA.CITY\n)\nSELECT \n    BuildingKey,\n    FLOOR_KEY,\n    TotalRooms,\n    TotalArea,\n    ROUND((TotalArea * 1.0 / NULLIF(TotalFloors, 0))) AS AvgAreaPerFloor,\n    BuildingName,\n    AccessLevel,\n    ZipCode,\n    City\nFROM BuildingData\nUNION ALL\nSELECT \n    'SUBTOTAL' AS BuildingKey,\n    NULL AS FLOOR_KEY,\n    SUM(TotalRooms) AS TotalRooms,\n    SUM(TotalArea) AS TotalArea,\n    ROUND(SUM(TotalArea * 1.0) / NULLIF(SUM(TotalFloors), 0)) AS AvgAreaPerFloor,\n    NULL AS BuildingName,\n    NULL AS AccessLevel,\n    NULL AS ZipCode,\n    NULL AS City\nFROM BuildingData\nUNION ALL\nSELECT \n    'GRAND TOTAL' AS BuildingKey,\n    NULL AS FLOOR_KEY,\n    SUM(TotalRooms) AS TotalRooms,\n    SUM(TotalArea) AS TotalArea,\n    ROUND(SUM(TotalArea * 1.0) / NULLIF(SUM(TotalFloors), 0)) AS AvgAreaPerFloor,\n    NULL AS BuildingName,\n    NULL AS AccessLevel,\n    NULL AS ZipCode,\n    NULL AS City\nFROM BuildingData;"
    },
    {
        "db_id": "dw",
        "question": "List the department, school, course number, subject title, total number of enrolled students, term code, and count of distinct catalog ISBNs. Add a summary row at the bottom showing the total number of students and distinct catalog ISBNs for the current term in the format of ('TOTAL:', null, null, null, total number of students, null, number of distinct catalog ISBNs).",
        "predicted_sql": "SELECT \n    LSO.OFFER_DEPT_NAME AS department,\n    LSO.OFFER_SCHOOL_NAME AS school,\n    LSO.COURSE_NUMBER AS course_number,\n    LSO.SUBJECT_TITLE AS subject_title,\n    SUM(LSO.NUM_ENROLLED_STUDENTS) AS total_enrolled_students,\n    LSO.TERM_CODE AS term_code,\n    COUNT(DISTINCT LRC.CATALOG_ISBN) AS distinct_catalog_isbns\nFROM \n    LIBRARY_SUBJECT_OFFERED LSO\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LSO.LIBRARY_SUBJECT_OFFERED_KEY = LRMD.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    ACADEMIC_TERM_PARAMETER ATP ON LSO.TERM_CODE = ATP.TERM_CODE\nWHERE \n    ATP.IS_CURRENT_TERM = 'Y'\nGROUP BY \n    LSO.OFFER_DEPT_NAME, \n    LSO.OFFER_SCHOOL_NAME, \n    LSO.COURSE_NUMBER, \n    LSO.SUBJECT_TITLE, \n    LSO.TERM_CODE\n\nUNION ALL\n\nSELECT \n    'TOTAL:' AS department,\n    NULL AS school,\n    NULL AS course_number,\n    NULL AS subject_title,\n    SUM(LSO.NUM_ENROLLED_STUDENTS) AS total_enrolled_students,\n    NULL AS term_code,\n    COUNT(DISTINCT LRC.CATALOG_ISBN) AS distinct_catalog_isbns\nFROM \n    LIBRARY_SUBJECT_OFFERED LSO\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LSO.LIBRARY_SUBJECT_OFFERED_KEY = LRMD.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    ACADEMIC_TERM_PARAMETER ATP ON LSO.TERM_CODE = ATP.TERM_CODE\nWHERE \n    ATP.IS_CURRENT_TERM = 'Y';"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list that involves subscribers that work in departments with names starting with 'Computer Science', state the ownership type, the list name, the number of owners, and the number of subscribers. Display the ownership type only if it differs from the previous entry. Include subtotals (the corresponding type field shoud be 'SUBTOTAL') for each ownership type and a grand total (the corresponding type field shoud be 'TOTAL') across all ownership types.",
        "predicted_sql": "WITH DepartmentSubscribers AS (\n    SELECT \n        ML.MOIRA_LIST_NAME,\n        MO.OWNER_TYPE,\n        MO.MOIRA_LIST_OWNER_KEY,\n        COUNT(DISTINCT MO.OWNER) AS OwnerCount,\n        COUNT(DISTINCT MD.MOIRA_LIST_MEMBER_MIT_ID) AS SubscriberCount\n    FROM \n        MOIRA_LIST ML\n    JOIN \n        MOIRA_LIST_OWNER MO ON ML.MOIRA_LIST_KEY = MO.MOIRA_LIST_OWNER_KEY\n    JOIN \n        MOIRA_LIST_DETAIL MD ON ML.MOIRA_LIST_KEY = MD.MOIRA_LIST_KEY\n    JOIN \n        EMPLOYEE_DIRECTORY ED ON MD.MOIRA_LIST_MEMBER_MIT_ID = ED.MIT_ID\n    WHERE \n        ED.DEPARTMENT_NAME LIKE 'Computer Science%'\n    GROUP BY \n        ML.MOIRA_LIST_NAME, MO.OWNER_TYPE\n), \nOwnershipSubtotals AS (\n    SELECT \n        OWNER_TYPE,\n        SUM(OwnerCount) AS TotalOwners,\n        SUM(SubscriberCount) AS TotalSubscribers\n    FROM \n        DepartmentSubscribers\n    GROUP BY \n        OWNER_TYPE\n),\nFinalOutput AS (\n    SELECT \n        OWNER_TYPE,\n        MOIRA_LIST_NAME,\n        OwnerCount,\n        SubscriberCount\n    FROM \n        DepartmentSubscribers\n    UNION ALL\n    SELECT \n        'SUBTOTAL' AS OWNER_TYPE,\n        NULL AS MOIRA_LIST_NAME,\n        TotalOwners,\n        TotalSubscribers\n    FROM \n        OwnershipSubtotals\n    UNION ALL\n    SELECT \n        'TOTAL' AS OWNER_TYPE,\n        NULL AS MOIRA_LIST_NAME,\n        SUM(TotalOwners),\n        SUM(TotalSubscribers)\n    FROM \n        OwnershipSubtotals\n)\nSELECT \n    OWNER_TYPE,\n    MOIRA_LIST_NAME,\n    OwnerCount,\n    SubscriberCount\nFROM \n    FinalOutput\nORDER BY \n    OWNER_TYPE, MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list its name, number of unique sessions, total number of attendees, active period (in the format of 'beginning term code-end term code'), the most common sponsor name, and the most common session start time. Include a grand total row showing the total number of sessions and attendees across all categories in the format of ('TOTAL', number of sessions, number of attendees, null, null, null).",
        "predicted_sql": "WITH CategoryStats AS (\n    SELECT \n        c.IAP_CATEGORY_NAME,\n        COUNT(DISTINCT s.IAP_SUBJECT_SESSION_KEY) AS unique_sessions,\n        SUM(d.MAX_ENROLLMENT) AS total_attendees,\n        MIN(d.TERM_CODE) || '-' || MAX(d.TERM_CODE) AS active_period,\n        (SELECT s2.SPONSOR_NAME \n         FROM IAP_SUBJECT_SPONSOR s2 \n         JOIN IAP_SUBJECT_DETAIL d2 ON s2.IAP_SUBJECT_SPONSOR_KEY = d2.IAP_SUBJECT_SPONSOR_KEY\n         WHERE d2.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY\n         GROUP BY s2.SPONSOR_NAME \n         ORDER BY COUNT(*) DESC LIMIT 1) AS most_common_sponsor,\n        (SELECT s3.SESSION_START_TIME \n         FROM IAP_SUBJECT_SESSION s3 \n         JOIN IAP_SUBJECT_DETAIL d3 ON s3.IAP_SUBJECT_SESSION_KEY = d3.IAP_SUBJECT_SESSION_KEY\n         WHERE d3.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY\n         GROUP BY s3.SESSION_START_TIME \n         ORDER BY COUNT(*) DESC LIMIT 1) AS most_common_start_time\n    FROM \n        IAP_SUBJECT_CATEGORY c\n    JOIN \n        IAP_SUBJECT_DETAIL d ON c.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY\n    JOIN \n        IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\n    GROUP BY \n        c.IAP_CATEGORY_NAME\n),\nTotalStats AS (\n    SELECT \n        'TOTAL' AS name,\n        COUNT(DISTINCT s.IAP_SUBJECT_SESSION_KEY) AS total_sessions,\n        SUM(d.MAX_ENROLLMENT) AS total_attendees,\n        NULL AS active_period,\n        NULL AS most_common_sponsor,\n        NULL AS most_common_start_time\n    FROM \n        IAP_SUBJECT_DETAIL d\n    JOIN \n        IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\n)\n\nSELECT * FROM CategoryStats\nUNION ALL\nSELECT * FROM TotalStats;"
    },
    {
        "db_id": "dw",
        "question": "For each building type, list the name of the building type, the number of buildings that are not subdivisions, number of employees, number of unique building street address, number of unique city, number of unique state, number of unique postal code, and average gross square footage per employee. For building type of 'resident', display it as 'RESIDENTIAL'. Include a grand total across all building types (the corresponding type field is 'TOTAL').",
        "predicted_sql": "WITH BuildingCounts AS (\n    SELECT \n        CASE \n            WHEN FCLT.BUILDING_TYPE = 'resident' THEN 'RESIDENTIAL' \n            ELSE FCLT.BUILDING_TYPE \n        END AS building_type,\n        COUNT(DISTINCT FCLT.FCLT_BUILDING_KEY) AS num_buildings,\n        COUNT(DISTINCT EMP.MIT_ID) AS num_employees,\n        COUNT(DISTINCT BA.BUILDING_STREET_ADDRESS) AS num_unique_street_addresses,\n        COUNT(DISTINCT BA.CITY) AS num_unique_cities,\n        COUNT(DISTINCT BA.STATE) AS num_unique_states,\n        COUNT(DISTINCT BA.POSTAL_CODE) AS num_unique_postal_codes,\n        AVG(FCLT.EXT_GROSS_AREA) AS avg_gross_sq_ft\n    FROM FCLT_BUILDING_HIST FCLT\n    LEFT JOIN FAC_BUILDING_ADDRESS BA ON FCLT.FCLT_BUILDING_KEY = BA.BUILDING_KEY\n    LEFT JOIN BUILDINGS B ON BA.BUILDING_KEY = B.BUILDING_KEY\n    LEFT JOIN FAC_ROOMS R ON B.BUILDING_KEY = R.BUILDING_KEY\n    LEFT JOIN EMPLOYEE_DIRECTORY EMP ON R.FAC_ROOM_KEY = EMP.OFFICE_LOCATION\n    WHERE FCLT.PARENT_BUILDING_NUMBER IS NULL\n    GROUP BY \n        CASE \n            WHEN FCLT.BUILDING_TYPE = 'resident' THEN 'RESIDENTIAL' \n            ELSE FCLT.BUILDING_TYPE \n        END\n), GrandTotal AS (\n    SELECT\n        'TOTAL' AS building_type,\n        SUM(num_buildings) AS num_buildings,\n        SUM(num_employees) AS num_employees,\n        SUM(num_unique_street_addresses) AS num_unique_street_addresses,\n        SUM(num_unique_cities) AS num_unique_cities,\n        SUM(num_unique_states) AS num_unique_states,\n        SUM(num_unique_postal_codes) AS num_unique_postal_codes,\n        AVG(avg_gross_sq_ft) AS avg_gross_sq_ft\n    FROM BuildingCounts\n)\nSELECT * FROM BuildingCounts\nUNION ALL\nSELECT * FROM GrandTotal;"
    },
    {
        "db_id": "dw",
        "question": "Group spaces in the Stata building by the access level and usage type. For each group, state the access level, usage type, name of the space, the number of spaces, total area across all rooms in the space, and average area across all rooms in the space. Display the access level only if it differs from the previous entry. Include subtotals for each access level, usage type, and space name, subtotals for each access level, and a grand total across all access levels. Exclude usage type that includes \"STORAGE\". All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    CASE WHEN @prev_access_level <> z.ACCESS_LEVEL THEN z.ACCESS_LEVEL END AS access_level,\n    su.SPACE_USAGE AS usage_type,\n    fo.DLC_NAME AS space_name,\n    COUNT(sd.BUILDING_ROOM) AS number_of_spaces,\n    ROUND(SUM(sd.ROOM_SQUARE_FOOTAGE)) AS total_area,\n    ROUND(AVG(sd.ROOM_SQUARE_FOOTAGE)) AS average_area\nFROM \n    SPACE_DETAIL sd\nJOIN \n    ZPM_ROOMS_LOAD z ON sd.BUILDING_ROOM = z.BUILDING_ROOM\nJOIN \n    SPACE_USAGE su ON z.SPACE_USAGE = su.SPACE_USAGE\nJOIN \n    SPACE_UNIT su2 ON z.SPACE_UNIT_CODE = su2.SPACE_UNIT_CODE\nJOIN \n    FCLT_ORGANIZATION fo ON su2.FCLT_ORGANIZATION_KEY = fo.FCLT_ORGANIZATION_KEY\nWHERE \n    sd.BUILDING_KEY = '1' AND \n    su.SPACE_USAGE NOT LIKE '%STORAGE%'\nGROUP BY \n    z.ACCESS_LEVEL, su.SPACE_USAGE, fo.DLC_NAME\nORDER BY \n    z.ACCESS_LEVEL, su.SPACE_USAGE, fo.DLC_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List each organization's break group, ID, name, and formatted name according to its level, along with whether its members are emeritus or non-emeritus. Also, include the organization number, level, employer count, and hierarchy type for each organization. Exclude organizations '139' and '250'. Sort the results by hierarchy type and ensure totals for employer counts are displayed.",
        "predicted_sql": "SELECT \n    FCLT_ORG.ORGANIZATION_SORT AS break_group,\n    FCLT_ORG.ORGANIZATION_ID AS ID,\n    FCLT_ORG.ORGANIZATION_NAME AS name,\n    FCLT_ORG.ORGANIZATION_LEVEL AS level,\n    FCLT_ORG.ORGANIZATION_NUMBER AS number,\n    COUNT(HR_FACULTY.MIT_ID) AS employer_count,\n    MDH.HIERARCHY_TYPE AS hierarchy_type,\n    CASE \n        WHEN HR_FACULTY.EMERITUS_STATUS = 'Emeritus' THEN 'Emeritus' \n        ELSE 'Non-Emeritus' \n    END AS status\nFROM \n    FCLT_ORGANIZATION FCLT_ORG\nJOIN \n    MASTER_DEPT_HIERARCHY MDH ON FCLT_ORG.DLC_KEY = MDH.DLC_KEY\nJOIN \n    HR_ORG_UNIT HR_UNIT ON FCLT_ORG.DLC_KEY = HR_UNIT.DLC_KEY\nJOIN \n    HR_FACULTY_ROSTER HR_FACULTY ON HR_UNIT.HR_ORG_UNIT_TITLE = HR_FACULTY.HR_ORG_UNIT_TITLE\nWHERE \n    FCLT_ORG.ORGANIZATION_ID NOT IN ('139', '250')\nGROUP BY \n    FCLT_ORG.ORGANIZATION_SORT, \n    FCLT_ORG.ORGANIZATION_ID, \n    FCLT_ORG.ORGANIZATION_NAME, \n    FCLT_ORG.ORGANIZATION_LEVEL, \n    FCLT_ORG.ORGANIZATION_NUMBER, \n    MDH.HIERARCHY_TYPE, \n    HR_FACULTY.EMERITUS_STATUS\nORDER BY \n    MDH.HIERARCHY_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its title, name of the building of the course location, duration (in terms of days), and a running average of the duration (in terms of days) using a window of two preceding and two following courses (partitioned by academic year and sorted by course start date).",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE,\n    b.BUILDING_NAME,\n    julianday(at.TERM_END_DATE) - julianday(at.TERM_START_DATE) AS duration,\n    AVG(julianday(at2.TERM_END_DATE) - julianday(at2.TERM_START_DATE)) OVER (PARTITION BY c.ACADEMIC_YEAR ORDER BY at.TERM_START_DATE ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS running_avg_duration\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS at ON c.EFFECTIVE_TERM_CODE = at.TERM_CODE\nJOIN \n    FCLT_ROOMS r ON r.FCLT_ROOM_KEY = c.SUBJECT_ID\nJOIN \n    FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nORDER BY \n    c.ACADEMIC_YEAR, at.TERM_START_DATE;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, the start date, the name of the course before it, and the name of the course after it, access level of the building, and the assignable area of the room used for the course, sorted by the ascending order start date and course name.",
        "predicted_sql": "SELECT \n    C.SUBJECT_TITLE AS course_name,\n    B.BUILDING_NAME_LONG AS building_name,\n    A.TERM_START_DATE AS start_date,\n    LAG(C.SUBJECT_TITLE) OVER (ORDER BY A.TERM_START_DATE, C.SUBJECT_TITLE) AS previous_course_name,\n    LEAD(C.SUBJECT_TITLE) OVER (ORDER BY A.TERM_START_DATE, C.SUBJECT_TITLE) AS next_course_name,\n    B.ACCESS_LEVEL_NAME AS access_level,\n    R.AREA AS assignable_area\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED C\nJOIN \n    ACADEMIC_TERMS A ON C.TERM_CODE = A.TERM_CODE\nJOIN \n    FCLT_ROOMS R ON R.BUILDING_ROOM = C.SUBJECT_ID\nJOIN \n    FCLT_BUILDING B ON R.FCLT_BUILDING_KEY = B.FCLT_BUILDING_KEY\nORDER BY \n    A.TERM_START_DATE ASC, C.SUBJECT_TITLE ASC;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, and the cumulative number of courses, including the course itself, held in the same year or preceding years (partitioned by academic year and sorted in the ascending order of course start date).",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE AS course_name,\n    b.BUILDING_NAME AS building_name,\n    COUNT(*) OVER (PARTITION BY c.ACADEMIC_YEAR ORDER BY a.TERM_START_DATE) AS cumulative_courses\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS a ON c.EFFECTIVE_TERM_CODE = a.TERM_CODE\nJOIN \n    FCLT_ROOMS r ON c.MEET_PLACE = r.FCLT_ROOM_KEY\nJOIN \n    FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nWHERE \n    c.ACADEMIC_YEAR <= a.ACADEMIC_YEAR\nORDER BY \n    a.TERM_START_DATE ASC;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the cluster type. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), cluster type, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and cluster type.",
        "predicted_sql": "WITH CourseDetails AS (\n    SELECT \n        A.IS_CURRENT_TERM,\n        S.CLUSTER_TYPE,\n        JULIANDAY(A.TERM_END_DATE) - JULIANDAY(A.TERM_START_DATE) AS DurationDays,\n        S.TOTAL_UNITS\n    FROM \n        ACADEMIC_TERMS_ALL A\n    JOIN \n        SUBJECT_SUMMARY S ON A.TERM_CODE = S.TERM_CODE\n    WHERE \n        S.DEPARTMENT_NAME IN ('Biology', 'Chemistry')\n),\nAggregated AS (\n    SELECT \n        IS_CURRENT_TERM,\n        CLUSTER_TYPE,\n        MAX(DurationDays) AS MaxDurationDays,\n        MAX(TOTAL_UNITS) AS MaxUnits,\n        AVG(DurationDays) AS AvgDurationDays,\n        AVG(TOTAL_UNITS) AS AvgUnits\n    FROM \n        CourseDetails\n    GROUP BY \n        IS_CURRENT_TERM, CLUSTER_TYPE\n),\nSubtotal AS (\n    SELECT \n        IS_CURRENT_TERM,\n        CLUSTER_TYPE,\n        MaxDurationDays,\n        MaxUnits,\n        AvgDurationDays,\n        AvgUnits\n    FROM \n        Aggregated\n    UNION ALL\n    SELECT \n        'SUBTOTAL' AS IS_CURRENT_TERM,\n        CLUSTER_TYPE,\n        MAX(MaxDurationDays),\n        MAX(MaxUnits),\n        AVG(AvgDurationDays),\n        AVG(AvgUnits)\n    FROM \n        Aggregated\n    GROUP BY \n        CLUSTER_TYPE\n),\nGrandTotal AS (\n    SELECT \n        'TOTAL' AS IS_CURRENT_TERM,\n        NULL AS CLUSTER_TYPE,\n        MAX(MaxDurationDays) AS MaxDurationDays,\n        MAX(MaxUnits) AS MaxUnits,\n        AVG(AvgDurationDays) AS AvgDurationDays,\n        AVG(AvgUnits) AS AvgUnits\n    FROM \n        Aggregated\n)\nSELECT \n    IS_CURRENT_TERM,\n    CLUSTER_TYPE,\n    MaxDurationDays,\n    MaxUnits,\n    AvgDurationDays,\n    AvgUnits\nFROM \n    Subtotal\nUNION ALL\nSELECT \n    IS_CURRENT_TERM,\n    CLUSTER_TYPE,\n    MaxDurationDays,\n    MaxUnits,\n    AvgDurationDays,\n    AvgUnits\nFROM \n    GrandTotal\nORDER BY \n    IS_CURRENT_TERM, \n    CLUSTER_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the department name. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), department name, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and department.",
        "predicted_sql": "WITH CourseDurations AS (\n    SELECT \n        A.IS_CURRENT_TERM,\n        SO.OFFER_DEPT_NAME,\n        JULIANDAY(A.TERM_END_DATE) - JULIANDAY(A.TERM_START_DATE) AS DurationDays,\n        SS.TOTAL_UNITS\n    FROM \n        ACADEMIC_TERMS_ALL A\n    JOIN \n        SUBJECT_OFFERED SO ON A.TERM_CODE = SO.TERM_CODE\n    JOIN \n        SUBJECT_SUMMARY SS ON SO.SUBJECT_ID = SS.SUBJECT_ID\n    WHERE \n        SO.OFFER_DEPT_NAME IN ('Biology', 'Chemistry')\n),\nAggregatedResults AS (\n    SELECT \n        ISNULL(IS_CURRENT_TERM, 'NON-CURRENT') AS CurrentStatus,\n        OFFER_DEPT_NAME,\n        MAX(DurationDays) AS MaxDurationDays,\n        MAX(TOTAL_UNITS) AS MaxUnits,\n        AVG(DurationDays) AS AvgDurationDays,\n        AVG(TOTAL_UNITS) AS AvgUnits\n    FROM \n        CourseDurations\n    GROUP BY \n        IS_CURRENT_TERM, OFFER_DEPT_NAME\n),\nSubtotalResults AS (\n    SELECT \n        CurrentStatus,\n        OFFER_DEPT_NAME,\n        MAXDurationDays,\n        MAXUnits,\n        AvgDurationDays,\n        AvgUnits\n    FROM \n        AggregatedResults\n    UNION ALL\n    SELECT \n        'SUBTOTAL' AS CurrentStatus,\n        OFFER_DEPT_NAME,\n        MAX(MaxDurationDays) AS MaxDurationDays,\n        MAX(MaxUnits) AS MaxUnits,\n        AVG(AvgDurationDays) AS AvgDurationDays,\n        AVG(AvgUnits) AS AvgUnits\n    FROM \n        AggregatedResults\n    GROUP BY \n        OFFER_DEPT_NAME\n),\nGrandTotal AS (\n    SELECT \n        'TOTAL' AS CurrentStatus,\n        NULL AS OFFER_DEPT_NAME,\n        MAX(MaxDurationDays) AS MaxDurationDays,\n        MAX(MaxUnits) AS MaxUnits,\n        AVG(AvgDurationDays) AS AvgDurationDays,\n        AVG(AvgUnits) AS AvgUnits\n    FROM \n        AggregatedResults\n)\nSELECT * \nFROM SubtotalResults \nUNION ALL \nSELECT * \nFROM GrandTotal\nORDER BY CurrentStatus, OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Group master courses by department. For each group, state the name of the department, the master course code, the number of subjects, the total new shelf price of associated TIP materials, and the number of unique TIP materials. Display the department and master course only if it differs from the previous entry. Include subtotals for each department and a grand total across all departments. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "WITH DepartmentCourse AS (\n    SELECT \n        o.OFFER_DEPT_NAME AS Department,\n        o.MASTER_COURSE_NUMBER AS MasterCourse,\n        COUNT(DISTINCT o.SUBJECT_ID) AS NumberOfSubjects,\n        SUM(ROUND(m.NEW_SHELF_PRICE)) AS TotalNewShelfPrice,\n        COUNT(DISTINCT m.ISBN) AS UniqueTIPMaterials\n    FROM \n        TIP_SUBJECT_OFFERED o\n    LEFT JOIN \n        TIP_DETAIL d ON o.TIP_SUBJECT_OFFERED_KEY = d.TIP_SUBJECT_OFFERED_KEY\n    LEFT JOIN \n        TIP_MATERIAL m ON d.TIP_MATERIAL_KEY = m.TIP_MATERIAL_KEY\n    GROUP BY \n        o.OFFER_DEPT_NAME, o.MASTER_COURSE_NUMBER\n),\nDepartmentTotal AS (\n    SELECT \n        Department,\n        SUM(NumberOfSubjects) AS NumberOfSubjectsTotal,\n        SUM(TotalNewShelfPrice) AS TotalNewShelfPriceTotal,\n        SUM(UniqueTIPMaterials) AS UniqueTIPMaterialsTotal\n    FROM \n        DepartmentCourse\n    GROUP BY \n        Department\n),\nGrandTotal AS (\n    SELECT \n        SUM(NumberOfSubjects) AS GrandNumberOfSubjects,\n        SUM(TotalNewShelfPrice) AS GrandTotalNewShelfPrice,\n        SUM(UniqueTIPMaterials) AS GrandUniqueTIPMaterials\n    FROM \n        DepartmentTotal\n)\n\nSELECT \n    dc.Department,\n    dc.MasterCourse,\n    dc.NumberOfSubjects,\n    FORMAT(dc.TotalNewShelfPrice, 0) AS TotalNewShelfPrice,\n    dc.UniqueTIPMaterials,\n    dt.NumberOfSubjectsTotal,\n    FORMAT(dt.TotalNewShelfPriceTotal, 0) AS TotalNewShelfPriceTotal,\n    dt.UniqueTIPMaterialsTotal,\n    gt.GrandNumberOfSubjects,\n    FORMAT(gt.GrandTotalNewShelfPrice, 0) AS GrandTotalNewShelfPrice,\n    gt.GrandUniqueTIPMaterials\nFROM \n    DepartmentCourse dc\nJOIN \n    DepartmentTotal dt ON dc.Department = dt.Department\nCROSS JOIN \n    GrandTotal gt\nORDER BY \n    dc.Department, dc.MasterCourse;"
    },
    {
        "db_id": "dw",
        "question": "For each term and department, list the term, department, the number of courses, average number of equivalent subjects, the school name, and department phone number. Include subtotals for each term (the corresponding term field is 'SUBTOTAL') and a grand total across all terms (the corresponding term field is 'TOTAL'). Do not repeat the term if it is the same as the previous row. Sort the table by term and department.",
        "predicted_sql": "WITH CourseStats AS (\n    SELECT \n        CCSO.TERM_CODE,\n        CCSO.DEPARTMENT_NAME,\n        COUNT(DISTINCT CCSO.SUBJECT_ID) AS course_count,\n        AVG(CASE WHEN CCSO.EQUIVALENT_SUBJECTS IS NOT NULL THEN 1 ELSE 0 END) AS avg_equivalent_subjects,\n        SD.SCHOOL_NAME,\n        SAD.DEPARTMENT_PHONE_NUMBER\n    FROM \n        COURSE_CATALOG_SUBJECT_OFFERED CCSO\n    JOIN \n        SIS_DEPARTMENT SD ON CCSO.DEPARTMENT_CODE = SD.DEPARTMENT_CODE\n    JOIN \n        SIS_ADMIN_DEPARTMENT SAD ON SD.DEPARTMENT_CODE = SAD.SIS_ADMIN_DEPARTMENT_CODE\n    GROUP BY \n        CCSO.TERM_CODE, CCSO.DEPARTMENT_NAME, SD.SCHOOL_NAME, SAD.DEPARTMENT_PHONE_NUMBER\n),\nTermTotals AS (\n    SELECT \n        TERM_CODE,\n        'SUBTOTAL' AS DEPARTMENT_NAME,\n        SUM(course_count) AS course_count,\n        AVG(avg_equivalent_subjects) AS avg_equivalent_subjects,\n        FIRST_VALUE(SCHOOL_NAME) OVER (PARTITION BY TERM_CODE ORDER BY DEPARTMENT_NAME) AS SCHOOL_NAME,\n        FIRST_VALUE(DEPARTMENT_PHONE_NUMBER) OVER (PARTITION BY TERM_CODE ORDER BY DEPARTMENT_NAME) AS DEPARTMENT_PHONE_NUMBER\n    FROM \n        CourseStats\n    GROUP BY \n        TERM_CODE\n),\nGrandTotal AS (\n    SELECT \n        'TOTAL' AS TERM_CODE,\n        NULL AS DEPARTMENT_NAME,\n        SUM(course_count) AS course_count,\n        AVG(avg_equivalent_subjects) AS avg_equivalent_subjects,\n        NULL AS SCHOOL_NAME,\n        NULL AS DEPARTMENT_PHONE_NUMBER\n    FROM \n        CourseStats\n)\n\nSELECT * FROM CourseStats\nUNION ALL\nSELECT * FROM TermTotals\nUNION ALL\nSELECT * FROM GrandTotal\nORDER BY TERM_CODE, DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Group sessions by their current term status. For each group, state the status ('CURRENT' if is current term and 'NOT CURRENT' otherwise), name of the session, number of IAP sessions, total IAP session time in days, and average IAP session time in days. Show a subtotal for each current status and a grand total row across all status. Order the results by current status and cluster type. Display the the current status only if it differs from the previous entry.",
        "predicted_sql": "WITH SessionDurations AS (\n    SELECT \n        IAC.IAP_CATEGORY_NAME,\n        CASE \n            WHEN AT.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' \n            ELSE 'NOT CURRENT' \n        END AS Current_Status,\n        COUNT(ISD.IAP_SUBJECT_SESSION_KEY) AS Number_of_Sessions,\n        SUM(JULIANDAY(IAP_SESSION.SESSION_END_TIME) - JULIANDAY(IAP_SESSION.SESSION_START_TIME)) AS Total_Session_Time,\n        AVG(JULIANDAY(IAP_SESSION.SESSION_END_TIME) - JULIANDAY(IAP_SESSION.SESSION_START_TIME)) AS Average_Session_Time\n    FROM \n        ACADEMIC_TERMS AT \n    JOIN \n        IAP_SUBJECT_DETAIL ISD ON AT.TERM_CODE = ISD.TERM_CODE \n    JOIN \n        IAP_SUBJECT_SESSION IAP_SESSION ON ISD.IAP_SUBJECT_SESSION_KEY = IAP_SESSION.IAP_SUBJECT_SESSION_KEY \n    JOIN \n        IAP_SUBJECT_CATEGORY IAC ON ISD.IAP_SUBJECT_CATEGORY_KEY = IAC.IAP_SUBJECT_CATEGORY_KEY \n    GROUP BY \n        Current_Status, IAC.IAP_CATEGORY_NAME\n),\nStatusTotals AS (\n    SELECT \n        Current_Status,\n        SUM(Number_of_Sessions) AS Total_Sessions,\n        SUM(Total_Session_Time) AS Total_Time,\n        AVG(Average_Session_Time) AS Avg_Time\n    FROM \n        SessionDurations\n    GROUP BY \n        Current_Status\n)\nSELECT \n    Current_Status,\n    IAP_CATEGORY_NAME,\n    Number_of_Sessions,\n    Total_Session_Time,\n    Average_Session_Time\nFROM \n    SessionDurations\nUNION ALL\nSELECT \n    Current_Status,\n    'Subtotal' AS IAP_CATEGORY_NAME,\n    SUM(Number_of_Sessions) AS Number_of_Sessions,\n    SUM(Total_Session_Time) AS Total_Session_Time,\n    AVG(Average_Session_Time) AS Average_Session_Time\nFROM \n    SessionDurations\nGROUP BY \n    Current_Status\nUNION ALL\nSELECT \n    'Grand Total' AS Current_Status,\n    'All Sessions' AS IAP_CATEGORY_NAME,\n    SUM(Number_of_Sessions) AS Number_of_Sessions,\n    SUM(Total_Session_Time) AS Total_Session_Time,\n    AVG(Average_Session_Time) AS Average_Session_Time\nFROM \n    SessionDurations\nORDER BY \n    Current_Status, IAP_CATEGORY_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List each academic year, the term code, and the number of newly introduced subjects in this term. Display the academic year only if it differs from the previous entry. Include a grand total (the corresponding year field should be 'TOTAL') stating the total number of subjects across all academic years.",
        "predicted_sql": "SELECT \n    COALESCE(academic_year, 'TOTAL') AS academic_year, \n    term_code, \n    COUNT(subject_id) AS num_of_new_subjects\nFROM (\n    SELECT \n        AACADEMIC_YEAR, \n        TERM_CODE, \n        SUBJECT_ID, \n        ROW_NUMBER() OVER (PARTITION BY AACADEMIC_YEAR, TERM_CODE ORDER BY SUBJECT_ID) AS rn \n    FROM \n        ACADEMIC_TERMS_ALL a\n    JOIN \n        COURSE_CATALOG_SUBJECT_OFFERED c ON a.TERM_CODE = c.TERM_CODE\n    WHERE \n        rn = 1\n) t\nGROUP BY \n    ROLLUP(academic_year, term_code)\nHAVING \n    COUNT(subject_id) > 0\nORDER BY \n    academic_year, term_code;"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with e (case insensitive), containing 10 to 20 members inclusive, and where over 75% are computer science students, provide the list name, owner, and member count.",
        "predicted_sql": "SELECT ml.MOIRA_LIST_NAME, mo.OWNER, COUNT(mld.MOIRA_LIST_MEMBER) AS member_count\nFROM MOIRA_LIST ml\nJOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN MOIRA_LIST_OWNER mo ON mld.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY\nJOIN SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN MIT_STUDENT_DIRECTORY msd ON sp.FULL_NAME = msd.FULL_NAME\nWHERE ml.MOIRA_LIST_NAME LIKE 'e%' \nGROUP BY ml.MOIRA_LIST_NAME, mo.OWNER\nHAVING COUNT(mld.MOIRA_LIST_MEMBER) BETWEEN 10 AND 20 \n   AND SUM(CASE WHEN msd.DEPARTMENT = '10' THEN 1 ELSE 0 END) * 1.0 / COUNT(mld.MOIRA_LIST_MEMBER) > 0.75;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with K, list their names, the phone numbers of departments they belong to, total number of mailing lists each student is in, and the average size of the mailing lists each student is in.",
        "predicted_sql": "SELECT \n    MSD.FULL_NAME, \n    SAD.DEPARTMENT_PHONE_NUMBER, \n    COUNT(MLD.MOIRA_LIST_KEY) AS total_maillists, \n    AVG(SIZE) AS avg_maillist_size\nFROM \n    MIT_STUDENT_DIRECTORY MSD\nJOIN \n    SIS_DEPARTMENT SD ON MSD.DEPARTMENT = SD.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT SAD ON SD.DEPARTMENT_CODE = SAD.SIS_ADMIN_DEPARTMENT_CODE\nLEFT JOIN \n    MOIRA_LIST_DETAIL MLD ON MSD.FULL_NAME = MLD.MOIRA_LIST_MEMBER_FULL_NAME\nLEFT JOIN \n    (SELECT MOIRA_LIST_KEY, COUNT(MOIRA_LIST_MEMBER) AS SIZE\n     FROM MOIRA_LIST_DETAIL\n     GROUP BY MOIRA_LIST_KEY) AS ML_SIZE ON MLD.MOIRA_LIST_KEY = ML_SIZE.MOIRA_LIST_KEY\nWHERE \n    MSD.LAST_NAME LIKE 'K%' \nGROUP BY \n    MSD.FULL_NAME, SAD.DEPARTMENT_PHONE_NUMBER;"
    },
    {
        "db_id": "dw",
        "question": "From the 100 email lists with the most number of subscribers, list their names, their total number of subscribers, their public status, the name of the department with the most presence in the list, and the number of students from this department in the list.",
        "predicted_sql": "WITH SubscriberCounts AS (\n    SELECT \n        ml.MOIRA_LIST_NAME,\n        COUNT(mld.MOIRA_LIST_MEMBER) AS total_subscribers,\n        ml.IS_PUBLIC,\n        mld.MOIRA_LIST_MEMBER_MIT_ID\n    FROM \n        MOIRA_LIST ml\n    JOIN \n        MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n    GROUP BY \n        ml.MOIRA_LIST_NAME, ml.IS_PUBLIC\n),\nDepartmentCounts AS (\n    SELECT \n        sc.MOIRA_LIST_NAME,\n        sd.DEPARTMENT_NAME,\n        COUNT(*) AS student_count\n    FROM \n        SubscriberCounts sc\n    JOIN \n        MIT_STUDENT_DIRECTORY msd ON sc.MOIRA_LIST_MEMBER_MIT_ID = msd.FULL_NAME_UPPERCASE\n    JOIN \n        SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\n    GROUP BY \n        sc.MOIRA_LIST_NAME, sd.DEPARTMENT_NAME\n),\nMaxDepartments AS (\n    SELECT \n        dc.MOIRA_LIST_NAME,\n        dc.DEPARTMENT_NAME,\n        dc.student_count,\n        ROW_NUMBER() OVER (PARTITION BY dc.MOIRA_LIST_NAME ORDER BY dc.student_count DESC) AS rn\n    FROM \n        DepartmentCounts dc\n)\nSELECT \n    sc.MOIRA_LIST_NAME,\n    sc.total_subscribers,\n    sc.IS_PUBLIC,\n    md.DEPARTMENT_NAME,\n    md.student_count\nFROM \n    SubscriberCounts sc\nLEFT JOIN \n    MaxDepartments md ON sc.MOIRA_LIST_NAME = md.MOIRA_LIST_NAME AND md.rn = 1\nORDER BY \n    sc.total_subscribers DESC\nLIMIT 100;"
    },
    {
        "db_id": "dw",
        "question": "Calculate the total assignable and non-assignable area for each building by summing up the respective areas of all its floors. For each building, list the building name, building number, total assignable area, total non-assignable area, and total room count, sorted in descending order of the total assignable area.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME AS building_name,\n    b.BUILDING_NUMBER AS building_number,\n    SUM(f.ASSIGNABLE_AREA) AS total_assignable_area,\n    SUM(f.NON_ASSIGNABLE_AREA) AS total_non_assignable_area,\n    COUNT(r.FAC_ROOM_KEY) AS total_room_count\nFROM \n    FAC_BUILDING b\nJOIN \n    FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nJOIN \n    FAC_ROOMS r ON f.BUILDING_KEY = r.BUILDING_KEY AND f.FLOOR = r.FLOOR\nGROUP BY \n    b.BUILDING_NAME, b.BUILDING_NUMBER\nORDER BY \n    total_assignable_area DESC;"
    },
    {
        "db_id": "dw",
        "question": "List all rooms in building 45, including their full name, area, major use, the organization that occupies them, the count of rooms per major use, and the total area occupied by rooms for each organization.",
        "predicted_sql": "SELECT \n    FR.ROOM_FULL_NAME,\n    FR.AREA,\n    FMU.MAJOR_USE,\n    FO.ORGANIZATION_NAME,\n    COUNT(FR.FAC_ROOM_KEY) OVER (PARTITION BY FMU.MAJOR_USE) AS room_count_per_major_use,\n    SUM(FR.AREA) OVER (PARTITION BY FO.ORGANIZATION_NAME) AS total_area_per_organization\nFROM \n    FAC_ROOMS FR\nJOIN \n    FAC_MAJOR_USE FMU ON FR.MAJOR_USE_KEY = FMU.MAJOR_USE_KEY\nJOIN \n    FAC_ORGANIZATION FO ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY\nWHERE \n    FR.BUILDING_KEY = '45';"
    },
    {
        "db_id": "dw",
        "question": "List the name, number, construction date, and type of all buildings, along with the count of addresses associated with each building, the average gross area of the buildings, and the total number of rooms in each building. Sort the results by building name.",
        "predicted_sql": "SELECT \n    FB.BUILDING_NAME AS name,\n    FB.BUILDING_NUMBER AS number,\n    FB.DATE_BUILT AS construction_date,\n    FB.BUILDING_TYPE AS type,\n    COUNT(DISTINCT FBA.BUILDING_ADDRESS_KEY) AS address_count,\n    AVG(CAST(FB.EXT_GROSS_AREA AS FLOAT)) AS average_gross_area,\n    COUNT(DISTINCT FR.FAC_ROOM_KEY) AS total_rooms\nFROM \n    FAC_BUILDING FB\nLEFT JOIN \n    FAC_BUILDING_ADDRESS FBA ON FB.FAC_BUILDING_KEY = FBA.BUILDING_KEY\nLEFT JOIN \n    FAC_ROOMS FR ON FB.FAC_BUILDING_KEY = FR.BUILDING_KEY\nGROUP BY \n    FB.BUILDING_NAME, FB.BUILDING_NUMBER, FB.DATE_BUILT, FB.BUILDING_TYPE\nORDER BY \n    FB.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list its name, number of unique courses offered, the number of unique reserved materials, and the number of unique instructors associated with those courses, sorted by the number of unique courses offered in descending order.",
        "predicted_sql": "SELECT \n    so.OFFER_DEPT_NAME AS department_name,\n    COUNT(DISTINCT so.MASTER_COURSE_NUMBER) AS unique_courses,\n    COUNT(DISTINCT rc.CATALOG_TITLE) AS unique_reserved_materials,\n    COUNT(DISTINCT ci.INSTRUCTOR_NAME) AS unique_instructors\nFROM \n    LIBRARY_SUBJECT_OFFERED so\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL md ON so.LIBRARY_SUBJECT_OFFERED_KEY = md.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG rc ON md.LIBRARY_RESERVE_CATALOG_KEY = rc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR ci ON md.LIBRARY_COURSE_INSTRUCTOR_KEY = ci.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    so.OFFER_DEPT_NAME\nORDER BY \n    unique_courses DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each course title, list the title, the total number of reserved materials, and the count of distinct material status associated with those materials, sorted by the total number of reserved materials in descending order.",
        "predicted_sql": "SELECT \n    LSO.SUBJECT_TITLE, \n    COUNT(DISTINCT LRM.LIBRARY_RESERVE_CATALOG_KEY) AS total_reserved_materials,\n    COUNT(DISTINCT LMS.LIBRARY_MATERIAL_STATUS) AS distinct_material_status_count\nFROM \n    LIBRARY_SUBJECT_OFFERED LSO\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRM ON LSO.LIBRARY_SUBJECT_OFFERED_KEY = LRM.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS LMS ON LRM.LIBRARY_MATERIAL_STATUS_KEY = LMS.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    LSO.SUBJECT_TITLE\nORDER BY \n    total_reserved_materials DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each instructor, list their name, the number of unique courses they teach, the total number of material assignments, average publication year, and number of distinct status, sorted by the number of unique courses in descending order.",
        "predicted_sql": "SELECT \n    ci.INSTRUCTOR_NAME, \n    COUNT(DISTINCT ci.COURSE_NAME) AS unique_courses, \n    COUNT(rm.LIBRARY_RESERVE_CATALOG_KEY) AS total_material_assignments, \n    AVG(CAST(rc.CATALOG_YEAR AS INTEGER)) AS average_publication_year, \n    COUNT(DISTINCT ms.LIBRARY_MATERIAL_STATUS_CODE) AS distinct_status\nFROM \n    LIBRARY_COURSE_INSTRUCTOR ci\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL rm ON ci.LIBRARY_COURSE_INSTRUCTOR_KEY = rm.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG rc ON rm.LIBRARY_RESERVE_CATALOG_KEY = rc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS ms ON rm.LIBRARY_MATERIAL_STATUS_KEY = ms.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    ci.INSTRUCTOR_NAME\nORDER BY \n    unique_courses DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each publication year, list the year, the total number of reserved materials, the average length of their titles, distinct number of status, and number of courses, sorted by publication year in descending order.",
        "predicted_sql": "SELECT \n    CATALOG_YEAR AS publication_year,\n    COUNT(DISTINCT RLC.LIBRARY_RESERVE_CATALOG_KEY) AS total_reserved_materials,\n    AVG(LENGTH(RLC.CATALOG_TITLE)) AS average_title_length,\n    COUNT(DISTINCT LMS.LIBRARY_MATERIAL_STATUS) AS distinct_status_count,\n    COUNT(DISTINCT I.COURSE_NAME) AS total_courses\nFROM \n    LIBRARY_RESERVE_CATALOG RLC\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL RMD ON RLC.LIBRARY_RESERVE_CATALOG_KEY = RMD.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS LMS ON RMD.LIBRARY_MATERIAL_STATUS_KEY = LMS.LIBRARY_MATERIAL_STATUS_KEY\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR I ON RMD.LIBRARY_COURSE_INSTRUCTOR_KEY = I.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    CATALOG_YEAR\nORDER BY \n    publication_year DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list the category name, the sponsor name, the number of activities offered, and the average fee per activity, sorted by the number of activities in descending order.",
        "predicted_sql": "SELECT \n    isc.IAP_CATEGORY_NAME, \n    iss.SPONSOR_NAME, \n    COUNT(isd.IAP_SUBJECT_SESSION_KEY) AS number_of_activities, \n    AVG(isd.FEE) AS average_fee \nFROM \n    IAP_SUBJECT_CATEGORY isc\nJOIN \n    IAP_SUBJECT_DETAIL isd ON isc.IAP_SUBJECT_CATEGORY_KEY = isd.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    IAP_SUBJECT_SPONSOR iss ON isd.IAP_SUBJECT_SPONSOR_KEY = iss.IAP_SUBJECT_SPONSOR_KEY\nGROUP BY \n    isc.IAP_CATEGORY_NAME, iss.SPONSOR_NAME \nORDER BY \n    number_of_activities DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor, list the sponsor name, the number of IAP sessions hosted, and the number of unique subjects organized.",
        "predicted_sql": "SELECT \n    s.SPONSOR_NAME,\n    COUNT(DISTINCT ses.IAP_SUBJECT_SESSION_KEY) AS num_iap_sessions,\n    COUNT(DISTINCT det.IAP_SUBJECT_CATEGORY_KEY) AS num_unique_subjects\nFROM \n    IAP_SUBJECT_SPONSOR s\nLEFT JOIN \n    IAP_SUBJECT_DETAIL det ON s.IAP_SUBJECT_SPONSOR_KEY = det.IAP_SUBJECT_SPONSOR_KEY\nLEFT JOIN \n    IAP_SUBJECT_SESSION ses ON det.IAP_SUBJECT_SESSION_KEY = ses.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    s.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each person role and IAP category, list the role, the category name, the number of people in this role, and the average fee, sorted by the role count in descending order.",
        "predicted_sql": "SELECT \n    sp.PERSON_ROLE, \n    sc.IAP_CATEGORY_NAME, \n    COUNT(sp.IAP_SUBJECT_PERSON_KEY) AS number_of_people, \n    AVG(sd.FEE) AS average_fee \nFROM \n    IAP_SUBJECT_PERSON sp \nJOIN \n    IAP_SUBJECT_DETAIL sd ON sp.IAP_SUBJECT_PERSON_KEY = sd.IAP_SUBJECT_PERSON_KEY \nJOIN \n    IAP_SUBJECT_CATEGORY sc ON sd.IAP_SUBJECT_CATEGORY_KEY = sc.IAP_SUBJECT_CATEGORY_KEY \nGROUP BY \n    sp.PERSON_ROLE, sc.IAP_CATEGORY_NAME \nORDER BY \n    number_of_people DESC;"
    },
    {
        "db_id": "dw",
        "question": "List the names of the buildings with the most floors. If there are ties, list each one separately.",
        "predicted_sql": "SELECT b.BUILDING_NAME\nFROM FAC_BUILDING b\nJOIN FAC_ROOMS r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY\nJOIN FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nGROUP BY b.BUILDING_NAME\nHAVING COUNT(DISTINCT f.LEVEL_ID) = (\n    SELECT MAX(floor_count)\n    FROM (\n        SELECT COUNT(DISTINCT f2.LEVEL_ID) AS floor_count\n        FROM FAC_BUILDING b2\n        JOIN FAC_ROOMS r2 ON b2.FAC_BUILDING_KEY = r2.BUILDING_KEY\n        JOIN FAC_FLOOR f2 ON r2.FLOOR_KEY = f2.FLOOR_KEY\n        GROUP BY b2.BUILDING_NAME\n    ) AS subquery\n);"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered in the summer term, list the subject titles, number of instructors, and the length of the longest instructor name.",
        "predicted_sql": "SELECT \n    CCSO.SUBJECT_TITLE, \n    COUNT(ED.FULL_NAME) AS NUMBER_OF_INSTRUCTORS, \n    MAX(LENGTH(ED.FULL_NAME)) AS LENGTH_OF_LONGEST_INSTRUCTOR_NAME\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED CCSO\nJOIN \n    EMPLOYEE_DIRECTORY ED ON CCSO.RESPONSIBLE_FACULTY_MIT_ID = ED.MIT_ID\nJOIN \n    ACADEMIC_TERMS_ALL ATA ON CCSO.TERM_CODE = ATA.TERM_CODE\nWHERE \n    ATA.IS_CURRENT_TERM = 'Y' AND \n    CCSO.IS_OFFERED_SUMMER_TERM = 'Y'\nGROUP BY \n    CCSO.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For the mailing list with owner key LIST69.377-keeper-xenon, list the owner, total number of mailing lists, and total number of members across all these mailing lists.",
        "predicted_sql": "SELECT \n    o.OWNER,\n    COUNT(DISTINCT l.MOIRA_LIST_KEY) AS total_mailing_lists,\n    COUNT(ld.MOIRA_LIST_MEMBER) AS total_members\nFROM \n    MOIRA_LIST_OWNER o\nJOIN \n    MOIRA_LIST l ON o.MOIRA_LIST_OWNER_KEY = l.MOIRA_LIST_OWNER_KEY\nJOIN \n    MOIRA_LIST_DETAIL ld ON l.MOIRA_LIST_KEY = ld.MOIRA_LIST_KEY\nWHERE \n    o.MOIRA_LIST_OWNER_KEY = 'LIST69.377-keeper-xenon'\nGROUP BY \n    o.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For each school, list the school name, total number of courses that appear in SIS subject code catalog, and the total number of degree-granting courses that appear in SIS subject code catalog.",
        "predicted_sql": "SELECT \n    d.SCHOOL_NAME, \n    COUNT(DISTINCT s.COURSE_NUMBER) AS total_courses, \n    COUNT(DISTINCT CASE WHEN c.IS_DEGREE_GRANTING = 'Y' THEN s.COURSE_NUMBER END) AS total_degree_granting_courses\nFROM \n    SIS_DEPARTMENT d\nJOIN \n    SIS_COURSE_DESCRIPTION c ON d.DEPARTMENT_CODE = c.DEPARTMENT\nJOIN \n    SIS_SUBJECT_CODE s ON c.COURSE = s.COURSE_NUMBER\nGROUP BY \n    d.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the department name, department phone number, number of students, and the length of the longest student full name in that department.",
        "predicted_sql": "SELECT \n    SIS_DEPARTMENT.DEPARTMENT_NAME,\n    SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER,\n    COUNT(MIT_STUDENT_DIRECTORY.EMAIL_ADDRESS) AS number_of_students,\n    MAX(LENGTH(MIT_STUDENT_DIRECTORY.FULL_NAME)) AS longest_student_full_name_length\nFROM \n    SIS_DEPARTMENT\nJOIN \n    SIS_ADMIN_DEPARTMENT ON SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE = SIS_DEPARTMENT.DEPARTMENT_CODE\nLEFT JOIN \n    MIT_STUDENT_DIRECTORY ON MIT_STUDENT_DIRECTORY.DEPARTMENT = SIS_DEPARTMENT.DEPARTMENT_CODE\nGROUP BY \n    SIS_DEPARTMENT.DEPARTMENT_NAME, \n    SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER;"
    }
]