[
    {
        "db_id": "dw",
        "question": "What is the current building key, building street address, city, state, and postal code of the history department?",
        "predicted_sql": "SELECT \n    b.BUILDING_KEY, \n    b.BUILDING_STREET_ADDRESS, \n    fba.CITY, \n    fba.STATE, \n    fba.POSTAL_CODE\nFROM \n    FCLT_BUILDING_ADDRESS fba\nJOIN \n    FCLT_ROOMS fr ON fba.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY\nJOIN \n    FCLT_ORG_DLC_KEY fok ON fr.FCLT_ORGANIZATION_KEY = fok.FCLT_ORGANIZATION_KEY\nJOIN \n    MASTER_DEPT_HIERARCHY mdh ON fok.DLC_KEY = mdh.DLC_KEY\nJOIN \n    BUILDINGS b ON fba.FCLT_BUILDING_KEY = b.BUILDING_KEY\nWHERE \n    mdh.DLC_NAME = 'History';"
    },
    {
        "db_id": "dw",
        "question": "Show the unique activity titles, locations, term start date, and supervisor name for all independent activities, sorted by the ascending order of start date.",
        "predicted_sql": "SELECT DISTINCT \n    d.ACTIVITY_TITLE, \n    s.SESSION_LOCATION, \n    t.TERM_START_DATE, \n    p.PERSON_NAME AS SUPERVISOR_NAME\nFROM \n    IAP_SUBJECT_DETAIL d\nJOIN \n    IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nJOIN \n    ACADEMIC_TERMS_ALL t ON d.TERM_CODE = t.TERM_CODE\nJOIN \n    IAP_SUBJECT_PERSON p ON d.IAP_SUBJECT_PERSON_KEY = p.IAP_SUBJECT_PERSON_KEY\nWHERE \n    p.PERSON_ROLE = 'Activity leader'\nORDER BY \n    t.TERM_START_DATE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the unique course instructor names, course titles, and the amount of material for each course instructor key and the key of subject offered.",
        "predicted_sql": "SELECT \n    lci.INSTRUCTOR_NAME AS course_instructor_name,\n    lso.SUBJECT_TITLE AS course_title,\n    COUNT(DISTINCT lrc.CATALOG_ISBN) AS amount_of_material,\n    lci.LIBRARY_COURSE_INSTRUCTOR_KEY AS course_instructor_key,\n    lso.LIBRARY_SUBJECT_OFFERED_KEY AS subject_offered_key\nFROM \n    LIBRARY_COURSE_INSTRUCTOR lci\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nGROUP BY \n    lci.INSTRUCTOR_NAME, lso.SUBJECT_TITLE, lci.LIBRARY_COURSE_INSTRUCTOR_KEY, lso.LIBRARY_SUBJECT_OFFERED_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What is the room, floor, building key, building street address, city, state, and postal code of Professor Summer Haynes's office?",
        "predicted_sql": "SELECT \n    fr.ROOM, \n    fr.FLOOR, \n    fr.BUILDING_KEY, \n    b.BUILDING_STREET_ADDRESS, \n    fba.CITY, \n    fba.STATE, \n    fba.POSTAL_CODE\nFROM \n    EMPLOYEE_DIRECTORY ed\nJOIN \n    FAC_ROOMS fr ON ed.OFFICE_LOCATION = fr.FAC_ROOM_KEY\nJOIN \n    FAC_BUILDING_ADDRESS fba ON fr.BUILDING_KEY = fba.BUILDING_KEY\nJOIN \n    BUILDINGS b ON fba.BUILDING_KEY = b.BUILDING_KEY\nWHERE \n    ed.FULL_NAME = 'Haynes, Summer'"
    },
    {
        "db_id": "dw",
        "question": "List the unique full room names, their corresponding building names, street addresses, cities, states, postal codes, and building heights for rooms associated with subjects that Computer Science students can enroll in.",
        "predicted_sql": "SELECT DISTINCT \n    FR.ROOM_FULL_NAME, \n    B.BUILDING_NAME, \n    B.BUILDING_STREET_ADDRESS, \n    FBA.CITY, \n    FBA.STATE, \n    FBA.POSTAL_CODE, \n    FB.BUILDING_HEIGHT\nFROM \n    FCLT_ROOMS FR\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED CCSO ON CCSO.MEET_PLACE = FR.FCLT_ROOM_KEY\nJOIN \n    FCLT_BUILDING_ADDRESS FBA ON FBA.FCLT_BUILDING_KEY = FR.FCLT_BUILDING_KEY\nJOIN \n    FCLT_BUILDING FB ON FB.FCLT_BUILDING_KEY = FR.FCLT_BUILDING_KEY\nJOIN \n    BUILDINGS B ON B.BUILDING_KEY = FR.FCLT_BUILDING_KEY\nWHERE \n    CCSO.DEPARTMENT_NAME = 'Electrical Eng & Computer Sci';"
    },
    {
        "db_id": "dw",
        "question": "List the unique term code, subject title, room, floor, building key, building street address, city, state, and postal code, formats, and number of enrolled students for all courses with more than 300 attendees.",
        "predicted_sql": "SELECT DISTINCT \n    so.TERM_CODE, \n    so.SUBJECT_TITLE, \n    fr.ROOM, \n    fr.FLOOR, \n    b.BUILDING_KEY, \n    b.BUILDING_STREET_ADDRESS, \n    fba.CITY, \n    fba.STATE, \n    fba.POSTAL_CODE, \n    so.FORM_TYPE, \n    so.NUM_ENROLLED_STUDENTS\nFROM \n    SUBJECT_OFFERED so\nJOIN \n    FCLT_ROOMS fr ON so.MEET_PLACE = fr.FCLT_ROOM_KEY\nJOIN \n    BUILDINGS b ON fr.FCLT_BUILDING_KEY = b.BUILDING_KEY\nJOIN \n    FCLT_BUILDING_ADDRESS fba ON fba.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY\nWHERE \n    so.NUM_ENROLLED_STUDENTS > 300\n    AND fba.ADDRESS_PURPOSE = 'STREET';"
    },
    {
        "db_id": "dw",
        "question": "What are the subject titles, their material titles, ISBN numbers, new shelf prices, and total costs of new materials for each subject title, sorted by individual item prices in ascending order?",
        "predicted_sql": "SELECT \n    tso.SUBJECT_TITLE,\n    tm.TITLE AS MATERIAL_TITLE,\n    tm.ISBN,\n    tm.NEW_SHELF_PRICE,\n    tm.NEW_SHELF_PRICE AS TOTAL_COST_OF_NEW_MATERIALS\nFROM \n    TIP_DETAIL td\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN \n    TIP_SUBJECT_OFFERED tso ON td.SUBJECT_ID = tso.SUBJECT_ID\nORDER BY \n    tm.NEW_SHELF_PRICE ASC;"
    },
    {
        "db_id": "dw",
        "question": "List the long names of buildings constructed before 1950 that have more than 100 employees, the built year of the building, and number of employees.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME_LONG, \n    b.DATE_BUILT, \n    COUNT(e.MIT_ID) AS number_of_employees\nFROM \n    FCLT_BUILDING_HIST b\nJOIN \n    FCLT_ROOMS r ON b.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY\nJOIN \n    EMPLOYEE_DIRECTORY e ON r.BUILDING_ROOM = e.OFFICE_LOCATION\nWHERE \n    STR_TO_DATE(b.DATE_BUILT, '%m/%d/%Y') < STR_TO_DATE('01/01/1950', '%m/%d/%Y')\nGROUP BY \n    b.BUILDING_NAME_LONG, b.DATE_BUILT\nHAVING \n    COUNT(e.MIT_ID) > 100;"
    },
    {
        "db_id": "dw",
        "question": "For each building key, what is the building name and the number of courses offered by the Center for International Studies?",
        "predicted_sql": "SELECT \n    fb.FCLT_BUILDING_KEY AS building_key,\n    fb.BUILDING_NAME AS building_name,\n    COUNT(DISTINCT cco.SUBJECT_ID) AS number_of_courses\nFROM \n    FCLT_BUILDING fb\nJOIN \n    FCLT_ROOMS fr ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED cco ON fr.BUILDING_ROOM = cco.MEET_PLACE\nJOIN \n    CIS_COURSE_CATALOG ccc ON cco.SUBJECT_ID = ccc.SUBJECT_ID\nWHERE \n    ccc.DEPARTMENT_NAME = 'Political Science'\nGROUP BY \n    fb.FCLT_BUILDING_KEY, fb.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building that accomodates the most students, and how many students does it accomodate?",
        "predicted_sql": "SELECT \n    fb.BUILDING_NAME, \n    COUNT(DISTINCT msd.FULL_NAME) AS student_count\nFROM \n    FCLT_BUILDING fb\nJOIN \n    FCLT_ROOMS fr ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY\nJOIN \n    MIT_STUDENT_DIRECTORY msd ON fr.BUILDING_ROOM = msd.OFFICE_LOCATION\nGROUP BY \n    fb.BUILDING_NAME\nORDER BY \n    student_count DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "List the name and floor of the building with the largest floor number.",
        "predicted_sql": "SELECT b.BUILDING_NAME, f.FLOOR\nFROM FAC_BUILDING b\nJOIN FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nORDER BY f.FLOOR + 0 DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category and academic year, list the category name, academic year, total fee collected, total number of IAP subjects, and the minimum and maximum enrollment.",
        "predicted_sql": "SELECT \n    isc.IAP_CATEGORY_NAME,\n    td.ACADEMIC_YEAR,\n    SUM(isd.FEE) AS total_fee_collected,\n    COUNT(DISTINCT isd.ACTIVITY_TITLE) AS total_number_of_IAP_subjects,\n    MIN(isd.MAX_ENROLLMENT) AS minimum_enrollment,\n    MAX(isd.MAX_ENROLLMENT) AS maximum_enrollment\nFROM \n    IAP_SUBJECT_CATEGORY isc\nJOIN \n    IAP_SUBJECT_DETAIL isd ON isc.IAP_SUBJECT_CATEGORY_KEY = isd.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    TIME_DAY td ON td.ACADEMIC_TERM_CODE = isd.TERM_CODE\nGROUP BY \n    isc.IAP_CATEGORY_NAME, td.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor of the independent activity periods, list the sponsor name, number of sessions held, the total number of enrollment, the minimum and maximum fee, the number of sessions with info, and the number of sessions without info.",
        "predicted_sql": "SELECT \n    s.SPONSOR_NAME,\n    COUNT(DISTINCT d.IAP_SUBJECT_SESSION_KEY) AS number_of_sessions,\n    SUM(d.MAX_ENROLLMENT) AS total_enrollment,\n    MIN(d.FEE) AS minimum_fee,\n    MAX(d.FEE) AS maximum_fee,\n    SUM(CASE WHEN ss.HAS_SESSION_INFO = 'Y' THEN 1 ELSE 0 END) AS sessions_with_info,\n    SUM(CASE WHEN ss.HAS_SESSION_INFO = 'N' THEN 1 ELSE 0 END) AS sessions_without_info\nFROM \n    IAP_SUBJECT_SPONSOR s\nJOIN \n    IAP_SUBJECT_DETAIL d ON s.IAP_SUBJECT_SPONSOR_KEY = d.IAP_SUBJECT_SPONSOR_KEY\nJOIN \n    IAP_SUBJECT_SESSION ss ON d.IAP_SUBJECT_SESSION_KEY = ss.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    s.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the individual's email and name, academic year, total number of IAP subjects, the minimum and maximum fees, and the total course enrollment for each individual and academic year?",
        "predicted_sql": "SELECT \n    isp.PERSON_EMAIL AS email,\n    isp.PERSON_NAME AS name,\n    td.ACADEMIC_YEAR AS academic_year,\n    COUNT(DISTINCT isd.ACTIVITY_TITLE) AS total_iap_subjects,\n    MIN(isd.FEE) AS min_fee,\n    MAX(isd.FEE) AS max_fee,\n    SUM(isd.MAX_ENROLLMENT) AS total_course_enrollment\nFROM \n    IAP_SUBJECT_DETAIL isd\nJOIN \n    IAP_SUBJECT_PERSON isp ON isd.IAP_SUBJECT_PERSON_KEY = isp.IAP_SUBJECT_PERSON_KEY\nJOIN \n    TIME_DAY td ON td.ACADEMIC_TERM_CODE = isd.TERM_CODE\nGROUP BY \n    isp.PERSON_EMAIL, isp.PERSON_NAME, td.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "What is the term code, term description, total number of IAP sessions, total fee collected, and minimum and maximum enrollment for each term code?",
        "predicted_sql": "SELECT \n    iapd.TERM_CODE,\n    ata.TERM_DESCRIPTION,\n    COUNT(DISTINCT iaps.IAP_SUBJECT_SESSION_KEY) AS total_iap_sessions,\n    SUM(iapd.FEE) AS total_fee_collected,\n    MIN(iapd.MAX_ENROLLMENT) AS min_enrollment,\n    MAX(iapd.MAX_ENROLLMENT) AS max_enrollment\nFROM \n    IAP_SUBJECT_DETAIL iapd\nJOIN \n    ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = iapd.TERM_CODE\nJOIN \n    IAP_SUBJECT_SESSION iaps ON iaps.IAP_SUBJECT_SESSION_KEY = iapd.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    iapd.TERM_CODE, ata.TERM_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "What is the name of the building, total number of subjects, total fee, and shortest and longest sessions for each physical IAP session location?",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME,\n    COUNT(DISTINCT d.IAP_SUBJECT_SESSION_KEY) AS total_subjects,\n    SUM(d.FEE) AS total_fee,\n    MIN(TIMEDIFF(s.SESSION_END_TIME, s.SESSION_START_TIME)) AS shortest_session,\n    MAX(TIMEDIFF(s.SESSION_END_TIME, s.SESSION_START_TIME)) AS longest_session\nFROM \n    IAP_SUBJECT_SESSION s\nJOIN \n    IAP_SUBJECT_DETAIL d ON s.IAP_SUBJECT_SESSION_KEY = d.IAP_SUBJECT_SESSION_KEY\nJOIN \n    BUILDINGS b ON s.SESSION_LOCATION = b.BUILDING_NUMBER\nWHERE \n    s.SESSION_LOCATION NOT IN ('NE45', 'On line')\nGROUP BY \n    b.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is total number of subjects, the total fee, and the shortest and longest sessions, for all virtual IAP sessions?",
        "predicted_sql": "SELECT \n    COUNT(DISTINCT IAP_SUBJECT_DETAIL.ACTIVITY_TITLE) AS total_subjects,\n    SUM(IAP_SUBJECT_DETAIL.FEE) AS total_fee,\n    MIN(TIMESTAMPDIFF(MINUTE, STR_TO_DATE(IAP_SUBJECT_SESSION.SESSION_START_TIME, '%h%i%p'), STR_TO_DATE(IAP_SUBJECT_SESSION.SESSION_END_TIME, '%h%i%p'))) AS shortest_session_minutes,\n    MAX(TIMESTAMPDIFF(MINUTE, STR_TO_DATE(IAP_SUBJECT_SESSION.SESSION_START_TIME, '%h%i%p'), STR_TO_DATE(IAP_SUBJECT_SESSION.SESSION_END_TIME, '%h%i%p'))) AS longest_session_minutes\nFROM \n    IAP_SUBJECT_DETAIL\nJOIN \n    IAP_SUBJECT_SESSION ON IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY = IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY\nWHERE \n    IAP_SUBJECT_SESSION.SESSION_LOCATION IN ('https://mit.zoom.us/', 'On line');"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, full name of the department, course level, total number of courses, and total number of degree-granting courses for each school code, department, and course level?",
        "predicted_sql": "SELECT \n    ssc.SCHOOL_CODE,\n    ssc.SCHOOL_NAME,\n    sd.DEPARTMENT_FULL_NAME,\n    scd.COURSE_LEVEL,\n    COUNT(DISTINCT scd.COURSE) AS total_courses,\n    COUNT(DISTINCT CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN scd.COURSE END) AS total_degree_granting_courses\nFROM \n    SIS_COURSE_DESCRIPTION scd\nJOIN \n    SIS_DEPARTMENT sd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT\nJOIN \n    SIS_SUBJECT_CODE ssc ON scd.COURSE = ssc.SUBJECT_CODE\nGROUP BY \n    ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DEPARTMENT_FULL_NAME, scd.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What are the different schools and departments that offer SIS courses? List their school code, school name, department code, department name, the total number of phone numbers, and the most common course level.",
        "predicted_sql": "SELECT \n    SSC.SCHOOL_CODE,\n    SSC.SCHOOL_NAME,\n    SD.DEPARTMENT_CODE,\n    SAD.SIS_ADMIN_DEPARTMENT_NAME AS DEPARTMENT_NAME,\n    COUNT(DISTINCT SAD.DEPARTMENT_PHONE_NUMBER) AS TOTAL_PHONE_NUMBERS,\n    (SELECT COURSE_LEVEL \n     FROM SIS_COURSE_DESCRIPTION SCD \n     WHERE SCD.DEPARTMENT = SD.DEPARTMENT_CODE \n     GROUP BY COURSE_LEVEL \n     ORDER BY COUNT(*) DESC \n     LIMIT 1) AS MOST_COMMON_COURSE_LEVEL\nFROM \n    SIS_SUBJECT_CODE SSC\nJOIN \n    SIS_COURSE_DESCRIPTION SCD ON SSC.SUBJECT_CODE = SCD.COURSE\nJOIN \n    SIS_DEPARTMENT SD ON SCD.DEPARTMENT = SD.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT SAD ON SD.DEPARTMENT_CODE = SAD.SIS_ADMIN_DEPARTMENT_CODE\nGROUP BY \n    SSC.SCHOOL_CODE, SSC.SCHOOL_NAME, SD.DEPARTMENT_CODE, SAD.SIS_ADMIN_DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the school code, school name, DLC key, the graduate level, total number of SIS subjects, the minimum and maximum course numbers, and the total number of departments offering subjects for each school?",
        "predicted_sql": "SELECT \n    sc.SCHOOL_CODE,\n    sc.SCHOOL_NAME,\n    d.DLC_KEY,\n    cd.GRADUATE_LEVEL,\n    COUNT(DISTINCT sc.SUBJECT_CODE) AS total_sis_subjects,\n    MIN(sc.COURSE_NUMBER) AS min_course_number,\n    MAX(sc.COURSE_NUMBER) AS max_course_number,\n    COUNT(DISTINCT d.DEPARTMENT_CODE) AS total_departments\nFROM \n    SIS_SUBJECT_CODE sc\nJOIN \n    SIS_COURSE_DESCRIPTION cd ON sc.SUBJECT_CODE = cd.COURSE\nJOIN \n    SIS_DEPARTMENT d ON cd.DEPARTMENT = d.DEPARTMENT_CODE\nGROUP BY \n    sc.SCHOOL_CODE, sc.SCHOOL_NAME, d.DLC_KEY, cd.GRADUATE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "What is the building component, name of the building, square footage for all rooms, total number of floors, total number of rooms, total number of facility organizations, total number of supervisors, and total number of supervisees for each building component?",
        "predicted_sql": "SELECT \n    sd.BUILDING_COMPONENT,\n    b.BUILDING_NAME,\n    SUM(sd.ROOM_SQUARE_FOOTAGE) AS total_room_square_footage,\n    COUNT(DISTINCT sf.FLOOR_KEY) AS total_number_of_floors,\n    COUNT(DISTINCT sd.BUILDING_ROOM) AS total_number_of_rooms,\n    COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS total_number_of_facility_organizations,\n    COUNT(DISTINCT ssu.MIT_ID) AS total_number_of_supervisors,\n    SUM(ssu.NUM_OF_SUPERVISEES) AS total_number_of_supervisees\nFROM \n    SPACE_DETAIL sd\nJOIN \n    BUILDINGS b ON sd.BUILDING_KEY = b.BUILDING_KEY\nJOIN \n    SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY\nJOIN \n    SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY\nJOIN \n    SPACE_SUPERVISOR_USAGE ssu ON su.DLC_KEY = ssu.DEPT_NAMES\nGROUP BY \n    sd.BUILDING_COMPONENT, b.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the DLC key, name of the DLC, total number of floors, total square footage, total number of facility organizations, total number of supervisors, total number of supervisees, and total building heights for each DLC?",
        "predicted_sql": "SELECT \n    su.DLC_KEY,\n    fo.DLC_NAME,\n    COUNT(DISTINCT sf.FLOOR_KEY) AS total_number_of_floors,\n    SUM(sd.ROOM_SQUARE_FOOTAGE) AS total_square_footage,\n    COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS total_number_of_facility_organizations,\n    COUNT(DISTINCT ssu.MIT_ID) AS total_number_of_supervisors,\n    SUM(ssu.NUM_OF_SUPERVISEES) AS total_number_of_supervisees,\n    SUM(CAST(fb.BUILDING_HEIGHT AS DECIMAL(10,2))) AS total_building_heights\nFROM \n    SPACE_UNIT su\nJOIN \n    FCLT_ORGANIZATION fo ON su.DLC_KEY = fo.DLC_KEY\nJOIN \n    SPACE_DETAIL sd ON su.SPACE_UNIT_KEY = sd.SPACE_UNIT_KEY\nJOIN \n    SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY\nJOIN \n    SPACE_SUPERVISOR_USAGE ssu ON su.DLC_KEY = ssu.DEPT_NAMES\nJOIN \n    FCLT_BUILDING fb ON sd.BUILDING_KEY = fb.FCLT_BUILDING_KEY\nGROUP BY \n    su.DLC_KEY, fo.DLC_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the department name, total number of types of TIP subjects, total number of enrolled students, the minimum and maximum rental new price for each department?",
        "predicted_sql": "SELECT \n    tso.OFFER_DEPT_NAME AS department_name,\n    COUNT(DISTINCT tso.SUBJECT_ID) AS total_types_of_tip_subjects,\n    SUM(tso.NUM_ENROLLED_STUDENTS) AS total_enrolled_students,\n    MIN(tm.RENTAL_NEW_PRICE) AS min_rental_new_price,\n    MAX(tm.RENTAL_NEW_PRICE) AS max_rental_new_price\nFROM \n    TIP_SUBJECT_OFFERED tso\nJOIN \n    TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nGROUP BY \n    tso.OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the details of courses offered in the current academic term, including the academic year, term code, hgn code, the total number of types of courses, the average number of units, the department name, the name and email address of the person in charge?",
        "predicted_sql": "SELECT \n    c.ACADEMIC_YEAR,\n    c.TERM_CODE,\n    s.HGN_CODE,\n    COUNT(DISTINCT c.SUBJECT_ID) AS total_types_of_courses,\n    AVG(c.TOTAL_UNITS) AS average_units,\n    c.DEPARTMENT_NAME,\n    e.FULL_NAME AS person_in_charge,\n    e.EMAIL_ADDRESS\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS a ON c.TERM_CODE = a.TERM_CODE\nJOIN \n    SUBJECT_OFFERED s ON c.SUBJECT_ID = s.SUBJECT_ID\nJOIN \n    EMPLOYEE_DIRECTORY e ON s.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nWHERE \n    a.IS_CURRENT_TERM = 'Y'\nGROUP BY \n    c.ACADEMIC_YEAR, c.TERM_CODE, s.HGN_CODE, c.DEPARTMENT_NAME, e.FULL_NAME, e.EMAIL_ADDRESS;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve information about the IAP subjects, including their titles, categories, session titles, session start time, session end time, sponsor names, and total number of sessions.",
        "predicted_sql": "SELECT \n    d.ACTIVITY_TITLE AS title,\n    c.IAP_CATEGORY_NAME AS category,\n    s.SESSION_TITLE AS session_title,\n    s.SESSION_START_TIME AS session_start_time,\n    s.SESSION_END_TIME AS session_end_time,\n    sp.SPONSOR_NAME AS sponsor_name,\n    COUNT(s.IAP_SUBJECT_SESSION_KEY) AS total_sessions\nFROM \n    IAP_SUBJECT_DETAIL d\nJOIN \n    IAP_SUBJECT_CATEGORY c ON d.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nJOIN \n    IAP_SUBJECT_SPONSOR sp ON d.IAP_SUBJECT_SPONSOR_KEY = sp.IAP_SUBJECT_SPONSOR_KEY\nGROUP BY \n    d.ACTIVITY_TITLE, c.IAP_CATEGORY_NAME, s.SESSION_TITLE, s.SESSION_START_TIME, s.SESSION_END_TIME, sp.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Show the department names, the corresponding SIS subject code, subject code descriptions, graduate level, and the total number of courses per department.",
        "predicted_sql": "SELECT \n    d.DEPARTMENT_NAME, \n    s.SUBJECT_CODE, \n    s.SUBJECT_CODE_DESC, \n    c.GRADUATE_LEVEL, \n    COUNT(DISTINCT c.COURSE) AS total_courses\nFROM \n    SIS_DEPARTMENT d\nJOIN \n    SIS_COURSE_DESCRIPTION c ON d.DEPARTMENT_CODE = c.DEPARTMENT\nJOIN \n    SIS_SUBJECT_CODE s ON s.COURSE_NUMBER = c.COURSE\nWHERE \n    c.GRADUATE_LEVEL = 'Masters'\nGROUP BY \n    d.DEPARTMENT_NAME, s.SUBJECT_CODE, s.SUBJECT_CODE_DESC, c.GRADUATE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "For each term, list the term code, the term description, whether the term is current or not, and the total number of types of CIS courses.",
        "predicted_sql": "SELECT \n    ata.TERM_CODE,\n    ata.TERM_DESCRIPTION,\n    ata.IS_CURRENT_TERM,\n    COUNT(DISTINCT ccc.SUBJECT_ID) AS total_cis_courses\nFROM \n    ACADEMIC_TERMS_ALL ata\nLEFT JOIN \n    CIS_COURSE_CATALOG ccc ON ata.ACADEMIC_YEAR = ccc.ACADEMIC_YEAR\nGROUP BY \n    ata.TERM_CODE, ata.TERM_DESCRIPTION, ata.IS_CURRENT_TERM;"
    },
    {
        "db_id": "dw",
        "question": "What is the author, school name, material status, total record counts, and total number of types of courses for each author and school?",
        "predicted_sql": "SELECT \n    tm.AUTHOR,\n    sd.SCHOOL_NAME,\n    tms.TIP_MATERIAL_STATUS,\n    SUM(td.RECORD_COUNT) AS total_record_counts,\n    COUNT(DISTINCT tso.SUBJECT_ID) AS total_number_of_types_of_courses\nFROM \n    TIP_DETAIL td\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN \n    TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nJOIN \n    TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    STUDENT_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE\nGROUP BY \n    tm.AUTHOR, sd.SCHOOL_NAME, tms.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is the course number, subject title, material status, the total, min, and max new shelf price, the total, min, and max used shelf price, total number of schools and the total number of materials for each TIP subject and material status?",
        "predicted_sql": "SELECT \n    tso.COURSE_NUMBER,\n    tso.SUBJECT_TITLE,\n    tms.TIP_MATERIAL_STATUS,\n    SUM(tm.NEW_SHELF_PRICE) AS total_new_shelf_price,\n    MIN(tm.NEW_SHELF_PRICE) AS min_new_shelf_price,\n    MAX(tm.NEW_SHELF_PRICE) AS max_new_shelf_price,\n    SUM(tm.USED_SHELF_PRICE) AS total_used_shelf_price,\n    MIN(tm.USED_SHELF_PRICE) AS min_used_shelf_price,\n    MAX(tm.USED_SHELF_PRICE) AS max_used_shelf_price,\n    COUNT(DISTINCT tso.OFFER_SCHOOL_NAME) AS total_schools,\n    COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS total_materials\nFROM \n    TIP_DETAIL td\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN \n    TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nJOIN \n    TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nGROUP BY \n    tso.COURSE_NUMBER, \n    tso.SUBJECT_TITLE, \n    tms.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is material status, the total number of materials, the total number of subjects, the total number of schools, and the most recent publication year for each material status?",
        "predicted_sql": "SELECT \n    tms.TIP_MATERIAL_STATUS AS material_status,\n    COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS total_number_of_materials,\n    COUNT(DISTINCT td.SUBJECT_ID) AS total_number_of_subjects,\n    COUNT(DISTINCT sd.SCHOOL_NAME) AS total_number_of_schools,\n    MAX(tm.YEAR) AS most_recent_publication_year\nFROM \n    TIP_DETAIL td\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN \n    TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nJOIN \n    TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    STUDENT_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE\nGROUP BY \n    tms.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "What is the term description, whether the term is current or not, total number of types of TIP subjects offered and materials needed, the minimum and maximum number of enrolled students, the total number of schools offering subjects, and the total number of records for each term code?",
        "predicted_sql": "SELECT \n    ata.TERM_DESCRIPTION,\n    ata.IS_CURRENT_TERM,\n    COUNT(DISTINCT tso.COURSE_NUMBER) AS total_types_of_TIP_subjects_offered,\n    COUNT(DISTINCT tm.ISBN) AS total_types_of_materials_needed,\n    MIN(tso.NUM_ENROLLED_STUDENTS) AS min_enrolled_students,\n    MAX(tso.NUM_ENROLLED_STUDENTS) AS max_enrolled_students,\n    COUNT(DISTINCT tso.OFFER_SCHOOL_NAME) AS total_schools_offering_subjects,\n    SUM(td.RECORD_COUNT) AS total_number_of_records\nFROM \n    ACADEMIC_TERMS_ALL ata\nJOIN \n    TIP_SUBJECT_OFFERED tso ON ata.TERM_CODE = tso.TERM_CODE\nJOIN \n    TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN \n    TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nGROUP BY \n    ata.TERM_CODE, ata.TERM_DESCRIPTION, ata.IS_CURRENT_TERM;"
    },
    {
        "db_id": "dw",
        "question": "List all buildings with their names, building numbers, building height, street address, city, state, HR department name, assignable square footage, total and average square footage, ordered in descending order of assignable, total, and average square footage.",
        "predicted_sql": "SELECT \n    B.BUILDING_NAME,\n    B.BUILDING_NUMBER,\n    FB.BUILDING_HEIGHT,\n    B.BUILDING_STREET_ADDRESS,\n    FBA.CITY,\n    FBA.STATE,\n    FO.HR_DEPARTMENT_NAME,\n    B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE,\n    SUM(FR.AREA) AS TOTAL_SQUARE_FOOTAGE,\n    AVG(FR.AREA) AS AVERAGE_SQUARE_FOOTAGE\nFROM \n    BUILDINGS B\nJOIN \n    FAC_BUILDING FB ON FB.FAC_BUILDING_KEY = B.BUILDING_KEY\nJOIN \n    FAC_ROOMS FR ON FR.BUILDING_KEY = FB.FAC_BUILDING_KEY\nJOIN \n    FAC_ORGANIZATION FO ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY\nJOIN \n    FAC_BUILDING_ADDRESS FBA ON FBA.BUILDING_KEY = B.BUILDING_KEY\nWHERE \n    FBA.CITY = 'CAMBRIDGE' AND FBA.STATE = 'MA'\nGROUP BY \n    B.BUILDING_NAME, \n    B.BUILDING_NUMBER, \n    FB.BUILDING_HEIGHT, \n    B.BUILDING_STREET_ADDRESS, \n    FBA.CITY, \n    FBA.STATE, \n    FO.HR_DEPARTMENT_NAME, \n    B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE\nORDER BY \n    B.BLDG_ASSIGNABLE_SQUARE_FOOTAGE DESC, \n    TOTAL_SQUARE_FOOTAGE DESC, \n    AVERAGE_SQUARE_FOOTAGE DESC;"
    },
    {
        "db_id": "dw",
        "question": "For the 2023 Fall term, what are the unique term descriptions, subject titles along with their prerequisites, total number of types of subjects per term code, instructor of this course, and the number of types of courses ever taught by the instructor?",
        "predicted_sql": "SELECT \n    DISTINCT at.TERM_DESCRIPTION, \n    ccso.SUBJECT_TITLE, \n    ccso.PREREQUISITES, \n    COUNT(DISTINCT ccso.SUBJECT_ID) AS total_subject_types_per_term_code, \n    ccso.FALL_INSTRUCTORS, \n    COUNT(DISTINCT ccso2.SUBJECT_ID) AS total_course_types_by_instructor\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED ccso\nJOIN \n    ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE\nLEFT JOIN \n    COURSE_CATALOG_SUBJECT_OFFERED ccso2 ON ccso.FALL_INSTRUCTORS = ccso2.FALL_INSTRUCTORS\nWHERE \n    ccso.TERM_CODE = '2023FA'\nGROUP BY \n    at.TERM_DESCRIPTION, \n    ccso.SUBJECT_TITLE, \n    ccso.PREREQUISITES, \n    ccso.FALL_INSTRUCTORS;"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the assignable floor area and building.",
        "predicted_sql": "SELECT \n    FR.ROOM_FULL_NAME,\n    FB.BUILDING_NAME,\n    FF.FLOOR,\n    FO.ORGANIZATION_NAME,\n    FO.HR_DEPARTMENT_NAME,\n    FR.AREA,\n    FF.ASSIGNABLE_AREA,\n    FB.ASSIGNABLE_AREA AS BUILDING_ASSIGNABLE_AREA,\n    (FR.AREA / FF.ASSIGNABLE_AREA) * 100 AS PERCENTAGE_OF_FLOOR_AREA,\n    (FR.AREA / FB.ASSIGNABLE_AREA) * 100 AS PERCENTAGE_OF_BUILDING_AREA\nFROM \n    FAC_ROOMS FR\nJOIN \n    FAC_BUILDING FB ON FR.BUILDING_KEY = FB.FAC_BUILDING_KEY\nJOIN \n    FAC_FLOOR FF ON FR.FLOOR_KEY = FF.FLOOR_KEY\nJOIN \n    FAC_ORGANIZATION FO ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the floor area and building.",
        "predicted_sql": "SELECT \n    FR.ROOM_FULL_NAME,\n    FB.BUILDING_NAME_LONG AS BUILDING_NAME,\n    FF.FLOOR,\n    FO.ORGANIZATION_NAME,\n    FO.HR_DEPARTMENT_NAME,\n    FR.AREA / FF.EXT_GROSS_AREA * 100 AS PERCENTAGE_ROOM_AREA_OVER_FLOOR,\n    FR.AREA / FB.EXT_GROSS_AREA * 100 AS PERCENTAGE_ROOM_AREA_OVER_BUILDING\nFROM \n    FAC_ROOMS FR\nJOIN \n    FAC_BUILDING FB ON FR.BUILDING_KEY = FB.FAC_BUILDING_KEY\nJOIN \n    FAC_FLOOR FF ON FR.FLOOR_KEY = FF.FLOOR_KEY\nJOIN \n    FAC_ORGANIZATION FO ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY;"
    },
    {
        "db_id": "dw",
        "question": "What are the academic year, and instructors names for courses offered in the academic year 2022, along with the total number of types of courses per instructor?",
        "predicted_sql": "SELECT \n    a.ACADEMIC_YEAR, \n    e.FULL_NAME AS instructor_name, \n    COUNT(DISTINCT s.COURSE_NUMBER) AS total_course_types\nFROM \n    SUBJECT_OFFERED s\nJOIN \n    ACADEMIC_TERMS_ALL a ON s.TERM_CODE = a.TERM_CODE\nJOIN \n    EMPLOYEE_DIRECTORY e ON s.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nWHERE \n    a.ACADEMIC_YEAR = '2022'\nGROUP BY \n    a.ACADEMIC_YEAR, e.FULL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What are the building names, department names, organizations, their highest and lowest floor number, along with the total number of rooms per each building key?",
        "predicted_sql": "SELECT \n    fb.BUILDING_NAME_LONG AS building_name,\n    fo.HR_DEPARTMENT_NAME AS department_name,\n    fo.ORGANIZATION AS organization,\n    MIN(ff.LEVEL_ID) AS lowest_floor_number,\n    MAX(ff.LEVEL_ID) AS highest_floor_number,\n    COUNT(DISTINCT fr.FAC_ROOM_KEY) AS total_rooms\nFROM \n    FAC_BUILDING fb\nJOIN \n    FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY\nJOIN \n    FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY\nJOIN \n    FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY\nGROUP BY \n    fb.FAC_BUILDING_KEY, fb.BUILDING_NAME_LONG, fo.HR_DEPARTMENT_NAME, fo.ORGANIZATION;"
    },
    {
        "db_id": "dw",
        "question": "Provide the complete information for students with the first name Kevin, including their full names, email addresses, department names, department phone numbers, school names, and the total student count per department and school. If a student is associated with more than one department, list a separate row for each department.",
        "predicted_sql": "SELECT \n    sd.FULL_NAME,\n    sd.EMAIL_ADDRESS,\n    d.DEPARTMENT_NAME,\n    ad.DEPARTMENT_PHONE_NUMBER,\n    d.SCHOOL_NAME,\n    COUNT(sd.EMAIL_ADDRESS) OVER (PARTITION BY sd.DEPARTMENT) AS STUDENT_COUNT_PER_DEPARTMENT,\n    COUNT(sd.EMAIL_ADDRESS) OVER (PARTITION BY d.SCHOOL_CODE) AS STUDENT_COUNT_PER_SCHOOL\nFROM \n    MIT_STUDENT_DIRECTORY sd\nJOIN \n    SIS_DEPARTMENT d ON sd.DEPARTMENT = d.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT ad ON d.DEPARTMENT_CODE = ad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    sd.FIRST_NAME = 'Kevin';"
    },
    {
        "db_id": "dw",
        "question": "What are the unique titles of subjects offered in the fall term along with their instructor names, instructor emails, and the total number of types of subjects per instructor?",
        "predicted_sql": "SELECT DISTINCT \n    c.SUBJECT_TITLE, \n    e.FULL_NAME AS INSTRUCTOR_NAME, \n    e.EMAIL_ADDRESS AS INSTRUCTOR_EMAIL,\n    COUNT(DISTINCT c.SUBJECT_ID) AS TOTAL_SUBJECT_TYPES\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nWHERE \n    c.IS_OFFERED_FALL_TERM = 'Y'\nGROUP BY \n    c.SUBJECT_TITLE, e.FULL_NAME, e.EMAIL_ADDRESS;"
    },
    {
        "db_id": "dw",
        "question": "List the building names, names of HR departments occupying them, the total gross square footage, the total and average assignable square footage, and the built year per building key.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME,\n    fo.HR_DEPARTMENT_NAME,\n    b.BLDG_GROSS_SQUARE_FOOTAGE,\n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE,\n    b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE / COUNT(DISTINCT fr.FAC_ROOM_KEY) AS AVG_ASSIGNABLE_SQUARE_FOOTAGE,\n    fb.DATE_BUILT,\n    b.BUILDING_KEY\nFROM \n    BUILDINGS b\nJOIN \n    FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY\nJOIN \n    FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY\nJOIN \n    FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY\nGROUP BY \n    b.BUILDING_KEY, b.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, b.BLDG_GROSS_SQUARE_FOOTAGE, b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE, fb.DATE_BUILT;"
    },
    {
        "db_id": "dw",
        "question": "Retrieve the titles of subjects offered in the summer term along with their descriptions, responsible faculty names, email address, building name, room name, floor level, building street address, and the total number of types of courses per departmnet.",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE,\n    c.SUBJECT_DESCRIPTION,\n    c.RESPONSIBLE_FACULTY_NAME,\n    e.EMAIL_ADDRESS,\n    b.BUILDING_NAME,\n    r.ROOM_FULL_NAME,\n    f.LEVEL_ID AS FLOOR_LEVEL,\n    b.BUILDING_STREET_ADDRESS,\n    COUNT(DISTINCT c.SUBJECT_ID) AS TOTAL_COURSE_TYPES\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS a ON a.TERM_CODE = c.TERM_CODE\nJOIN \n    EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nJOIN \n    FAC_ROOMS r ON c.MEET_PLACE = r.FAC_ROOM_KEY\nJOIN \n    FAC_FLOOR f ON r.FLOOR_KEY = f.FLOOR_KEY\nJOIN \n    BUILDINGS b ON r.BUILDING_KEY = b.BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS ba ON r.BUILDING_KEY = ba.BUILDING_KEY\nWHERE \n    a.TERM_CODE LIKE '%SU%' \n    AND ba.ADDRESS_PURPOSE = 'STREET'\nGROUP BY \n    c.SUBJECT_TITLE, \n    c.SUBJECT_DESCRIPTION, \n    c.RESPONSIBLE_FACULTY_NAME, \n    e.EMAIL_ADDRESS, \n    b.BUILDING_NAME, \n    r.ROOM_FULL_NAME, \n    f.LEVEL_ID, \n    b.BUILDING_STREET_ADDRESS"
    },
    {
        "db_id": "dw",
        "question": "For each term code, list the term description, attribute desciption, department name, school name, and the number of subjects in the area of humanities, arts and social sciences.",
        "predicted_sql": "SELECT \n    a.TERM_CODE,\n    a.TERM_DESCRIPTION,\n    c.HASS_ATTRIBUTE_DESC AS ATTRIBUTE_DESCRIPTION,\n    d.DEPARTMENT_NAME,\n    d.SCHOOL_NAME,\n    COUNT(DISTINCT c.SUBJECT_ID) AS NUMBER_OF_SUBJECTS\nFROM \n    ACADEMIC_TERMS_ALL a\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED c ON a.TERM_CODE = c.TERM_CODE\nJOIN \n    CIS_HASS_ATTRIBUTE h ON c.HASS_ATTRIBUTE = h.HASS_ATTRIBUTE\nJOIN \n    SIS_DEPARTMENT d ON c.DEPARTMENT_CODE = d.DEPARTMENT_CODE\nWHERE \n    h.CIS_ATTRIBUTE_GROUP = 'H'\nGROUP BY \n    a.TERM_CODE, a.TERM_DESCRIPTION, c.HASS_ATTRIBUTE_DESC, d.DEPARTMENT_NAME, d.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List building names, their height, street address, city, state, postal code, their gross and assignable square footage, the smallest and largest floor level and the total area of all rooms for each building key.",
        "predicted_sql": "SELECT \n    fb.FAC_BUILDING_KEY AS building_key,\n    fb.BUILDING_NAME AS building_name,\n    fb.BUILDING_HEIGHT AS height,\n    b.BUILDING_STREET_ADDRESS AS street_address,\n    fba.CITY AS city,\n    fba.STATE AS state,\n    fba.POSTAL_CODE AS postal_code,\n    fb.EXT_GROSS_AREA AS gross_square_footage,\n    fb.ASSIGNABLE_AREA AS assignable_square_footage,\n    MIN(ff.LEVEL_ID) AS smallest_floor_level,\n    MAX(ff.LEVEL_ID) AS largest_floor_level,\n    SUM(CAST(fr.AREA AS DECIMAL(10,2))) AS total_room_area\nFROM \n    FAC_BUILDING fb\nJOIN \n    BUILDINGS b ON fb.FAC_BUILDING_KEY = b.BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS fba ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY AND fba.ADDRESS_PURPOSE = 'STREET'\nJOIN \n    FAC_FLOOR ff ON fb.FAC_BUILDING_KEY = ff.BUILDING_KEY\nJOIN \n    FAC_ROOMS fr ON ff.FLOOR_KEY = fr.FLOOR_KEY\nGROUP BY \n    fb.FAC_BUILDING_KEY, fb.BUILDING_NAME, fb.BUILDING_HEIGHT, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, fb.EXT_GROSS_AREA, fb.ASSIGNABLE_AREA;"
    },
    {
        "db_id": "dw",
        "question": "What is the category title, version, department name, school name, total number of courses for each course level, and the total number of degree-granting courses for each CIP category code?",
        "predicted_sql": "SELECT \n    CIP.CATEGORY_TITLE,\n    CIP.VERSION,\n    SIS_DEPARTMENT.DEPARTMENT_NAME,\n    SIS_DEPARTMENT.SCHOOL_NAME,\n    SIS_COURSE_DESCRIPTION.COURSE_LEVEL,\n    COUNT(SIS_COURSE_DESCRIPTION.COURSE) AS total_courses,\n    SUM(CASE WHEN SIS_COURSE_DESCRIPTION.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS total_degree_granting_courses\nFROM \n    SIS_COURSE_DESCRIPTION\nJOIN \n    CIP ON SIS_COURSE_DESCRIPTION.CIP_PROGRAM_CODE = CIP.PROGRAM_CODE\nJOIN \n    SIS_DEPARTMENT ON SIS_COURSE_DESCRIPTION.DEPARTMENT = SIS_DEPARTMENT.DEPARTMENT_CODE\nGROUP BY \n    CIP.CATEGORY_TITLE,\n    CIP.VERSION,\n    SIS_DEPARTMENT.DEPARTMENT_NAME,\n    SIS_DEPARTMENT.SCHOOL_NAME,\n    SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library materials, the minimum and maximum publication years, and the total number of materials status for each course name?",
        "predicted_sql": "SELECT \n    lci.COURSE_NAME,\n    COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS total_library_materials,\n    MIN(lrc.CATALOG_YEAR) AS min_publication_year,\n    MAX(lrc.CATALOG_YEAR) AS max_publication_year,\n    COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS total_materials_status\nFROM \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    lci.COURSE_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the total number of library reserve materials, the minimum and maximum publication years, and the total number of enrolled students for each course instructor?",
        "predicted_sql": "SELECT \n    lci.INSTRUCTOR_NAME,\n    COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS total_library_reserve_materials,\n    MIN(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS min_publication_year,\n    MAX(CAST(lrc.CATALOG_YEAR AS UNSIGNED)) AS max_publication_year,\n    SUM(lso.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\nFROM \n    LIBRARY_COURSE_INSTRUCTOR lci\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nGROUP BY \n    lci.INSTRUCTOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "What is the material status, term description, total number of courses and materials, occurences in departments and school, and the total number of instructors for each library material status code and term code?",
        "predicted_sql": "SELECT \n    lms.LIBRARY_MATERIAL_STATUS_CODE,\n    ata.TERM_DESCRIPTION,\n    COUNT(DISTINCT lso.COURSE_NUMBER) AS total_courses,\n    COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS total_materials,\n    COUNT(DISTINCT lso.OFFER_DEPT_CODE) AS total_departments,\n    COUNT(DISTINCT lso.OFFER_SCHOOL_NAME) AS total_schools,\n    COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS total_instructors\nFROM \n    LIBRARY_MATERIAL_STATUS lms\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lms.LIBRARY_MATERIAL_STATUS_KEY = lrmd.LIBRARY_MATERIAL_STATUS_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    ACADEMIC_TERMS_ALL ata ON lso.TERM_CODE = ata.TERM_CODE\nGROUP BY \n    lms.LIBRARY_MATERIAL_STATUS_CODE, ata.TERM_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "For building 36, list all space units, their floor and building name, building street address, their space usage, and the number of organizations and space units on the same building and floor.",
        "predicted_sql": "SELECT \n    SU.SPACE_UNIT,\n    SF.FLOOR,\n    B.BUILDING_NAME,\n    B.BUILDING_STREET_ADDRESS,\n    SUU.SPACE_USAGE,\n    COUNT(DISTINCT FO.FCLT_ORGANIZATION_KEY) AS NUMBER_OF_ORGANIZATIONS,\n    COUNT(DISTINCT SD.SPACE_UNIT_KEY) AS NUMBER_OF_SPACE_UNITS\nFROM \n    SPACE_DETAIL SD\nJOIN \n    SPACE_UNIT SU ON SD.SPACE_UNIT_KEY = SU.SPACE_UNIT_KEY\nJOIN \n    SPACE_USAGE SUU ON SD.SPACE_USAGE_KEY = SUU.SPACE_USAGE_KEY\nJOIN \n    SPACE_FLOOR SF ON SD.FLOOR_KEY = SF.FLOOR_KEY\nJOIN \n    BUILDINGS B ON SD.BUILDING_KEY = B.BUILDING_KEY\nJOIN \n    FCLT_BUILDING_ADDRESS FBA ON B.BUILDING_KEY = FBA.FCLT_BUILDING_KEY\nJOIN \n    FCLT_ORGANIZATION FO ON SU.FCLT_ORGANIZATION_KEY = FO.FCLT_ORGANIZATION_KEY\nWHERE \n    B.BUILDING_NUMBER = '36'\nGROUP BY \n    SU.SPACE_UNIT, SF.FLOOR, B.BUILDING_NAME, B.BUILDING_STREET_ADDRESS, SUU.SPACE_USAGE;"
    },
    {
        "db_id": "dw",
        "question": "For each distinct mailing list containing more than 1000 people and with a name starting with A (case insensitive), provide its name, whether it is a mailing list, whether it is a moira group, whether it is a NFS group, the owner of the mailing list, and the number of people in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    ml.IS_MOIRA_MAILING_LIST,\n    ml.IS_MOIRA_GROUP,\n    ml.IS_NFS_GROUP,\n    mlo.OWNER,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS number_of_people\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY\nWHERE \n    ml.IS_MOIRA_MAILING_LIST = 'Y'\n    AND ml.MOIRA_LIST_NAME LIKE 'A%'\nGROUP BY \n    ml.MOIRA_LIST_NAME, ml.IS_MOIRA_MAILING_LIST, ml.IS_MOIRA_GROUP, ml.IS_NFS_GROUP, mlo.OWNER\nHAVING \n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) > 1000;"
    },
    {
        "db_id": "dw",
        "question": "List the mailing lists with the largest number of members and the least number of members, including their names, owners, public status, hidden status, and number of members in the list. If a mailing list has multiple owners, create a separate entry for each owner. Similarly, if multiple lists share the minimum or maximum member count, include all those lists.",
        "predicted_sql": "WITH MemberCounts AS (\n    SELECT \n        mld.MOIRA_LIST_KEY,\n        COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS member_count\n    FROM \n        MOIRA_LIST_DETAIL mld\n    GROUP BY \n        mld.MOIRA_LIST_KEY\n),\nMinMaxCounts AS (\n    SELECT \n        MIN(member_count) AS min_count,\n        MAX(member_count) AS max_count\n    FROM \n        MemberCounts\n),\nTargetLists AS (\n    SELECT \n        mc.MOIRA_LIST_KEY,\n        mc.member_count\n    FROM \n        MemberCounts mc\n    JOIN \n        MinMaxCounts mmc ON mc.member_count = mmc.min_count OR mc.member_count = mmc.max_count\n)\nSELECT \n    ml.MOIRA_LIST_NAME,\n    mlo.OWNER,\n    ml.IS_PUBLIC,\n    ml.IS_HIDDEN,\n    tl.member_count\nFROM \n    TargetLists tl\nJOIN \n    MOIRA_LIST ml ON tl.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_DETAIL mld ON tl.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY\nORDER BY \n    tl.member_count DESC, ml.MOIRA_LIST_NAME, mlo.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with C (case insensitive) and containing faculty who teach courses in the summer in financial aid years after 2001, provide the name of the list, the number of people in the list, and the number of faculty in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(mld.MOIRA_LIST_MEMBER) AS total_people,\n    COUNT(DISTINCT ed.MIT_ID) AS total_faculty\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nLEFT JOIN \n    EMPLOYEE_DIRECTORY ed ON mld.MOIRA_LIST_MEMBER_MIT_ID = ed.MIT_ID\nLEFT JOIN \n    COURSE_CATALOG_SUBJECT_OFFERED ccso ON ed.MIT_ID = ccso.RESPONSIBLE_FACULTY_MIT_ID\nLEFT JOIN \n    ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE\nWHERE \n    ml.MOIRA_LIST_NAME LIKE 'C%' \n    AND at.FINANCIAL_AID_YEAR > '2001'\n    AND at.IS_OFFERED_SUMMER_TERM = 'Y'\nGROUP BY \n    ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Regarding the mailing list about duo users, provide the number of students in this list, and the number of departments and schools associated with these students.",
        "predicted_sql": "SELECT \n    COUNT(DISTINCT msd.FULL_NAME) AS number_of_students,\n    COUNT(DISTINCT msd.DEPARTMENT) AS number_of_departments,\n    COUNT(DISTINCT sd.SCHOOL_CODE) AS number_of_schools\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    MIT_STUDENT_DIRECTORY msd ON mld.MOIRA_LIST_MEMBER_MIT_ID = msd.FULL_NAME\nJOIN \n    SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nWHERE \n    ml.MOIRA_LIST_NAME LIKE '%duo-users%'\n    AND msd.STUDENT_YEAR = 'G'\n    AND msd.DEPARTMENT IS NOT NULL;"
    },
    {
        "db_id": "dw",
        "question": "For faculty who are responsible for courses in 2023 fall term, list the name of mailing lists with ten members that they subscribe to, the number of faculty in these lists, and the number of courses associated with those faculty.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(DISTINCT ed.MIT_ID) AS number_of_faculty,\n    COUNT(DISTINCT c.SUBJECT_TITLE) AS number_of_courses\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    EMPLOYEE_DIRECTORY ed ON c.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID\nJOIN \n    MOIRA_LIST_DETAIL mld ON ed.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN \n    MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nWHERE \n    c.TERM_CODE = '2023FA'\nGROUP BY \n    ml.MOIRA_LIST_NAME\nHAVING \n    COUNT(mld.MOIRA_LIST_MEMBER) = 10;"
    },
    {
        "db_id": "dw",
        "question": "For each course instructor in the 'keeper-zephyr' mailing list, provide the name of mailing lists they subscribe to, instructor name, earliest and latest publication years, and total number of enrolled students.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME AS mailing_list_name,\n    lci.INSTRUCTOR_NAME,\n    MIN(lrc.CATALOG_YEAR) AS earliest_publication_year,\n    MAX(lrc.CATALOG_YEAR) AS latest_publication_year,\n    SUM(lso.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER_MIT_ID = sp.MIT_ID\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR lci ON sp.FULL_NAME = lci.INSTRUCTOR_NAME\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nWHERE \n    ml.MOIRA_LIST_NAME = 'keeper-zephyr'\nGROUP BY \n    ml.MOIRA_LIST_NAME, lci.INSTRUCTOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list with a name beginning with R (case insensitive), and that Professor Ayden Hopkins is subscribed to, list its name, description, owner, number of people in the list, and number of tenured faculty in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    ml.MOIRA_LIST_DESCRIPTION,\n    mlo.OWNER,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS number_of_people,\n    COUNT(DISTINCT CASE WHEN sp.PAYROLL_RANK = 'Faculty Tenured' THEN mld.MOIRA_LIST_MEMBER END) AS number_of_tenured_faculty\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER_MIT_ID = sp.MIT_ID\nWHERE \n    ml.IS_MOIRA_MAILING_LIST = 'Y'\n    AND ml.MOIRA_LIST_NAME LIKE 'R%'\n    AND sp.FULL_NAME = 'Hopkins, Ayden'\nGROUP BY \n    ml.MOIRA_LIST_NAME, ml.MOIRA_LIST_DESCRIPTION, mlo.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For the email list with name 'date-destiny', list the name of the list, department name, the number of students from the Management department, and the percentage of students who are from the Management department, rounded to two decimal places.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    sad.SIS_ADMIN_DEPARTMENT_NAME,\n    COUNT(DISTINCT msd.FULL_NAME) AS number_of_students,\n    ROUND(COUNT(DISTINCT CASE WHEN sad.SIS_ADMIN_DEPARTMENT_NAME = 'Management' THEN msd.FULL_NAME END) / COUNT(DISTINCT msd.FULL_NAME) * 100, 2) AS percentage_of_management_students\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN \n    MIT_STUDENT_DIRECTORY msd ON sp.FULL_NAME = msd.FULL_NAME\nJOIN \n    SIS_ADMIN_DEPARTMENT sad ON msd.DEPARTMENT = sad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    ml.MOIRA_LIST_NAME = 'date-destiny'\nGROUP BY \n    ml.MOIRA_LIST_NAME, sad.SIS_ADMIN_DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For the building with the most floors, list the building name and the names of the mailing lists staring with a (case insensitive) that the building employees with kerberos starting with c (case insensitive) subscribe to.",
        "predicted_sql": "SELECT \n    fb.BUILDING_NAME_LONG, \n    ml.MOIRA_LIST_NAME\nFROM \n    FAC_BUILDING fb\nJOIN \n    FAC_FLOOR ff ON fb.FAC_BUILDING_KEY = ff.BUILDING_KEY\nJOIN \n    FAC_ROOMS fr ON ff.FLOOR_KEY = fr.FLOOR_KEY\nJOIN \n    EMPLOYEE_DIRECTORY ed ON fr.FAC_ROOM_KEY = ed.OFFICE_LOCATION\nJOIN \n    MOIRA_LIST_DETAIL mld ON ed.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN \n    MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nWHERE \n    fb.FAC_BUILDING_KEY = (\n        SELECT \n            ff.BUILDING_KEY\n        FROM \n            FAC_FLOOR ff\n        GROUP BY \n            ff.BUILDING_KEY\n        ORDER BY \n            COUNT(DISTINCT ff.LEVEL_ID) DESC\n        LIMIT 1\n    )\n    AND ml.MOIRA_LIST_NAME LIKE 'a%'\n    AND ed.KRB_NAME LIKE 'c%'"
    },
    {
        "db_id": "dw",
        "question": "For the email lists subscribed by faculty members with last names begin with Y, list the names of the lists, the total number of subjects managed by faculty in those mailing lists, and the number of such faculty in the lists.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(DISTINCT c.SUBJECT_ID) AS total_subjects,\n    COUNT(DISTINCT ed.MIT_ID) AS number_of_faculty\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    EMPLOYEE_DIRECTORY ed ON mld.MOIRA_LIST_MEMBER_MIT_ID = ed.MIT_ID\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED c ON ed.MIT_ID = c.RESPONSIBLE_FACULTY_MIT_ID\nWHERE \n    ed.LAST_NAME LIKE 'Y%'\nGROUP BY \n    ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with H who are subscribed to mailing list 'beacon-date-date', list the names of the students, the phone numbers of departments they belong to, and the size of the mailing list 'beacon-date-date' that they are subscribed to.",
        "predicted_sql": "SELECT \n    msd.FULL_NAME AS student_name,\n    sad.DEPARTMENT_PHONE_NUMBER AS department_phone_number,\n    COUNT(mld.MOIRA_LIST_MEMBER) AS mailing_list_size\nFROM \n    MIT_STUDENT_DIRECTORY msd\nJOIN \n    SE_PERSON sp ON msd.FULL_NAME = sp.FULL_NAME\nJOIN \n    MOIRA_LIST_DETAIL mld ON sp.KRB_NAME = mld.MOIRA_LIST_MEMBER\nJOIN \n    MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nJOIN \n    SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    msd.LAST_NAME LIKE 'H%' \n    AND ml.MOIRA_LIST_NAME = 'beacon-date-date'\nGROUP BY \n    msd.FULL_NAME, sad.DEPARTMENT_PHONE_NUMBER;"
    },
    {
        "db_id": "dw",
        "question": "Give the count of mailing lists with names starting with B that include members from the Electrical Engineering and Computer Science department, along with the name of the list starting with B that have the highest number of members from that department and the corresponding member count.",
        "predicted_sql": "SELECT \n    COUNT(DISTINCT ml.MOIRA_LIST_NAME) AS mailing_list_count,\n    ml.MOIRA_LIST_NAME AS list_with_max_members,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS max_member_count\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nWHERE \n    ml.IS_MOIRA_MAILING_LIST = 'Y'\n    AND ml.MOIRA_LIST_NAME LIKE 'B%'\n    AND sp.ORGANIZATION = 'Electrical Engineering-Computer Science'\nGROUP BY \n    ml.MOIRA_LIST_NAME\nORDER BY \n    max_member_count DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For the 'kangaroo-inspire-yearn' email list, for each department present in the list, list the department name, the number of students in that department, and its percentage relative to the students in the mailing list.",
        "predicted_sql": "SELECT \n    sad.SIS_ADMIN_DEPARTMENT_NAME AS department_name,\n    COUNT(msd.FULL_NAME) AS number_of_students,\n    (COUNT(msd.FULL_NAME) / total_students.total_count) * 100 AS percentage_of_students\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN \n    MIT_STUDENT_DIRECTORY msd ON sp.FULL_NAME = msd.FULL_NAME\nJOIN \n    SIS_ADMIN_DEPARTMENT sad ON msd.DEPARTMENT = sad.SIS_ADMIN_DEPARTMENT_CODE\nJOIN \n    (SELECT COUNT(msd.FULL_NAME) AS total_count\n     FROM MOIRA_LIST ml\n     JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n     JOIN SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\n     JOIN MIT_STUDENT_DIRECTORY msd ON sp.FULL_NAME = msd.FULL_NAME\n     WHERE ml.MOIRA_LIST_NAME = 'kangaroo-inspire-yearn') total_students\nWHERE \n    ml.MOIRA_LIST_NAME = 'kangaroo-inspire-yearn'\nGROUP BY \n    sad.SIS_ADMIN_DEPARTMENT_NAME, total_students.total_count;"
    },
    {
        "db_id": "dw",
        "question": "Among the mailing lists subscribed by people with physical offices in building 24, provide the name of the most subscribed mailing list and the total number of subscribers.",
        "predicted_sql": "SELECT \n    m.MOIRA_LIST_NAME, \n    COUNT(DISTINCT md.MOIRA_LIST_MEMBER) AS total_subscribers\nFROM \n    MOIRA_LIST m\nJOIN \n    MOIRA_LIST_DETAIL md ON m.MOIRA_LIST_KEY = md.MOIRA_LIST_KEY\nJOIN \n    EMPLOYEE_DIRECTORY ed ON ed.KRB_NAME = md.MOIRA_LIST_MEMBER\nWHERE \n    ed.OFFICE_LOCATION LIKE '24%' \n    AND m.IS_MOIRA_MAILING_LIST = 'Y'\nGROUP BY \n    m.MOIRA_LIST_NAME\nORDER BY \n    total_subscribers DESC\nLIMIT 1;"
    },
    {
        "db_id": "dw",
        "question": "For email lists subscribed by either support staff or faculty, list its name, the number of subscribers that are support staff, the number of subscribers that are faculty, as well as its active status.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    SUM(CASE WHEN sp.EMPLOYEE_TYPE = 'Support Staff' THEN 1 ELSE 0 END) AS support_staff_count,\n    SUM(CASE WHEN sp.EMPLOYEE_TYPE = 'Faculty' THEN 1 ELSE 0 END) AS faculty_count,\n    ml.IS_ACTIVE\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER_MIT_ID = sp.MIT_ID\nWHERE \n    sp.EMPLOYEE_TYPE IN ('Support Staff', 'Faculty')\nGROUP BY \n    ml.MOIRA_LIST_NAME, ml.IS_ACTIVE;"
    },
    {
        "db_id": "dw",
        "question": "For the 'ocean-apple' mailing list, identify the department with the highest student count. Provide the department name, phone number, and the total number of students subscribed to the mailing list from that department. If multiple departments have the same highest count, list each one separately.",
        "predicted_sql": "SELECT \n    sis_dept.SIS_ADMIN_DEPARTMENT_NAME AS department_name,\n    sis_dept.DEPARTMENT_PHONE_NUMBER AS phone_number,\n    COUNT(DISTINCT mit_student.FULL_NAME) AS student_count\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\nJOIN \n    MIT_STUDENT_DIRECTORY mit_student ON sp.FULL_NAME = mit_student.FULL_NAME\nJOIN \n    SIS_ADMIN_DEPARTMENT sis_dept ON mit_student.DEPARTMENT = sis_dept.SIS_ADMIN_DEPARTMENT_CODE\nWHERE \n    ml.MOIRA_LIST_NAME = 'ocean-apple'\nGROUP BY \n    sis_dept.SIS_ADMIN_DEPARTMENT_NAME, sis_dept.DEPARTMENT_PHONE_NUMBER\nHAVING \n    student_count = (\n        SELECT \n            MAX(student_count)\n        FROM (\n            SELECT \n                COUNT(DISTINCT mit_student.FULL_NAME) AS student_count\n            FROM \n                MOIRA_LIST ml\n            JOIN \n                MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\n            JOIN \n                SE_PERSON sp ON mld.MOIRA_LIST_MEMBER = sp.KRB_NAME\n            JOIN \n                MIT_STUDENT_DIRECTORY mit_student ON sp.FULL_NAME = mit_student.FULL_NAME\n            JOIN \n                SIS_ADMIN_DEPARTMENT sis_dept ON mit_student.DEPARTMENT = sis_dept.SIS_ADMIN_DEPARTMENT_CODE\n            WHERE \n                ml.MOIRA_LIST_NAME = 'ocean-apple'\n            GROUP BY \n                sis_dept.SIS_ADMIN_DEPARTMENT_NAME, sis_dept.DEPARTMENT_PHONE_NUMBER\n        ) AS dept_counts\n    );"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list, list its owner, owner type, the member visibility ('Public Members' if public, and 'Hidden Members' otherwise), and the number of members of this type of visibility. For each owner and owner type, include a grand total for all members in the format of (owner, owner type, null, total members).",
        "predicted_sql": "SELECT \n    o.OWNER,\n    o.OWNER_TYPE,\n    CASE \n        WHEN l.IS_PUBLIC = 'Y' THEN 'Public Members'\n        ELSE 'Hidden Members'\n    END AS member_visibility,\n    COUNT(d.MOIRA_LIST_MEMBER) AS number_of_members\nFROM \n    MOIRA_LIST l\nJOIN \n    MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER o ON d.MOIRA_LIST_OWNER_KEY = o.MOIRA_LIST_OWNER_KEY\nGROUP BY \n    o.OWNER, o.OWNER_TYPE, member_visibility\n\nUNION ALL\n\nSELECT \n    o.OWNER,\n    o.OWNER_TYPE,\n    NULL AS member_visibility,\n    COUNT(d.MOIRA_LIST_MEMBER) AS total_members\nFROM \n    MOIRA_LIST l\nJOIN \n    MOIRA_LIST_DETAIL d ON l.MOIRA_LIST_KEY = d.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER o ON d.MOIRA_LIST_OWNER_KEY = o.MOIRA_LIST_OWNER_KEY\nGROUP BY \n    o.OWNER, o.OWNER_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "Group biology courses by cluster type and course level. For each group, list the name of the department, the course title, cluster type, total enrollments, average enrollment within its cluster, course level, number of unique course materials, average new and used prices for TIP materials, total material record count for TIP materials, number of unique library titles, and number of unique library ISBNs.",
        "predicted_sql": "SELECT \n    sos.OFFER_DEPT_NAME AS department_name,\n    sos.SUBJECT_TITLE AS course_title,\n    sos.CLUSTER_TYPE AS cluster_type,\n    SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollments,\n    AVG(sos.NUM_ENROLLED_STUDENTS) AS average_enrollment_within_cluster,\n    scd.COURSE_LEVEL AS course_level,\n    COUNT(DISTINCT tm.TITLE) AS unique_course_materials,\n    AVG(tm.NEW_SHELF_PRICE) AS average_new_price,\n    AVG(tm.USED_SHELF_PRICE) AS average_used_price,\n    SUM(td.RECORD_COUNT) AS total_material_record_count,\n    COUNT(DISTINCT lrc.CATALOG_TITLE) AS unique_library_titles,\n    COUNT(DISTINCT lrc.CATALOG_ISBN) AS unique_library_isbns\nFROM \n    SUBJECT_OFFERED_SUMMARY sos\nJOIN \n    SIS_COURSE_DESCRIPTION scd ON sos.COURSE_NUMBER = scd.COURSE\nLEFT JOIN \n    TIP_DETAIL td ON sos.SUBJECT_ID = td.SUBJECT_ID\nLEFT JOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_CATALOG lrc ON sos.SUBJECT_ID = lrc.CATALOG_SYSTEM_NUMBER\nWHERE \n    sos.OFFER_DEPT_NAME = 'Biology'\nGROUP BY \n    sos.OFFER_DEPT_NAME, sos.SUBJECT_TITLE, sos.CLUSTER_TYPE, scd.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered this year in either the Fall or Spring term, list its department name, school name, subject ID, subject title, course level, total units, the term it is offered ('Spring' for Spring term and 'Fall' for Fall term), term description, the number of distinct instructors teaching in the Fall, and the number of distinct instructors teaching in the Spring.",
        "predicted_sql": "SELECT \n    c.DEPARTMENT_NAME,\n    d.SCHOOL_NAME,\n    c.SUBJECT_ID,\n    c.SUBJECT_TITLE,\n    s.COURSE_LEVEL,\n    c.TOTAL_UNITS,\n    CASE \n        WHEN c.IS_OFFERED_FALL_TERM = 'Y' THEN 'Fall'\n        WHEN c.IS_OFFERED_SPRING_TERM = 'Y' THEN 'Spring'\n    END AS TERM_OFFERED,\n    a.TERM_DESCRIPTION,\n    COUNT(DISTINCT c.FALL_INSTRUCTORS) AS NUM_FALL_INSTRUCTORS,\n    COUNT(DISTINCT c.SPRING_INSTRUCTORS) AS NUM_SPRING_INSTRUCTORS\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS a ON c.TERM_CODE = a.TERM_CODE\nJOIN \n    SIS_DEPARTMENT d ON c.DEPARTMENT_CODE = d.DEPARTMENT_CODE\nJOIN \n    SIS_COURSE_DESCRIPTION s ON s.COURSE = c.SUBJECT_CODE\nWHERE \n    c.IS_OFFERED_THIS_YEAR = 'Y'\n    AND (c.IS_OFFERED_FALL_TERM = 'Y' OR c.IS_OFFERED_SPRING_TERM = 'Y')\nGROUP BY \n    c.DEPARTMENT_NAME, d.SCHOOL_NAME, c.SUBJECT_ID, c.SUBJECT_TITLE, s.COURSE_LEVEL, c.TOTAL_UNITS, TERM_OFFERED, a.TERM_DESCRIPTION;"
    },
    {
        "db_id": "dw",
        "question": "For Political Science courses with HASS attributes, for each attribute, list the name and description of the attribute, the number of unique subjects, average units, the total enrollment, the number of departments that grant degrees, and the subject code description.",
        "predicted_sql": "SELECT \n    c.HASS_ATTRIBUTE AS attribute_name,\n    c.HASS_ATTRIBUTE_DESC AS attribute_description,\n    COUNT(DISTINCT c.SUBJECT_ID) AS number_of_unique_subjects,\n    AVG(c.TOTAL_UNITS) AS average_units,\n    SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollment,\n    COUNT(DISTINCT CASE WHEN d.IS_DEGREE_GRANTING = 'Y' THEN d.DEPARTMENT_CODE END) AS number_of_degree_granting_departments,\n    sc.SUBJECT_CODE_DESC AS subject_code_description\nFROM \n    CIS_COURSE_CATALOG c\nJOIN \n    SUBJECT_OFFERED_SUMMARY sos ON c.SUBJECT_ID = sos.SUBJECT_ID\nJOIN \n    SIS_SUBJECT_CODE sc ON c.SUBJECT_CODE = sc.SUBJECT_CODE\nJOIN \n    SIS_DEPARTMENT d ON sc.DEPARTMENT_CODE = d.DEPARTMENT_CODE\nWHERE \n    d.DEPARTMENT_NAME = 'Political Science'\nGROUP BY \n    c.HASS_ATTRIBUTE, c.HASS_ATTRIBUTE_DESC, sc.SUBJECT_CODE_DESC;"
    },
    {
        "db_id": "dw",
        "question": "Group subjects by cluster type, department offering the subject, and the school name. For each group, list the cluster type, name of the department, school name, whether the department grants degrees, total number of subjects, total enrollment, and average enrollment. Exclude clusters or schools with no student data.",
        "predicted_sql": "SELECT \n    sos.CLUSTER_TYPE,\n    sos.OFFER_DEPT_NAME,\n    sd.SCHOOL_NAME,\n    sd.IS_DEGREE_GRANTING,\n    COUNT(DISTINCT sos.SUBJECT_ID) AS total_subjects,\n    SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollment,\n    AVG(sos.NUM_ENROLLED_STUDENTS) AS average_enrollment\nFROM \n    SUBJECT_OFFERED_SUMMARY sos\nJOIN \n    SIS_DEPARTMENT sd ON sd.DEPARTMENT_CODE = sos.OFFER_DEPT_CODE\nWHERE \n    sos.NUM_ENROLLED_STUDENTS > 0\nGROUP BY \n    sos.CLUSTER_TYPE, sos.OFFER_DEPT_NAME, sd.SCHOOL_NAME, sd.IS_DEGREE_GRANTING\nHAVING \n    total_enrollment > 0;"
    },
    {
        "db_id": "dw",
        "question": "Group classes that take place in buildings at MIT by the building name and course level. For each group, provide the name of the building, the course level ('Graduate' or 'Undergraduate'), the total number of unique courses of such level, and total instructors for these courses. Include subtotals for each building and course level and a grand total across all buildings and course levels.",
        "predicted_sql": "SELECT \n    fb.BUILDING_NAME_LONG AS BuildingName,\n    CASE \n        WHEN scd.COURSE_LEVEL = 'G' THEN 'Graduate'\n        WHEN scd.COURSE_LEVEL = 'U' THEN 'Undergraduate'\n    END AS CourseLevel,\n    COUNT(DISTINCT so.COURSE_NUMBER) AS TotalUniqueCourses,\n    COUNT(DISTINCT so.RESPONSIBLE_FACULTY_NAME) AS TotalInstructors\nFROM \n    FAC_BUILDING fb\nJOIN \n    FAC_BUILDING_ADDRESS fba ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY\nJOIN \n    SUBJECT_OFFERED so ON fb.BUILDING_NAME_LONG = so.MEET_PLACE\nJOIN \n    SIS_COURSE_DESCRIPTION scd ON so.COURSE_NUMBER = scd.COURSE\nWHERE \n    fb.SITE = 'MIT'\nGROUP BY \n    fb.BUILDING_NAME_LONG, scd.COURSE_LEVEL WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each course, provide the room number of course location, building name, building number, building city, building state, area, organization name, room usage, term code, course level, the total number of subjects, unique meeting times, and total units. Do not include meet place or meet times with NULL values.",
        "predicted_sql": "SELECT \n    crs.MEET_PLACE AS room_number,\n    fb.BUILDING_NAME_LONG AS building_name,\n    fb.BUILDING_NUMBER AS building_number,\n    fba.CITY AS building_city,\n    fba.STATE AS building_state,\n    fr.AREA AS area,\n    fr.ORGANIZATION_NAME AS organization_name,\n    fmu.MAJOR_USE AS room_usage,\n    crs.TERM_CODE AS term_code,\n    scd.COURSE_LEVEL AS course_level,\n    COUNT(DISTINCT crs.SUBJECT_ID) AS total_subjects,\n    COUNT(DISTINCT crs.MEET_TIME) AS unique_meeting_times,\n    SUM(crs.TOTAL_UNITS) AS total_units\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED crs\nJOIN \n    FAC_ROOMS fr ON fr.FAC_ROOM_KEY = crs.MEET_PLACE\nJOIN \n    FAC_BUILDING fb ON fr.BUILDING_KEY = fb.FAC_BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS fba ON fba.BUILDING_KEY = fb.FAC_BUILDING_KEY\nJOIN \n    FAC_MAJOR_USE fmu ON fr.MAJOR_USE_KEY = fmu.MAJOR_USE_KEY\nJOIN \n    SIS_COURSE_DESCRIPTION scd ON scd.COURSE = crs.SUBJECT_ID\nWHERE \n    crs.MEET_PLACE IS NOT NULL\n    AND crs.MEET_TIME IS NOT NULL\nGROUP BY \n    crs.MEET_PLACE, fb.BUILDING_NAME_LONG, fb.BUILDING_NUMBER, fba.CITY, fba.STATE, \n    fr.AREA, fr.ORGANIZATION_NAME, fmu.MAJOR_USE, crs.TERM_CODE, scd.COURSE_LEVEL;"
    },
    {
        "db_id": "dw",
        "question": "Consider only books cataloged on or after 2000. For each library material status and department, list the material status, department name, number of associated catalog items, and the total number of enrolled students in courses using those materials. Include subtotals for each material status and a grand total across all status (the corresponding status field is 'Grand Total').",
        "predicted_sql": "SELECT \n    COALESCE(lms.LIBRARY_MATERIAL_STATUS, 'Grand Total') AS material_status,\n    COALESCE(ssc.DEPARTMENT_NAME, 'All Departments') AS department_name,\n    COUNT(DISTINCT lrc.LIBRARY_RESERVE_CATALOG_KEY) AS num_catalog_items,\n    SUM(so.NUM_ENROLLED_STUDENTS) AS total_enrolled_students\nFROM \n    LIBRARY_RESERVE_CATALOG lrc\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrd ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrd.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS lms ON lrd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED so ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = so.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    SIS_SUBJECT_CODE ssc ON so.COURSE_NUMBER = ssc.COURSE_NUMBER\nWHERE \n    lrc.CATALOG_YEAR >= '2000'\nGROUP BY \n    ROLLUP(lms.LIBRARY_MATERIAL_STATUS, ssc.DEPARTMENT_NAME)\nORDER BY \n    material_status, department_name;"
    },
    {
        "db_id": "dw",
        "question": "For each department in the library system, list the name of the department, total number of courses using library materials, the number of catalog items associated with those courses, and the average enrollment per course. Include a grand total across all departments (the corresponding department field should be 'Grand Total').",
        "predicted_sql": "SELECT \n    COALESCE(department, 'Grand Total') AS department,\n    COUNT(DISTINCT lci.COURSE_NAME) AS total_courses,\n    COUNT(DISTINCT lrc.LIBRARY_RESERVE_CATALOG_KEY) AS total_catalog_items,\n    AVG(lso.NUM_ENROLLED_STUDENTS) AS avg_enrollment\nFROM \n    LIBRARY_COURSE_INSTRUCTOR lci\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nGROUP BY \n    department WITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each department and school offering courses with materials, list the department name, school name, number of unique course materials, number of courses, average new and used shelf prices of materials, total material records, and number of distinct material statuses. Include a grand total across all schools and departments (the corresponding school and department fields should be null).",
        "predicted_sql": "SELECT \n    tso.OFFER_DEPT_NAME AS department_name,\n    sd.SCHOOL_NAME AS school_name,\n    COUNT(DISTINCT tm.TIP_MATERIAL_KEY) AS unique_course_materials,\n    COUNT(DISTINCT tso.SUBJECT_ID) AS number_of_courses,\n    AVG(tm.NEW_SHELF_PRICE) AS avg_new_shelf_price,\n    AVG(tm.USED_SHELF_PRICE) AS avg_used_shelf_price,\n    SUM(td.RECORD_COUNT) AS total_material_records,\n    COUNT(DISTINCT tms.TIP_MATERIAL_STATUS) AS distinct_material_statuses\nFROM \n    TIP_SUBJECT_OFFERED tso\nJOIN \n    TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nJOIN \n    TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nJOIN \n    SIS_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE\nWHERE \n    tso.IS_NO_COURSE_MATERIAL = 'N'\nGROUP BY \n    tso.OFFER_DEPT_NAME, sd.SCHOOL_NAME\nWITH ROLLUP;"
    },
    {
        "db_id": "dw",
        "question": "For each TIP material status, list the total number of unique materials associated with the status, the total number of records associated with the status, and the total student enrollment associated with the status. Any material status with null values should be displayed as 'No material status'. Additionally, include a grand total across all material status (the material status for this row should be displayed as 'Grand Total').",
        "predicted_sql": "SELECT \n    COALESCE(tms.TIP_MATERIAL_STATUS, 'No material status') AS material_status,\n    COUNT(DISTINCT tm.TIP_MATERIAL_KEY) AS unique_materials_count,\n    SUM(td.RECORD_COUNT) AS total_records_count,\n    SUM(tso.NUM_ENROLLED_STUDENTS) AS total_student_enrollment\nFROM \n    TIP_DETAIL td\nLEFT JOIN \n    TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nLEFT JOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN \n    TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nGROUP BY \n    tms.TIP_MATERIAL_STATUS\n\nUNION ALL\n\nSELECT \n    'Grand Total' AS material_status,\n    COUNT(DISTINCT tm.TIP_MATERIAL_KEY) AS unique_materials_count,\n    SUM(td.RECORD_COUNT) AS total_records_count,\n    SUM(tso.NUM_ENROLLED_STUDENTS) AS total_student_enrollment\nFROM \n    TIP_DETAIL td\nLEFT JOIN \n    TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY\nLEFT JOIN \n    TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY;"
    },
    {
        "db_id": "dw",
        "question": "For each room, list its associated building name, floor number, room number, ownership type, organization name, number of rooms, area, and percentage of area relative to the building. Include subtotals across floors, subtotals across all floors for each building, and a grand total across all buildings. For the subtotal for each building and the grand total, the percentage of area should be relative to area of all buildings. All numeric values should be rounded to integers and formatted using commas as thousands separators except the relative percentages which should be rounded to two decimal places.",
        "predicted_sql": "SELECT \n    r.BUILDING_ROOM AS room_number,\n    b.BUILDING_NAME_LONG AS building_name,\n    f.FLOOR AS floor_number,\n    b.OWNERSHIP_TYPE AS ownership_type,\n    o.ORGANIZATION_NAME AS organization_name,\n    COUNT(r.FCLT_ROOM_KEY) AS number_of_rooms,\n    ROUND(SUM(r.AREA), 0) AS area,\n    ROUND(SUM(r.AREA) / b.EXT_GROSS_AREA * 100, 2) AS percentage_of_area_relative_to_building\nFROM \n    FCLT_ROOMS r\nJOIN \n    FCLT_FLOOR f ON r.FCLT_FLOOR_KEY = f.FCLT_FLOOR_KEY\nJOIN \n    FCLT_BUILDING b ON f.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nJOIN \n    FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY\nGROUP BY \n    r.BUILDING_ROOM, b.BUILDING_NAME_LONG, f.FLOOR, b.OWNERSHIP_TYPE, o.ORGANIZATION_NAME, b.EXT_GROSS_AREA\nWITH ROLLUP\nHAVING \n    GROUPING(r.BUILDING_ROOM) = 0 OR GROUPING(f.FLOOR) = 1 OR GROUPING(b.BUILDING_NAME_LONG) = 1\nORDER BY \n    building_name, floor_number, room_number;"
    },
    {
        "db_id": "dw",
        "question": "For each financial aid year and academic year, list the number of fiscal periods, quarters, the start term date, the end term date, and number of distinct department-level term parameters.",
        "predicted_sql": "SELECT \n    at.FINANCIAL_AID_YEAR,\n    at.ACADEMIC_YEAR,\n    COUNT(DISTINCT tm.FISCAL_PERIOD) AS number_of_fiscal_periods,\n    COUNT(DISTINCT tq.FY_QUARTER_CODE) AS number_of_quarters,\n    MIN(td.START_DATE) AS start_term_date,\n    MAX(td.END_DATE) AS end_term_date,\n    COUNT(DISTINCT atp.TERM_PARAMETER) AS number_of_distinct_term_parameters\nFROM \n    ACADEMIC_TERMS at\nJOIN \n    TIME_DAY td ON at.TERM_START_DATE = td.CALENDAR_DATE\nJOIN \n    TIME_MONTH tm ON td.FISCAL_PERIOD = tm.FISCAL_PERIOD\nJOIN \n    TIME_QUARTER tq ON tm.FISCAL_YEAR = tq.FISCAL_YEAR\nJOIN \n    ACADEMIC_TERM_PARAMETER atp ON at.TERM_CODE = atp.TERM_CODE\nGROUP BY \n    at.FINANCIAL_AID_YEAR, at.ACADEMIC_YEAR;"
    },
    {
        "db_id": "dw",
        "question": "Group buildings by campus sectors. For each group, list the campus sector, name of the building, city and state where the building is located, total number of floors, total assignable area, total number of rooms, total number of organizations, ownership type, and a rank column indicating the order (1-indexed) of this row within each sector based on the descending order of assignable area. Include subtotals for each sector and a grand total across all sectors. The subtotal and grand total only need to computed over the total number of floors and assignable area.",
        "predicted_sql": "SELECT \n    CAMPUS_SECTOR,\n    BUILDING_NAME_LONG AS BUILDING_NAME,\n    CITY,\n    STATE,\n    COUNT(DISTINCT FCLT_FLOOR.FLOOR) AS TOTAL_FLOORS,\n    SUM(FCLT_BUILDING.ASSIGNABLE_AREA) AS TOTAL_ASSIGNABLE_AREA,\n    COUNT(DISTINCT FCLT_ROOMS.FCLT_ROOM_KEY) AS TOTAL_ROOMS,\n    COUNT(DISTINCT FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY) AS TOTAL_ORGANIZATIONS,\n    OWNERSHIP_TYPE,\n    RANK() OVER (PARTITION BY CAMPUS_SECTOR ORDER BY SUM(FCLT_BUILDING.ASSIGNABLE_AREA) DESC) AS RANK_WITHIN_SECTOR\nFROM \n    FCLT_BUILDING\nJOIN \n    FCLT_BUILDING_ADDRESS ON FCLT_BUILDING.FCLT_BUILDING_KEY = FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY\nJOIN \n    FCLT_FLOOR ON FCLT_BUILDING.FCLT_BUILDING_KEY = FCLT_FLOOR.FCLT_BUILDING_KEY\nJOIN \n    FCLT_ROOMS ON FCLT_BUILDING.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY\nJOIN \n    FCLT_ORGANIZATION ON FCLT_ROOMS.FCLT_ORGANIZATION_KEY = FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY\nGROUP BY \n    CAMPUS_SECTOR, BUILDING_NAME_LONG, CITY, STATE, OWNERSHIP_TYPE\nWITH ROLLUP\nHAVING \n    (CAMPUS_SECTOR IS NOT NULL AND BUILDING_NAME IS NOT NULL) OR (CAMPUS_SECTOR IS NULL AND BUILDING_NAME IS NULL)\nORDER BY \n    CAMPUS_SECTOR, RANK_WITHIN_SECTOR;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the name of the department, the title of the TIP material associated with the department, author, ISBN, library term code, and whether it is available in the library reserves ('Available in Library' if yes and 'Not Available in Library' otherwise), the total number of instructors per library book for the department, the total number of materials available in the library for the department, and the total number of available materials across all departments.",
        "predicted_sql": "SELECT \n    tso.OFFER_DEPT_NAME AS department_name,\n    tm.TITLE AS tip_material_title,\n    tm.AUTHOR AS author,\n    tm.ISBN AS isbn,\n    lrm.TERM_CODE AS library_term_code,\n    CASE \n        WHEN lrc.CATALOG_ISBN IS NOT NULL THEN 'Available in Library'\n        ELSE 'Not Available in Library'\n    END AS availability_in_library,\n    COUNT(DISTINCT lrm.LIBRARY_COURSE_INSTRUCTOR_KEY) AS total_instructors_per_book,\n    COUNT(DISTINCT lrm.LIBRARY_RESERVE_CATALOG_KEY) AS total_materials_in_library,\n    COUNT(DISTINCT tm.TIP_MATERIAL_KEY) AS total_available_materials\nFROM \n    TIP_MATERIAL tm\nJOIN \n    TIP_DETAIL td ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY\nJOIN \n    TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrm ON lrm.LIBRARY_RESERVE_CATALOG_KEY = tm.ISBN\nLEFT JOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrc.CATALOG_ISBN = tm.ISBN\nGROUP BY \n    tso.OFFER_DEPT_NAME, tm.TITLE, tm.AUTHOR, tm.ISBN, lrm.TERM_CODE, lrc.CATALOG_ISBN\nORDER BY \n    tso.OFFER_DEPT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department and material status, list the name of the department, the material status, the number of TIP materials associated with this department and status, the number of library materials associated with this department and status, the total number of TIP and library materials associated with this department and status. Include a subtotal for each department and a grand total across all departments.",
        "predicted_sql": "SELECT \n    tso.OFFER_DEPT_NAME AS department_name,\n    tms.TIP_MATERIAL_STATUS AS material_status,\n    COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS num_tip_materials,\n    COUNT(DISTINCT lrd.LIBRARY_RESERVE_CATALOG_KEY) AS num_library_materials,\n    COUNT(DISTINCT td.TIP_MATERIAL_KEY) + COUNT(DISTINCT lrd.LIBRARY_RESERVE_CATALOG_KEY) AS total_materials\nFROM \n    TIP_DETAIL td\nJOIN \n    TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY\nLEFT JOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrd ON tso.SUBJECT_ID = lrd.SUBJECT_ID\nLEFT JOIN \n    LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nLEFT JOIN \n    LIBRARY_MATERIAL_STATUS lms ON lrd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    tso.OFFER_DEPT_NAME, tms.TIP_MATERIAL_STATUS\nWITH ROLLUP\nHAVING \n    (tso.OFFER_DEPT_NAME IS NOT NULL OR tms.TIP_MATERIAL_STATUS IS NOT NULL)\nORDER BY \n    tso.OFFER_DEPT_NAME, tms.TIP_MATERIAL_STATUS;"
    },
    {
        "db_id": "dw",
        "question": "For each building that is not a subdivision, list the building number, full name, street address, building type, occupancy date, ownership type, and site location. You should also include three rows at the end showing the number of owned, leased, all buildings at MIT that are not subdivisions, in the format of (null, #building Buildings, null, null, null, null, null).",
        "predicted_sql": "SELECT \n    fb.BUILDING_NUMBER, \n    fb.BUILDING_NAME_LONG, \n    b.BUILDING_STREET_ADDRESS, \n    fb.BUILDING_TYPE, \n    fb.DATE_OCCUPIED, \n    fb.OWNERSHIP_TYPE, \n    fb.SITE\nFROM \n    FAC_BUILDING fb\nJOIN \n    FAC_BUILDING_ADDRESS fba ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY\nJOIN \n    BUILDINGS b ON b.BUILDING_KEY = fba.BUILDING_KEY\nWHERE \n    fb.PARENT_BUILDING_NUMBER IS NULL\n    AND fba.ADDRESS_PURPOSE = 'STREET'\nUNION ALL\nSELECT \n    NULL, \n    CONCAT(COUNT(CASE WHEN fb.OWNERSHIP_TYPE = 'OWNED' THEN 1 END), ' owned Buildings'), \n    NULL, \n    NULL, \n    NULL, \n    NULL, \n    NULL\nFROM \n    FAC_BUILDING fb\nWHERE \n    fb.PARENT_BUILDING_NUMBER IS NULL\n    AND fb.SITE = 'MIT'\nUNION ALL\nSELECT \n    NULL, \n    CONCAT(COUNT(CASE WHEN fb.OWNERSHIP_TYPE = 'LEASED' THEN 1 END), ' leased Buildings'), \n    NULL, \n    NULL, \n    NULL, \n    NULL, \n    NULL\nFROM \n    FAC_BUILDING fb\nWHERE \n    fb.PARENT_BUILDING_NUMBER IS NULL\n    AND fb.SITE = 'MIT'\nUNION ALL\nSELECT \n    NULL, \n    CONCAT(COUNT(*), ' Buildings'), \n    NULL, \n    NULL, \n    NULL, \n    NULL, \n    NULL\nFROM \n    FAC_BUILDING fb\nWHERE \n    fb.PARENT_BUILDING_NUMBER IS NULL\n    AND fb.SITE = 'MIT';"
    },
    {
        "db_id": "dw",
        "question": "For each owned building that is not a subdivision, list the construction start year, the building number, and the year of initial occupancy. Display the construction start year only if it differs from the previous row. If the year of initial occupancy or construction start year is unknown, display 'UNKNOWN'. You should also include a row at the end showing the total number of owned buildings that are not subdivisions, in the format of (null, #building Buildings, null).",
        "predicted_sql": "SELECT \n    CASE \n        WHEN DATE_BUILT IS NOT NULL THEN YEAR(STR_TO_DATE(DATE_BUILT, '%m/%d/%Y'))\n        ELSE 'UNKNOWN'\n    END AS construction_start_year,\n    BUILDING_NUMBER,\n    CASE \n        WHEN DATE_OCCUPIED IS NOT NULL THEN YEAR(STR_TO_DATE(DATE_OCCUPIED, '%m/%d/%Y'))\n        ELSE 'UNKNOWN'\n    END AS year_of_initial_occupancy\nFROM \n    FAC_BUILDING\nWHERE \n    OWNERSHIP_TYPE = 'OWNED'\n    AND PARENT_BUILDING_NUMBER IS NULL\nORDER BY \n    construction_start_year, BUILDING_NUMBER;\n\nUNION ALL\n\nSELECT \n    NULL,\n    CONCAT(COUNT(*), ' Buildings'),\n    NULL\nFROM \n    FAC_BUILDING\nWHERE \n    OWNERSHIP_TYPE = 'OWNED'\n    AND PARENT_BUILDING_NUMBER IS NULL;"
    },
    {
        "db_id": "dw",
        "question": "Group all buildings at MIT into either owned or leased. For each group, state the ownership type, usage type, number of buildings, gross square footage, number of rooms, and the number of associated organizations. Display the ownership type only if it differs from the previous row. Include subtotals for each group and a grand total across all groups. The subtotal and grand total rows should not include ownership type and usage type. Footage should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    CASE WHEN GROUPING(OWNERSHIP_TYPE) = 0 THEN OWNERSHIP_TYPE ELSE NULL END AS OWNERSHIP_TYPE,\n    CASE WHEN GROUPING(BUILDING_USE) = 0 THEN BUILDING_USE ELSE NULL END AS BUILDING_USE,\n    COUNT(DISTINCT FCLT_BUILDING_HIST.FCLT_BUILDING_KEY) AS NUMBER_OF_BUILDINGS,\n    FORMAT(ROUND(SUM(FCLT_BUILDING_HIST.EXT_GROSS_AREA)), 0) AS GROSS_SQUARE_FOOTAGE,\n    COUNT(DISTINCT FCLT_ROOMS.FCLT_ROOM_KEY) AS NUMBER_OF_ROOMS,\n    COUNT(DISTINCT FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY) AS NUMBER_OF_ORGANIZATIONS\nFROM \n    FCLT_BUILDING_HIST\nLEFT JOIN \n    FCLT_ROOMS ON FCLT_BUILDING_HIST.FCLT_BUILDING_KEY = FCLT_ROOMS.FCLT_BUILDING_KEY\nLEFT JOIN \n    FCLT_ORGANIZATION ON FCLT_ROOMS.FCLT_ORGANIZATION_KEY = FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY\nWHERE \n    FCLT_BUILDING_HIST.SITE = 'MIT'\nGROUP BY \n    OWNERSHIP_TYPE, BUILDING_USE WITH ROLLUP\nHAVING \n    GROUPING(OWNERSHIP_TYPE) = 0 OR GROUPING(BUILDING_USE) = 0\nORDER BY \n    OWNERSHIP_TYPE, BUILDING_USE;"
    },
    {
        "db_id": "dw",
        "question": "For each building use, list the type, the number of distinct buildings (excluding subdivisions) of this use, the total gross square footage of these buildings, and the number of unique organizations associated with the rooms in these buildings. If the building is used as a residence, display the usage type as \"RESIDENTIAL.\" You should also include a row at the end showing the total number of buildings, the gross square footage, and the number of organizations across all types of building use. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN b.BUILDING_USE = 'RESIDENT' THEN 'RESIDENTIAL'\n        ELSE b.BUILDING_USE\n    END AS BUILDING_USE,\n    b.BUILDING_TYPE,\n    COUNT(DISTINCT b.PARENT_BUILDING_NUMBER) AS NUM_BUILDINGS,\n    FORMAT(ROUND(SUM(b.EXT_GROSS_AREA)), 0) AS TOTAL_GROSS_AREA,\n    FORMAT(ROUND(COUNT(DISTINCT r.FCLT_ORGANIZATION_KEY)), 0) AS NUM_ORGANIZATIONS\nFROM \n    FCLT_BUILDING b\nJOIN \n    FCLT_ROOMS r ON b.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY\nGROUP BY \n    b.BUILDING_USE, b.BUILDING_TYPE\nWITH ROLLUP\nHAVING \n    (GROUPING(b.BUILDING_USE) = 0 AND GROUPING(b.BUILDING_TYPE) = 0) \n    OR (GROUPING(b.BUILDING_USE) = 1 AND GROUPING(b.BUILDING_TYPE) = 1);"
    },
    {
        "db_id": "dw",
        "question": "For each organization except Cambridge-MIT Institute, list its ID, number, level, formatted name according to level (if level is 2, there should be 1 space before the name, if level is 3, there should be 2 space before the name, up to level 6), whether it is assignable ('ASSIGNABLE' if assignable, 'NON-ASSIGNABLE' otherwise), total area, number of rooms, and average room area. Area and number of rooms should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    o.ORGANIZATION_ID AS ID,\n    o.ORGANIZATION_NUMBER AS number,\n    o.ORGANIZATION_LEVEL AS level,\n    CONCAT(REPEAT(' ', o.ORGANIZATION_LEVEL - 1), o.ORGANIZATION_NAME) AS formatted_name,\n    CASE \n        WHEN o.ASSIGNABLE = '1' THEN 'ASSIGNABLE'\n        ELSE 'NON-ASSIGNABLE'\n    END AS assignable,\n    FORMAT(ROUND(SUM(r.AREA)), 0) AS total_area,\n    FORMAT(COUNT(DISTINCT r.BUILDING_ROOM), 0) AS number_of_rooms,\n    FORMAT(ROUND(AVG(r.AREA)), 0) AS average_room_area\nFROM \n    FCLT_ORGANIZATION o\nJOIN \n    FCLT_ROOMS r ON o.FCLT_ORGANIZATION_KEY = r.FCLT_ORGANIZATION_KEY\nWHERE \n    o.ORGANIZATION_NAME != 'Cambridge-MIT Institute'\nGROUP BY \n    o.ORGANIZATION_ID, o.ORGANIZATION_NUMBER, o.ORGANIZATION_LEVEL, o.ORGANIZATION_NAME, o.ASSIGNABLE\nORDER BY \n    o.ORGANIZATION_ID;"
    },
    {
        "db_id": "dw",
        "question": "Group all rooms into whether or not they are assignable and the major use descriptions. For each group, state \"ASSIGNABLE\" if the room is assignable and \"NON-ASSIGNABLE\" otherwise, the major use description, the total number of rooms, total area, and average area. Include subtotals for each group and a grand total across all groups. The assignable status and major use descriptions should only be displayed when they differ from the previous row. Do not include rooms whose major use or major use description starts with 'ZUSE.' The results should be sorted by assignable status and major use description. The subtotal and grand total rows should not include assignable status or major use description.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN fm.ASSIGNABLE = '1' THEN 'ASSIGNABLE' \n        ELSE 'NON-ASSIGNABLE' \n    END AS ASSIGNABLE_STATUS,\n    fr.MAJOR_USE_DESC,\n    COUNT(fr.ROOM) AS TOTAL_ROOMS,\n    SUM(fr.AREA) AS TOTAL_AREA,\n    AVG(fr.AREA) AS AVERAGE_AREA\nFROM \n    FCLT_ROOMS fr\nJOIN \n    FCLT_MAJOR_USE fm ON fr.FCLT_MAJOR_USE_KEY = fm.FCLT_MAJOR_USE_KEY\nWHERE \n    fm.MAJOR_USE NOT LIKE 'ZUSE%' \n    AND fr.MAJOR_USE_DESC NOT LIKE 'ZUSE%'\nGROUP BY \n    fm.ASSIGNABLE, fr.MAJOR_USE_DESC\nWITH ROLLUP\nHAVING \n    (GROUPING(fm.ASSIGNABLE) = 0 AND GROUPING(fr.MAJOR_USE_DESC) = 0) \n    OR (GROUPING(fm.ASSIGNABLE) = 1 AND GROUPING(fr.MAJOR_USE_DESC) = 1)\nORDER BY \n    ASSIGNABLE_STATUS, fr.MAJOR_USE_DESC;"
    },
    {
        "db_id": "dw",
        "question": "List each floor key and department name within the Stata building, as well as the number of rooms, total area, and average area per department on each floor. Include subtotals for each floor and a grand total across all floors. Sort the results by floor key and department name in ascending order. Exclude departments without any rooms in the building. Only the first row of each floor group should include the floor key, and the subtotal and grand total rows should not include floor key or department name. Number of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    CASE WHEN GROUPING(f.FLOOR_KEY) = 0 THEN f.FLOOR_KEY ELSE NULL END AS FLOOR_KEY,\n    CASE WHEN GROUPING(o.ORGANIZATION_NAME) = 0 THEN o.ORGANIZATION_NAME ELSE NULL END AS DEPARTMENT_NAME,\n    COUNT(DISTINCT r.FAC_ROOM_KEY) AS NUMBER_OF_ROOMS,\n    FORMAT(ROUND(SUM(CAST(r.AREA AS DECIMAL))), 0) AS TOTAL_AREA,\n    FORMAT(ROUND(AVG(CAST(r.AREA AS DECIMAL))), 0) AS AVERAGE_AREA_PER_DEPARTMENT\nFROM \n    FAC_ROOMS r\nJOIN \n    BUILDINGS b ON b.BUILDING_KEY = r.BUILDING_KEY\nJOIN \n    FAC_FLOOR f ON f.FLOOR_KEY = r.FLOOR_KEY\nJOIN \n    FCLT_ORGANIZATION o ON o.FCLT_ORGANIZATION_KEY = r.ORGANIZATION_KEY\nWHERE \n    b.BUILDING_NAME = 'Ray and Maria Stata Center'\nGROUP BY \n    f.FLOOR_KEY, o.ORGANIZATION_NAME WITH ROLLUP\nHAVING \n    COUNT(DISTINCT r.FAC_ROOM_KEY) > 0\nORDER BY \n    f.FLOOR_KEY ASC, o.ORGANIZATION_NAME ASC;"
    },
    {
        "db_id": "dw",
        "question": "List each building key and floor key within the department of facilities, the number of rooms, total area, average area per floor, building name, access level, zip code, and city. Include subtotals for each building and a grand total across all buildings. The subtotals and grand total should not include zip code or city. Numbers of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    r.BUILDING_KEY,\n    r.FLOOR_KEY,\n    COUNT(DISTINCT r.FAC_ROOM_KEY) AS NUMBER_OF_ROOMS,\n    FORMAT(ROUND(SUM(r.AREA)), 0) AS TOTAL_AREA,\n    FORMAT(ROUND(SUM(r.AREA) / COUNT(DISTINCT r.FLOOR_KEY)), 0) AS AVG_AREA_PER_FLOOR,\n    b.BUILDING_NAME_LONG,\n    b.ACCESS_LEVEL_NAME,\n    a.POSTAL_CODE,\n    a.CITY\nFROM \n    FAC_ROOMS r\nJOIN \n    FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY\nJOIN \n    FAC_BUILDING b ON r.BUILDING_KEY = b.FAC_BUILDING_KEY\nJOIN \n    FAC_BUILDING_ADDRESS a ON r.BUILDING_KEY = a.BUILDING_KEY\nWHERE \n    o.ORGANIZATION_NAME = 'DP OF FACILITIES'\n    AND a.ADDRESS_PURPOSE = 'STREET'\nGROUP BY \n    r.BUILDING_KEY, r.FLOOR_KEY, b.BUILDING_NAME_LONG, b.ACCESS_LEVEL_NAME, a.POSTAL_CODE, a.CITY\nWITH ROLLUP\nHAVING \n    (GROUPING(r.BUILDING_KEY) = 0 AND GROUPING(r.FLOOR_KEY) = 0) \n    OR (GROUPING(r.BUILDING_KEY) = 0 AND GROUPING(r.FLOOR_KEY) = 1)\n    OR (GROUPING(r.BUILDING_KEY) = 1 AND GROUPING(r.FLOOR_KEY) = 1)\nORDER BY \n    r.BUILDING_KEY, r.FLOOR_KEY;"
    },
    {
        "db_id": "dw",
        "question": "List the department, school, course number, subject title, total number of enrolled students, term code, and count of distinct catalog ISBNs. Add a summary row at the bottom showing the total number of students and distinct catalog ISBNs for the current term in the format of ('TOTAL:', null, null, null, total number of students, null, number of distinct catalog ISBNs).",
        "predicted_sql": "SELECT \n    OFFER_DEPT_NAME AS department,\n    OFFER_SCHOOL_NAME AS school,\n    COURSE_NUMBER AS course_number,\n    SUBJECT_TITLE AS subject_title,\n    SUM(NUM_ENROLLED_STUDENTS) AS total_enrolled_students,\n    LSO.TERM_CODE AS term_code,\n    COUNT(DISTINCT LRC.CATALOG_ISBN) AS distinct_catalog_isbns\nFROM \n    LIBRARY_SUBJECT_OFFERED LSO\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LSO.LIBRARY_SUBJECT_OFFERED_KEY = LRMD.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    ACADEMIC_TERM_PARAMETER ATP ON LSO.TERM_CODE = ATP.TERM_CODE\nWHERE \n    ATP.IS_CURRENT_TERM = 'Y'\nGROUP BY \n    OFFER_DEPT_NAME, OFFER_SCHOOL_NAME, COURSE_NUMBER, SUBJECT_TITLE, LSO.TERM_CODE\n\nUNION ALL\n\nSELECT \n    'TOTAL:' AS department,\n    NULL AS school,\n    NULL AS course_number,\n    NULL AS subject_title,\n    SUM(NUM_ENROLLED_STUDENTS) AS total_enrolled_students,\n    NULL AS term_code,\n    COUNT(DISTINCT LRC.CATALOG_ISBN) AS distinct_catalog_isbns\nFROM \n    LIBRARY_SUBJECT_OFFERED LSO\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LSO.LIBRARY_SUBJECT_OFFERED_KEY = LRMD.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG LRC ON LRMD.LIBRARY_RESERVE_CATALOG_KEY = LRC.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    ACADEMIC_TERM_PARAMETER ATP ON LSO.TERM_CODE = ATP.TERM_CODE\nWHERE \n    ATP.IS_CURRENT_TERM = 'Y';"
    },
    {
        "db_id": "dw",
        "question": "For each mailing list that involves subscribers that work in departments with names starting with 'Computer Science', state the ownership type, the list name, the number of owners, and the number of subscribers. Display the ownership type only if it differs from the previous entry. Include subtotals (the corresponding type field shoud be 'SUBTOTAL') for each ownership type and a grand total (the corresponding type field shoud be 'TOTAL') across all ownership types.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN GROUPING(ml.MOIRA_LIST_NAME) = 1 AND GROUPING(mlo.OWNER_TYPE) = 0 THEN 'SUBTOTAL'\n        WHEN GROUPING(ml.MOIRA_LIST_NAME) = 1 AND GROUPING(mlo.OWNER_TYPE) = 1 THEN 'TOTAL'\n        ELSE mlo.OWNER_TYPE\n    END AS OWNER_TYPE,\n    ml.MOIRA_LIST_NAME,\n    COUNT(DISTINCT mlo.OWNER) AS NUMBER_OF_OWNERS,\n    COUNT(DISTINCT mld.MOIRA_LIST_MEMBER_MIT_ID) AS NUMBER_OF_SUBSCRIBERS\nFROM \n    MOIRA_LIST_DETAIL mld\nJOIN \n    MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY\nJOIN \n    MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY\nJOIN \n    EMPLOYEE_DIRECTORY ed ON ed.MIT_ID = mld.MOIRA_LIST_MEMBER_MIT_ID\nWHERE \n    ed.DEPARTMENT_NAME LIKE 'Computer Science%'\nGROUP BY \n    mlo.OWNER_TYPE, ml.MOIRA_LIST_NAME WITH ROLLUP\nHAVING \n    (GROUPING(ml.MOIRA_LIST_NAME) = 0 OR GROUPING(mlo.OWNER_TYPE) = 1)\nORDER BY \n    mlo.OWNER_TYPE, ml.MOIRA_LIST_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list its name, number of unique sessions, total number of attendees, active period (in the format of 'beginning term code-end term code'), the most common sponsor name, and the most common session start time. Include a grand total row showing the total number of sessions and attendees across all categories in the format of ('TOTAL', number of sessions, number of attendees, null, null, null).",
        "predicted_sql": "SELECT \n    c.IAP_CATEGORY_NAME AS name,\n    COUNT(DISTINCT s.IAP_SUBJECT_SESSION_KEY) AS number_of_sessions,\n    SUM(d.MAX_ENROLLMENT) AS total_number_of_attendees,\n    CONCAT(MIN(d.TERM_CODE), '-', MAX(d.TERM_CODE)) AS active_period,\n    (SELECT sp.SPONSOR_NAME \n     FROM IAP_SUBJECT_SPONSOR sp \n     JOIN IAP_SUBJECT_DETAIL d2 ON sp.IAP_SUBJECT_SPONSOR_KEY = d2.IAP_SUBJECT_SPONSOR_KEY \n     WHERE d2.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY \n     GROUP BY sp.SPONSOR_NAME \n     ORDER BY COUNT(*) DESC \n     LIMIT 1) AS most_common_sponsor_name,\n    (SELECT ss.SESSION_START_TIME \n     FROM IAP_SUBJECT_SESSION ss \n     JOIN IAP_SUBJECT_DETAIL d3 ON ss.IAP_SUBJECT_SESSION_KEY = d3.IAP_SUBJECT_SESSION_KEY \n     WHERE d3.IAP_SUBJECT_CATEGORY_KEY = c.IAP_SUBJECT_CATEGORY_KEY \n     GROUP BY ss.SESSION_START_TIME \n     ORDER BY COUNT(*) DESC \n     LIMIT 1) AS most_common_session_start_time\nFROM \n    IAP_SUBJECT_CATEGORY c\nJOIN \n    IAP_SUBJECT_DETAIL d ON c.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    IAP_SUBJECT_SESSION s ON d.IAP_SUBJECT_SESSION_KEY = s.IAP_SUBJECT_SESSION_KEY\nGROUP BY \n    c.IAP_CATEGORY_NAME\n\nUNION ALL\n\nSELECT \n    'TOTAL',\n    COUNT(DISTINCT d.IAP_SUBJECT_SESSION_KEY),\n    SUM(d.MAX_ENROLLMENT),\n    NULL,\n    NULL,\n    NULL\nFROM \n    IAP_SUBJECT_DETAIL d;"
    },
    {
        "db_id": "dw",
        "question": "For each building type, list the name of the building type, the number of buildings that are not subdivisions, number of employees, number of unique building street address, number of unique city, number of unique state, number of unique postal code, and average gross square footage per employee. For building type of 'resident', display it as 'RESIDENTIAL'. Include a grand total across all building types (the corresponding type field is 'TOTAL').",
        "predicted_sql": "SELECT \n    CASE \n        WHEN bldg.BUILDING_TYPE = 'RESIDENT' THEN 'RESIDENTIAL'\n        ELSE bldg.BUILDING_TYPE\n    END AS BUILDING_TYPE,\n    COUNT(DISTINCT CASE WHEN bldg.PARENT_BUILDING_NUMBER IS NULL THEN bldg.FCLT_BUILDING_KEY END) AS NUM_BUILDINGS_NOT_SUBDIVISIONS,\n    COUNT(DISTINCT emp.MIT_ID) AS NUM_EMPLOYEES,\n    COUNT(DISTINCT CASE WHEN addr.ADDRESS_PURPOSE = 'STREET' THEN bldg_street.BUILDING_STREET_ADDRESS END) AS NUM_UNIQUE_BUILDING_STREET_ADDRESS,\n    COUNT(DISTINCT addr.CITY) AS NUM_UNIQUE_CITY,\n    COUNT(DISTINCT addr.STATE) AS NUM_UNIQUE_STATE,\n    COUNT(DISTINCT addr.POSTAL_CODE) AS NUM_UNIQUE_POSTAL_CODE,\n    AVG(bldg.EXT_GROSS_AREA / NULLIF(COUNT(DISTINCT emp.MIT_ID), 0)) AS AVG_GROSS_SQUARE_FOOTAGE_PER_EMPLOYEE\nFROM \n    FCLT_BUILDING_HIST bldg\nLEFT JOIN \n    FAC_BUILDING_ADDRESS addr ON bldg.FCLT_BUILDING_KEY = addr.BUILDING_KEY\nLEFT JOIN \n    BUILDINGS bldg_street ON addr.BUILDING_KEY = bldg_street.BUILDING_KEY\nLEFT JOIN \n    FAC_ROOMS room ON bldg_street.BUILDING_KEY = room.BUILDING_KEY\nLEFT JOIN \n    EMPLOYEE_DIRECTORY emp ON room.FAC_ROOM_KEY = emp.OFFICE_LOCATION\nGROUP BY \n    BUILDING_TYPE WITH ROLLUP\nHAVING \n    BUILDING_TYPE IS NOT NULL OR GROUPING(BUILDING_TYPE) = 1"
    },
    {
        "db_id": "dw",
        "question": "Group spaces in the Stata building by the access level and usage type. For each group, state the access level, usage type, name of the space, the number of spaces, total area across all rooms in the space, and average area across all rooms in the space. Display the access level only if it differs from the previous entry. Include subtotals for each access level, usage type, and space name, subtotals for each access level, and a grand total across all access levels. Exclude usage type that includes \"STORAGE\". All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    IF(@prev_access_level = zrl.ACCESS_LEVEL, NULL, zrl.ACCESS_LEVEL) AS access_level,\n    su.SPACE_USAGE AS usage_type,\n    fo.DLC_NAME AS space_name,\n    COUNT(DISTINCT sd.BUILDING_ROOM) AS number_of_spaces,\n    FORMAT(SUM(sd.ROOM_SQUARE_FOOTAGE), 0) AS total_area,\n    FORMAT(ROUND(AVG(sd.ROOM_SQUARE_FOOTAGE)), 0) AS average_area\nFROM \n    SPACE_DETAIL sd\nJOIN \n    SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY\nJOIN \n    FCLT_ORGANIZATION fo ON su.FCLT_ORGANIZATION_KEY = fo.FCLT_ORGANIZATION_KEY\nJOIN \n    ZPM_ROOMS_LOAD zrl ON sd.BUILDING_ROOM = zrl.BUILDING_ROOM\nJOIN \n    SPACE_USAGE su ON sd.SPACE_USAGE_KEY = su.SPACE_USAGE_KEY\nWHERE \n    sd.BUILDING_KEY = '32' -- Assuming '32' is the Stata building key\n    AND su.SPACE_USAGE NOT LIKE '%STORAGE%'\nGROUP BY \n    zrl.ACCESS_LEVEL, su.SPACE_USAGE, fo.DLC_NAME\nWITH ROLLUP\nHAVING \n    su.SPACE_USAGE IS NOT NULL\nORDER BY \n    zrl.ACCESS_LEVEL, su.SPACE_USAGE, fo.DLC_NAME;"
    },
    {
        "db_id": "dw",
        "question": "List each organization's break group, ID, name, and formatted name according to its level, along with whether its members are emeritus or non-emeritus. Also, include the organization number, level, employer count, and hierarchy type for each organization. Exclude organizations '139' and '250'. Sort the results by hierarchy type and ensure totals for employer counts are displayed.",
        "predicted_sql": "SELECT \n    FCLT_ORGANIZATION.ORGANIZATION_SORT AS break_group,\n    FCLT_ORGANIZATION.ORGANIZATION_ID AS ID,\n    FCLT_ORGANIZATION.ORGANIZATION_NAME AS name,\n    CONCAT(FCLT_ORGANIZATION.ORGANIZATION_NAME, ' (', FCLT_ORGANIZATION.ORGANIZATION_LEVEL, ')') AS formatted_name,\n    FCLT_ORGANIZATION.ORGANIZATION_LEVEL AS level,\n    FCLT_ORGANIZATION.ORGANIZATION_NUMBER AS number,\n    COUNT(DISTINCT HR_FACULTY_ROSTER.MIT_ID) AS employer_count,\n    MASTER_DEPT_HIERARCHY.HIERARCHY_TYPE AS hierarchy_type,\n    CASE \n        WHEN HR_FACULTY_ROSTER.EMERITUS_STATUS = 'Emeritus' THEN 'Emeritus'\n        ELSE 'Non-Emeritus'\n    END AS member_status\nFROM \n    FCLT_ORGANIZATION\nJOIN \n    MASTER_DEPT_HIERARCHY ON FCLT_ORGANIZATION.DLC_KEY = MASTER_DEPT_HIERARCHY.DLC_KEY\nJOIN \n    HR_ORG_UNIT ON FCLT_ORGANIZATION.DLC_KEY = HR_ORG_UNIT.DLC_KEY\nJOIN \n    HR_FACULTY_ROSTER ON HR_ORG_UNIT.HR_ORG_UNIT_TITLE = HR_FACULTY_ROSTER.HR_ORG_UNIT_TITLE\nWHERE \n    FCLT_ORGANIZATION.ORGANIZATION_ID <> '250'\nGROUP BY \n    FCLT_ORGANIZATION.ORGANIZATION_SORT, \n    FCLT_ORGANIZATION.ORGANIZATION_ID, \n    FCLT_ORGANIZATION.ORGANIZATION_NAME, \n    FCLT_ORGANIZATION.ORGANIZATION_LEVEL, \n    FCLT_ORGANIZATION.ORGANIZATION_NUMBER, \n    MASTER_DEPT_HIERARCHY.HIERARCHY_TYPE, \n    member_status\nORDER BY \n    MASTER_DEPT_HIERARCHY.HIERARCHY_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its title, name of the building of the course location, duration (in terms of days), and a running average of the duration (in terms of days) using a window of two preceding and two following courses (partitioned by academic year and sorted by course start date).",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE AS title,\n    b.BUILDING_NAME AS building_name,\n    DATEDIFF(t.TERM_END_DATE, t.TERM_START_DATE) AS duration,\n    AVG(DATEDIFF(t.TERM_END_DATE, t.TERM_START_DATE)) \n        OVER (PARTITION BY c.ACADEMIC_YEAR ORDER BY t.TERM_START_DATE \n              ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS running_average_duration\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS t ON c.EFFECTIVE_TERM_CODE = t.TERM_CODE\nJOIN \n    FCLT_ROOMS r ON c.SUBJECT_ID = r.FCLT_ROOM_KEY\nJOIN \n    FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nORDER BY \n    c.ACADEMIC_YEAR, t.TERM_START_DATE;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, the start date, the name of the course before it, and the name of the course after it, access level of the building, and the assignable area of the room used for the course, sorted by the ascending order start date and course name.",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE AS course_name,\n    b.BUILDING_NAME_LONG AS building_name,\n    a.TERM_START_DATE AS start_date,\n    LAG(c.SUBJECT_TITLE) OVER (ORDER BY a.TERM_START_DATE, c.SUBJECT_TITLE) AS previous_course_name,\n    LEAD(c.SUBJECT_TITLE) OVER (ORDER BY a.TERM_START_DATE, c.SUBJECT_TITLE) AS next_course_name,\n    b.ACCESS_LEVEL_NAME AS access_level,\n    r.AREA AS assignable_area\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS a ON c.TERM_CODE = a.TERM_CODE\nJOIN \n    FCLT_ROOMS r ON c.SUBJECT_ID = r.FCLT_ROOM_KEY\nJOIN \n    FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nORDER BY \n    a.TERM_START_DATE ASC, \n    c.SUBJECT_TITLE ASC;"
    },
    {
        "db_id": "dw",
        "question": "For each course, list its name, name of the building of the course location, and the cumulative number of courses, including the course itself, held in the same year or preceding years (partitioned by academic year and sorted in the ascending order of course start date).",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE AS course_name,\n    b.BUILDING_NAME AS building_name,\n    COUNT(*) OVER (PARTITION BY c.ACADEMIC_YEAR ORDER BY t.TERM_START_DATE) AS cumulative_courses\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    ACADEMIC_TERMS t ON c.EFFECTIVE_TERM_CODE = t.TERM_CODE\nJOIN \n    FCLT_ROOMS r ON c.MEET_PLACE = r.FCLT_ROOM_KEY\nJOIN \n    FCLT_BUILDING b ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\nORDER BY \n    c.ACADEMIC_YEAR, t.TERM_START_DATE;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the cluster type. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), cluster type, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and cluster type.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN a.IS_CURRENT_TERM = 'Y' THEN 'CURRENT'\n        ELSE 'NON-CURRENT'\n    END AS current_status,\n    s.CLUSTER_TYPE,\n    MAX(DATEDIFF(a.TERM_END_DATE, a.TERM_START_DATE)) AS max_duration_days,\n    MAX(s.TOTAL_UNITS) AS max_units,\n    AVG(DATEDIFF(a.TERM_END_DATE, a.TERM_START_DATE)) AS avg_duration_days,\n    AVG(s.TOTAL_UNITS) AS avg_units\nFROM \n    SUBJECT_SUMMARY s\nJOIN \n    ACADEMIC_TERMS_ALL a ON s.TERM_CODE = a.TERM_CODE\nWHERE \n    s.DEPARTMENT_NAME IN ('Biology', 'Chemistry')\nGROUP BY \n    current_status, s.CLUSTER_TYPE\nWITH ROLLUP\nHAVING \n    GROUPING(s.CLUSTER_TYPE) = 0 OR GROUPING(s.CLUSTER_TYPE) = 1\nORDER BY \n    current_status, s.CLUSTER_TYPE;"
    },
    {
        "db_id": "dw",
        "question": "Group courses in the biology and chemistry department by whether they are current or not and the department name. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), department name, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and department.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT'\n        ELSE 'NON-CURRENT'\n    END AS CURRENT_STATUS,\n    OFFER_DEPT_NAME AS DEPARTMENT_NAME,\n    MAX(DATEDIFF(TERM_END_DATE, TERM_START_DATE)) AS MAX_DURATION_DAYS,\n    MAX(TOTAL_UNITS) AS MAX_UNITS,\n    AVG(DATEDIFF(TERM_END_DATE, TERM_START_DATE)) AS AVG_DURATION_DAYS,\n    AVG(TOTAL_UNITS) AS AVG_UNITS\nFROM \n    ACADEMIC_TERMS_ALL\nJOIN \n    SUBJECT_SUMMARY ON ACADEMIC_TERMS_ALL.TERM_CODE = SUBJECT_SUMMARY.TERM_CODE\nJOIN \n    SUBJECT_OFFERED ON SUBJECT_SUMMARY.SUBJECT_ID = SUBJECT_OFFERED.SUBJECT_ID\nWHERE \n    OFFER_DEPT_NAME IN ('Biology', 'Chemistry')\nGROUP BY \n    IS_CURRENT_TERM, OFFER_DEPT_NAME\nWITH ROLLUP\nHAVING \n    (CURRENT_STATUS IS NOT NULL AND DEPARTMENT_NAME IS NOT NULL) OR (CURRENT_STATUS IS NULL AND DEPARTMENT_NAME IS NULL)\nORDER BY \n    CURRENT_STATUS, DEPARTMENT_NAME;"
    },
    {
        "db_id": "dw",
        "question": "Group master courses by department. For each group, state the name of the department, the master course code, the number of subjects, the total new shelf price of associated TIP materials, and the number of unique TIP materials. Display the department and master course only if it differs from the previous entry. Include subtotals for each department and a grand total across all departments. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
        "predicted_sql": "SELECT \n    OFFER_DEPT_NAME AS Department,\n    MASTER_COURSE_NUMBER AS MasterCourseCode,\n    COUNT(DISTINCT SUBJECT_ID) AS NumberOfSubjects,\n    FORMAT(SUM(NEW_SHELF_PRICE), 0) AS TotalNewShelfPrice,\n    COUNT(DISTINCT TIP_MATERIAL_KEY) AS NumberOfUniqueTIPMaterials\nFROM \n    TIP_SUBJECT_OFFERED\nJOIN \n    TIP_DETAIL ON TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY = TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY\nJOIN \n    TIP_MATERIAL ON TIP_DETAIL.TIP_MATERIAL_KEY = TIP_MATERIAL.TIP_MATERIAL_KEY\nGROUP BY \n    OFFER_DEPT_NAME, MASTER_COURSE_NUMBER\nWITH ROLLUP\nHAVING \n    (GROUPING(OFFER_DEPT_NAME) = 0 AND GROUPING(MASTER_COURSE_NUMBER) = 0) \n    OR (GROUPING(OFFER_DEPT_NAME) = 0 AND GROUPING(MASTER_COURSE_NUMBER) = 1)\nORDER BY \n    OFFER_DEPT_NAME, MASTER_COURSE_NUMBER;"
    },
    {
        "db_id": "dw",
        "question": "For each term and department, list the term, department, the number of courses, average number of equivalent subjects, the school name, and department phone number. Include subtotals for each term (the corresponding term field is 'SUBTOTAL') and a grand total across all terms (the corresponding term field is 'TOTAL'). Do not repeat the term if it is the same as the previous row. Sort the table by term and department.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN GROUPING(c.TERM_CODE) = 1 THEN 'TOTAL'\n        ELSE c.TERM_CODE\n    END AS TERM,\n    CASE \n        WHEN GROUPING(c.DEPARTMENT_NAME) = 1 THEN 'SUBTOTAL'\n        ELSE c.DEPARTMENT_NAME\n    END AS DEPARTMENT,\n    COUNT(DISTINCT c.SUBJECT_ID) AS NUMBER_OF_COURSES,\n    AVG(LENGTH(c.EQUIVALENT_SUBJECTS) - LENGTH(REPLACE(c.EQUIVALENT_SUBJECTS, ',', '')) + 1) AS AVG_EQUIVALENT_SUBJECTS,\n    d.SCHOOL_NAME,\n    a.DEPARTMENT_PHONE_NUMBER\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    SIS_DEPARTMENT d ON c.DEPARTMENT_CODE = d.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT a ON a.SIS_ADMIN_DEPARTMENT_CODE = d.DEPARTMENT_CODE\nGROUP BY \n    c.TERM_CODE, c.DEPARTMENT_NAME, d.SCHOOL_NAME, a.DEPARTMENT_PHONE_NUMBER\nWITH ROLLUP\nORDER BY \n    TERM, DEPARTMENT;"
    },
    {
        "db_id": "dw",
        "question": "Group sessions by their current term status. For each group, state the status ('CURRENT' if is current term and 'NOT CURRENT' otherwise), name of the session, number of IAP sessions, total IAP session time in days, and average IAP session time in days. Show a subtotal for each current status and a grand total row across all status. Order the results by current status and cluster type. Display the the current status only if it differs from the previous entry.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN AT.IS_CURRENT_TERM = 'Y' THEN 'CURRENT' \n        ELSE 'NOT CURRENT' \n    END AS current_status,\n    ISC.IAP_CATEGORY_NAME AS session_name,\n    COUNT(DISTINCT ISS.IAP_SUBJECT_SESSION_KEY) AS number_of_iap_sessions,\n    SUM(DATEDIFF(ISS.SESSION_END_TIME, ISS.SESSION_START_TIME)) AS total_iap_session_time_days,\n    AVG(DATEDIFF(ISS.SESSION_END_TIME, ISS.SESSION_START_TIME)) AS average_iap_session_time_days\nFROM \n    IAP_SUBJECT_DETAIL ISD\nJOIN \n    ACADEMIC_TERMS AT ON ISD.TERM_CODE = AT.TERM_CODE\nJOIN \n    IAP_SUBJECT_SESSION ISS ON ISD.IAP_SUBJECT_SESSION_KEY = ISS.IAP_SUBJECT_SESSION_KEY\nJOIN \n    IAP_SUBJECT_CATEGORY ISC ON ISD.IAP_SUBJECT_CATEGORY_KEY = ISC.IAP_SUBJECT_CATEGORY_KEY\nGROUP BY \n    current_status, session_name\nWITH ROLLUP\nHAVING \n    (current_status IS NOT NULL AND session_name IS NOT NULL) OR (current_status IS NULL AND session_name IS NULL)\nORDER BY \n    current_status, session_name;"
    },
    {
        "db_id": "dw",
        "question": "List each academic year, the term code, and the number of newly introduced subjects in this term. Display the academic year only if it differs from the previous entry. Include a grand total (the corresponding year field should be 'TOTAL') stating the total number of subjects across all academic years.",
        "predicted_sql": "SELECT \n    CASE \n        WHEN @prev_year = ACADEMIC_TERMS_ALL.ACADEMIC_YEAR THEN ''\n        ELSE ACADEMIC_TERMS_ALL.ACADEMIC_YEAR\n    END AS academic_year,\n    ACADEMIC_TERMS_ALL.TERM_CODE,\n    COUNT(COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID) AS new_subjects_count\nFROM \n    ACADEMIC_TERMS_ALL\nJOIN \n    COURSE_CATALOG_SUBJECT_OFFERED ON ACADEMIC_TERMS_ALL.TERM_CODE = COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE\nWHERE \n    COURSE_CATALOG_SUBJECT_OFFERED.STATUS_CHANGE = 'New subject'\nGROUP BY \n    ACADEMIC_TERMS_ALL.ACADEMIC_YEAR, ACADEMIC_TERMS_ALL.TERM_CODE\nORDER BY \n    ACADEMIC_TERMS_ALL.ACADEMIC_YEAR, ACADEMIC_TERMS_ALL.TERM_CODE\n\nUNION ALL\n\nSELECT \n    'TOTAL' AS academic_year,\n    NULL AS TERM_CODE,\n    COUNT(COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID) AS new_subjects_count\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED\nWHERE \n    COURSE_CATALOG_SUBJECT_OFFERED.STATUS_CHANGE = 'New subject';"
    },
    {
        "db_id": "dw",
        "question": "For email lists with names starting with e (case insensitive), containing 10 to 20 members inclusive, and where over 75% are computer science students, provide the list name, owner, and member count.",
        "predicted_sql": "SELECT \n    ML.MOIRA_LIST_NAME, \n    MLO.OWNER, \n    COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER) AS MEMBER_COUNT\nFROM \n    MOIRA_LIST ML\nJOIN \n    MOIRA_LIST_DETAIL MLD ON ML.MOIRA_LIST_KEY = MLD.MOIRA_LIST_KEY\nJOIN \n    MOIRA_LIST_OWNER MLO ON MLD.MOIRA_LIST_OWNER_KEY = MLO.MOIRA_LIST_OWNER_KEY\nJOIN \n    SE_PERSON SP ON MLD.MOIRA_LIST_MEMBER = SP.KRB_NAME\nJOIN \n    MIT_STUDENT_DIRECTORY MSD ON SP.FULL_NAME = MSD.FULL_NAME\nWHERE \n    ML.MOIRA_LIST_NAME LIKE 'e%' \n    AND MSD.DEPARTMENT_NAME = 'Electrical Eng & Computer Sci'\nGROUP BY \n    ML.MOIRA_LIST_NAME, MLO.OWNER\nHAVING \n    COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER) BETWEEN 10 AND 20\n    AND COUNT(DISTINCT CASE WHEN MSD.DEPARTMENT_NAME = 'Electrical Eng & Computer Sci' THEN MLD.MOIRA_LIST_MEMBER END) / COUNT(DISTINCT MLD.MOIRA_LIST_MEMBER) > 0.75;"
    },
    {
        "db_id": "dw",
        "question": "For students with last names starting with K, list their names, the phone numbers of departments they belong to, total number of mailing lists each student is in, and the average size of the mailing lists each student is in.",
        "predicted_sql": "SELECT \n    msd.FULL_NAME,\n    sad.DEPARTMENT_PHONE_NUMBER,\n    COUNT(DISTINCT mld.MOIRA_LIST_KEY) AS total_mailing_lists,\n    AVG(mld.COUNTER) AS average_list_size\nFROM \n    MIT_STUDENT_DIRECTORY msd\nJOIN \n    SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE\nJOIN \n    SE_PERSON sp ON msd.FULL_NAME = sp.FULL_NAME\nJOIN \n    MOIRA_LIST_DETAIL mld ON sp.MIT_ID = mld.MOIRA_LIST_MEMBER_MIT_ID\nWHERE \n    msd.LAST_NAME LIKE 'K%'\nGROUP BY \n    msd.FULL_NAME, sad.DEPARTMENT_PHONE_NUMBER;"
    },
    {
        "db_id": "dw",
        "question": "From the 100 email lists with the most number of subscribers, list their names, their total number of subscribers, their public status, the name of the department with the most presence in the list, and the number of students from this department in the list.",
        "predicted_sql": "SELECT \n    ml.MOIRA_LIST_NAME,\n    COUNT(mld.MOIRA_LIST_MEMBER) AS total_subscribers,\n    ml.IS_PUBLIC,\n    sd.DEPARTMENT_NAME,\n    COUNT(msd.FULL_NAME) AS department_student_count\nFROM \n    MOIRA_LIST ml\nJOIN \n    MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY\nJOIN \n    MIT_STUDENT_DIRECTORY msd ON mld.MOIRA_LIST_MEMBER = msd.EMAIL_ADDRESS\nJOIN \n    SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nGROUP BY \n    ml.MOIRA_LIST_NAME, ml.IS_PUBLIC, sd.DEPARTMENT_NAME\nORDER BY \n    total_subscribers DESC\nLIMIT 100;"
    },
    {
        "db_id": "dw",
        "question": "Calculate the total assignable and non-assignable area for each building by summing up the respective areas of all its floors. For each building, list the building name, building number, total assignable area, total non-assignable area, and total room count, sorted in descending order of the total assignable area.",
        "predicted_sql": "SELECT \n    b.BUILDING_NAME AS building_name,\n    b.BUILDING_NUMBER AS building_number,\n    SUM(f.ASSIGNABLE_AREA) AS total_assignable_area,\n    SUM(f.NON_ASSIGNABLE_AREA) AS total_non_assignable_area,\n    COUNT(DISTINCT r.FAC_ROOM_KEY) AS total_room_count\nFROM \n    FAC_BUILDING b\nJOIN \n    FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nJOIN \n    FAC_ROOMS r ON f.BUILDING_KEY = r.BUILDING_KEY AND f.FLOOR = r.FLOOR\nGROUP BY \n    b.BUILDING_NAME, b.BUILDING_NUMBER\nORDER BY \n    total_assignable_area DESC;"
    },
    {
        "db_id": "dw",
        "question": "List all rooms in building 45, including their full name, area, major use, the organization that occupies them, the count of rooms per major use, and the total area occupied by rooms for each organization.",
        "predicted_sql": "SELECT \n    FR.FAC_ROOM_KEY,\n    FR.ROOM_FULL_NAME,\n    FR.AREA,\n    FMU.MAJOR_USE,\n    FO.ORGANIZATION_NAME,\n    COUNT(FR.FAC_ROOM_KEY) OVER (PARTITION BY FMU.MAJOR_USE) AS ROOM_COUNT_PER_MAJOR_USE,\n    SUM(FR.AREA) OVER (PARTITION BY FO.ORGANIZATION_NAME) AS TOTAL_AREA_PER_ORGANIZATION\nFROM \n    FAC_ROOMS FR\nJOIN \n    FAC_MAJOR_USE FMU ON FR.MAJOR_USE_KEY = FMU.MAJOR_USE_KEY\nJOIN \n    FAC_ORGANIZATION FO ON FR.ORGANIZATION_KEY = FO.ORGANIZATION_KEY\nWHERE \n    FR.BUILDING_KEY = '45';"
    },
    {
        "db_id": "dw",
        "question": "List the name, number, construction date, and type of all buildings, along with the count of addresses associated with each building, the average gross area of the buildings, and the total number of rooms in each building. Sort the results by building name.",
        "predicted_sql": "SELECT \n    fb.BUILDING_NAME,\n    fb.BUILDING_NUMBER,\n    fb.DATE_BUILT,\n    fb.BUILDING_TYPE,\n    COUNT(fba.BUILDING_ADDRESS_KEY) AS address_count,\n    AVG(fb.EXT_GROSS_AREA) AS average_gross_area,\n    COUNT(fr.FAC_ROOM_KEY) AS total_rooms\nFROM \n    FAC_BUILDING fb\nLEFT JOIN \n    FAC_BUILDING_ADDRESS fba ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY\nLEFT JOIN \n    FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY\nGROUP BY \n    fb.BUILDING_NAME, fb.BUILDING_NUMBER, fb.DATE_BUILT, fb.BUILDING_TYPE\nORDER BY \n    fb.BUILDING_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list its name, number of unique courses offered, the number of unique reserved materials, and the number of unique instructors associated with those courses, sorted by the number of unique courses offered in descending order.",
        "predicted_sql": "SELECT \n    lso.OFFER_DEPT_NAME AS department_name,\n    COUNT(DISTINCT lso.MASTER_COURSE_NUMBER) AS unique_courses_offered,\n    COUNT(DISTINCT lrc.LIBRARY_RESERVE_CATALOG_KEY) AS unique_reserved_materials,\n    COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS unique_instructors\nFROM \n    LIBRARY_SUBJECT_OFFERED lso\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lso.LIBRARY_SUBJECT_OFFERED_KEY = lrmd.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    lso.OFFER_DEPT_NAME\nORDER BY \n    unique_courses_offered DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each course title, list the title, the total number of reserved materials, and the count of distinct material status associated with those materials, sorted by the total number of reserved materials in descending order.",
        "predicted_sql": "SELECT \n    lso.SUBJECT_TITLE AS title,\n    COUNT(lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS total_reserved_materials,\n    COUNT(DISTINCT lrmd.LIBRARY_MATERIAL_STATUS_KEY) AS distinct_material_status_count\nFROM \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd\nJOIN \n    LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    lso.SUBJECT_TITLE\nORDER BY \n    total_reserved_materials DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each instructor, list their name, the number of unique courses they teach, the total number of material assignments, average publication year, and number of distinct status, sorted by the number of unique courses in descending order.",
        "predicted_sql": "SELECT \n    lci.INSTRUCTOR_NAME,\n    COUNT(DISTINCT lci.COURSE_NAME) AS unique_courses,\n    COUNT(lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS total_material_assignments,\n    AVG(CASE WHEN lrc.CATALOG_YEAR != '0' THEN CAST(lrc.CATALOG_YEAR AS UNSIGNED) END) AS average_publication_year,\n    COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS distinct_status\nFROM \n    LIBRARY_COURSE_INSTRUCTOR lci\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY\nJOIN \n    LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\nGROUP BY \n    lci.INSTRUCTOR_NAME\nORDER BY \n    unique_courses DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each publication year, list the year, the total number of reserved materials, the average length of their titles, distinct number of status, and number of courses, sorted by publication year in descending order.",
        "predicted_sql": "SELECT \n    CATALOG_YEAR AS publication_year,\n    COUNT(DISTINCT LRC.LIBRARY_RESERVE_CATALOG_KEY) AS total_reserved_materials,\n    AVG(CHAR_LENGTH(CATALOG_TITLE)) AS average_title_length,\n    COUNT(DISTINCT LMS.LIBRARY_MATERIAL_STATUS) AS distinct_status_count,\n    COUNT(DISTINCT LCI.COURSE_NAME) AS number_of_courses\nFROM \n    LIBRARY_RESERVE_CATALOG LRC\nJOIN \n    LIBRARY_RESERVE_MATRL_DETAIL LRMD ON LRC.LIBRARY_RESERVE_CATALOG_KEY = LRMD.LIBRARY_RESERVE_CATALOG_KEY\nJOIN \n    LIBRARY_MATERIAL_STATUS LMS ON LRMD.LIBRARY_MATERIAL_STATUS_KEY = LMS.LIBRARY_MATERIAL_STATUS_KEY\nJOIN \n    LIBRARY_COURSE_INSTRUCTOR LCI ON LRMD.LIBRARY_COURSE_INSTRUCTOR_KEY = LCI.LIBRARY_COURSE_INSTRUCTOR_KEY\nGROUP BY \n    CATALOG_YEAR\nORDER BY \n    CATALOG_YEAR DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each IAP category, list the category name, the sponsor name, the number of activities offered, and the average fee per activity, sorted by the number of activities in descending order.",
        "predicted_sql": "SELECT \n    c.IAP_CATEGORY_NAME AS category_name,\n    s.SPONSOR_NAME AS sponsor_name,\n    COUNT(d.ACTIVITY_TITLE) AS number_of_activities,\n    AVG(d.FEE) AS average_fee_per_activity\nFROM \n    IAP_SUBJECT_CATEGORY c\nJOIN \n    IAP_SUBJECT_DETAIL d ON c.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY\nJOIN \n    IAP_SUBJECT_SPONSOR s ON d.IAP_SUBJECT_SPONSOR_KEY = s.IAP_SUBJECT_SPONSOR_KEY\nGROUP BY \n    c.IAP_CATEGORY_NAME, s.SPONSOR_NAME\nORDER BY \n    number_of_activities DESC;"
    },
    {
        "db_id": "dw",
        "question": "For each sponsor, list the sponsor name, the number of IAP sessions hosted, and the number of unique subjects organized.",
        "predicted_sql": "SELECT \n    s.SPONSOR_NAME,\n    COUNT(DISTINCT sd.IAP_SUBJECT_SESSION_KEY) AS number_of_sessions,\n    COUNT(DISTINCT sd.IAP_SUBJECT_CATEGORY_KEY) AS number_of_unique_subjects\nFROM \n    IAP_SUBJECT_SPONSOR s\nJOIN \n    IAP_SUBJECT_DETAIL sd ON s.IAP_SUBJECT_SPONSOR_KEY = sd.IAP_SUBJECT_SPONSOR_KEY\nGROUP BY \n    s.SPONSOR_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each person role and IAP category, list the role, the category name, the number of people in this role, and the average fee, sorted by the role count in descending order.",
        "predicted_sql": "SELECT \n    isp.PERSON_ROLE AS role, \n    isc.IAP_CATEGORY_NAME AS category_name, \n    COUNT(DISTINCT isp.IAP_SUBJECT_PERSON_KEY) AS number_of_people, \n    AVG(isd.FEE) AS average_fee\nFROM \n    IAP_SUBJECT_PERSON isp\nJOIN \n    IAP_SUBJECT_DETAIL isd ON isp.IAP_SUBJECT_PERSON_KEY = isd.IAP_SUBJECT_PERSON_KEY\nJOIN \n    IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY\nGROUP BY \n    isp.PERSON_ROLE, isc.IAP_CATEGORY_NAME\nORDER BY \n    number_of_people DESC;"
    },
    {
        "db_id": "dw",
        "question": "List the names of the buildings with the most floors. If there are ties, list each one separately.",
        "predicted_sql": "SELECT b.BUILDING_NAME\nFROM FAC_BUILDING b\nJOIN FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nGROUP BY b.BUILDING_NAME\nHAVING COUNT(DISTINCT f.LEVEL_ID) = (\n    SELECT MAX(floor_count)\n    FROM (\n        SELECT COUNT(DISTINCT LEVEL_ID) as floor_count\n        FROM FAC_FLOOR\n        GROUP BY BUILDING_KEY\n    ) as subquery\n)"
    },
    {
        "db_id": "dw",
        "question": "For subjects offered in the summer term, list the subject titles, number of instructors, and the length of the longest instructor name.",
        "predicted_sql": "SELECT \n    c.SUBJECT_TITLE,\n    COUNT(DISTINCT e.FULL_NAME) AS number_of_instructors,\n    MAX(CHAR_LENGTH(e.FULL_NAME)) AS longest_instructor_name_length\nFROM \n    COURSE_CATALOG_SUBJECT_OFFERED c\nJOIN \n    EMPLOYEE_DIRECTORY e ON c.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID\nJOIN \n    ACADEMIC_TERMS_ALL a ON c.TERM_CODE = a.TERM_CODE\nWHERE \n    c.IS_OFFERED_SUMMER_TERM = 'Y'\nGROUP BY \n    c.SUBJECT_TITLE;"
    },
    {
        "db_id": "dw",
        "question": "For the mailing list with owner key LIST69.377-keeper-xenon, list the owner, total number of mailing lists, and total number of members across all these mailing lists.",
        "predicted_sql": "SELECT \n    o.OWNER,\n    COUNT(DISTINCT l.MOIRA_LIST_KEY) AS total_mailing_lists,\n    COUNT(DISTINCT d.MOIRA_LIST_MEMBER) AS total_members\nFROM \n    MOIRA_LIST_OWNER o\nJOIN \n    MOIRA_LIST_DETAIL d ON o.MOIRA_LIST_OWNER_KEY = d.MOIRA_LIST_OWNER_KEY\nJOIN \n    MOIRA_LIST l ON d.MOIRA_LIST_KEY = l.MOIRA_LIST_KEY\nWHERE \n    o.MOIRA_LIST_OWNER_KEY = 'LIST69.377-keeper-xenon'\nGROUP BY \n    o.OWNER;"
    },
    {
        "db_id": "dw",
        "question": "For each school, list the school name, total number of courses that appear in SIS subject code catalog, and the total number of degree-granting courses that appear in SIS subject code catalog.",
        "predicted_sql": "SELECT \n    d.SCHOOL_NAME, \n    COUNT(DISTINCT sc.COURSE_NUMBER) AS total_courses,\n    COUNT(DISTINCT CASE WHEN cd.IS_DEGREE_GRANTING = 'Y' THEN sc.COURSE_NUMBER END) AS total_degree_granting_courses\nFROM \n    SIS_SUBJECT_CODE sc\nJOIN \n    SIS_COURSE_DESCRIPTION cd ON sc.COURSE_NUMBER = cd.COURSE\nJOIN \n    SIS_DEPARTMENT d ON cd.DEPARTMENT = d.DEPARTMENT_CODE\nGROUP BY \n    d.SCHOOL_NAME;"
    },
    {
        "db_id": "dw",
        "question": "For each department, list the department name, department phone number, number of students, and the length of the longest student full name in that department.",
        "predicted_sql": "SELECT \n    sd.DEPARTMENT_NAME,\n    sad.DEPARTMENT_PHONE_NUMBER,\n    COUNT(msd.EMAIL_ADDRESS) AS number_of_students,\n    MAX(CHAR_LENGTH(msd.FULL_NAME)) AS longest_student_full_name_length\nFROM \n    MIT_STUDENT_DIRECTORY msd\nJOIN \n    SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE\nJOIN \n    SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE\nGROUP BY \n    sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER;"
    }
]